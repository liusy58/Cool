---------  Test  ../../examples/arith.cl  ---------
2,1859c2,440
< #7 CLASS
< #7 TYPEID A
< #7 '{'
< #9 OBJECTID var
< #9 ':'
< #9 TYPEID Int
< #9 ASSIGN
< #9 INT_CONST 0
< #9 ';'
< #11 OBJECTID value
< #11 '('
< #11 ')'
< #11 ':'
< #11 TYPEID Int
< #11 '{'
< #11 OBJECTID var
< #11 '}'
< #11 ';'
< #13 OBJECTID set_var
< #13 '('
< #13 OBJECTID num
< #13 ':'
< #13 TYPEID Int
< #13 ')'
< #13 ':'
< #13 TYPEID SELF_TYPE
< #13 '{'
< #14 '{'
< #15 OBJECTID var
< #15 ASSIGN
< #15 OBJECTID num
< #15 ';'
< #16 OBJECTID self
< #16 ';'
< #17 '}'
< #18 '}'
< #18 ';'
< #20 OBJECTID method1
< #20 '('
< #20 OBJECTID num
< #20 ':'
< #20 TYPEID Int
< #20 ')'
< #20 ':'
< #20 TYPEID SELF_TYPE
< #20 '{'
< #21 OBJECTID self
< #22 '}'
< #22 ';'
< #24 OBJECTID method2
< #24 '('
< #24 OBJECTID num1
< #24 ':'
< #24 TYPEID Int
< #24 ','
< #24 OBJECTID num2
< #24 ':'
< #24 TYPEID Int
< #24 ')'
< #24 ':'
< #24 TYPEID B
< #24 '{'
< #25 '('
< #25 LET
< #25 OBJECTID x
< #25 ':'
< #25 TYPEID Int
< #25 IN
< #26 '{'
< #27 OBJECTID x
< #27 ASSIGN
< #27 OBJECTID num1
< #27 '+'
< #27 OBJECTID num2
< #27 ';'
< #28 '('
< #28 NEW
< #28 TYPEID B
< #28 ')'
< #28 '.'
< #28 OBJECTID set_var
< #28 '('
< #28 OBJECTID x
< #28 ')'
< #28 ';'
< #29 '}'
< #30 ')'
< #31 '}'
< #31 ';'
< #33 OBJECTID method3
< #33 '('
< #33 OBJECTID num
< #33 ':'
< #33 TYPEID Int
< #33 ')'
< #33 ':'
< #33 TYPEID C
< #33 '{'
< #34 '('
< #34 LET
< #34 OBJECTID x
< #34 ':'
< #34 TYPEID Int
< #34 IN
< #35 '{'
< #36 OBJECTID x
< #36 ASSIGN
< #36 '~'
< #36 OBJECTID num
< #36 ';'
< #37 '('
< #37 NEW
< #37 TYPEID C
< #37 ')'
< #37 '.'
< #37 OBJECTID set_var
< #37 '('
< #37 OBJECTID x
< #37 ')'
< #37 ';'
< #38 '}'
< #39 ')'
< #40 '}'
< #40 ';'
< #42 OBJECTID method4
< #42 '('
< #42 OBJECTID num1
< #42 ':'
< #42 TYPEID Int
< #42 ','
< #42 OBJECTID num2
< #42 ':'
< #42 TYPEID Int
< #42 ')'
< #42 ':'
< #42 TYPEID D
< #42 '{'
< #43 IF
< #43 OBJECTID num2
< #43 '<'
< #43 OBJECTID num1
< #43 THEN
< #44 '('
< #44 LET
< #44 OBJECTID x
< #44 ':'
< #44 TYPEID Int
< #44 IN
< #45 '{'
< #46 OBJECTID x
< #46 ASSIGN
< #46 OBJECTID num1
< #46 '-'
< #46 OBJECTID num2
< #46 ';'
< #47 '('
< #47 NEW
< #47 TYPEID D
< #47 ')'
< #47 '.'
< #47 OBJECTID set_var
< #47 '('
< #47 OBJECTID x
< #47 ')'
< #47 ';'
< #48 '}'
< #49 ')'
< #50 ELSE
< #51 '('
< #51 LET
< #51 OBJECTID x
< #51 ':'
< #51 TYPEID Int
< #51 IN
< #52 '{'
< #53 OBJECTID x
< #53 ASSIGN
< #53 OBJECTID num2
< #53 '-'
< #53 OBJECTID num1
< #53 ';'
< #54 '('
< #54 NEW
< #54 TYPEID D
< #54 ')'
< #54 '.'
< #54 OBJECTID set_var
< #54 '('
< #54 OBJECTID x
< #54 ')'
< #54 ';'
< #55 '}'
< #56 ')'
< #57 FI
< #58 '}'
< #58 ';'
< #60 OBJECTID method5
< #60 '('
< #60 OBJECTID num
< #60 ':'
< #60 TYPEID Int
< #60 ')'
< #60 ':'
< #60 TYPEID E
< #60 '{'
< #61 '('
< #61 LET
< #61 OBJECTID x
< #61 ':'
< #61 TYPEID Int
< #61 ASSIGN
< #61 INT_CONST 1
< #61 IN
< #62 '{'
< #63 '('
< #63 LET
< #63 OBJECTID y
< #63 ':'
< #63 TYPEID Int
< #63 ASSIGN
< #63 INT_CONST 1
< #63 IN
< #64 WHILE
< #64 OBJECTID y
< #64 LE
< #64 OBJECTID num
< #64 LOOP
< #65 '{'
< #66 OBJECTID x
< #66 ASSIGN
< #66 OBJECTID x
< #66 '*'
< #66 OBJECTID y
< #66 ';'
< #67 OBJECTID y
< #67 ASSIGN
< #67 OBJECTID y
< #67 '+'
< #67 INT_CONST 1
< #67 ';'
< #68 '}'
< #69 POOL
< #70 ')'
< #70 ';'
< #71 '('
< #71 NEW
< #71 TYPEID E
< #71 ')'
< #71 '.'
< #71 OBJECTID set_var
< #71 '('
< #71 OBJECTID x
< #71 ')'
< #71 ';'
< #72 '}'
< #73 ')'
< #74 '}'
< #74 ';'
< #76 '}'
< #76 ';'
< #78 CLASS
< #78 TYPEID B
< #78 INHERITS
< #78 TYPEID A
< #78 '{'
< #80 OBJECTID method5
< #80 '('
< #80 OBJECTID num
< #80 ':'
< #80 TYPEID Int
< #80 ')'
< #80 ':'
< #80 TYPEID E
< #80 '{'
< #81 '('
< #81 LET
< #81 OBJECTID x
< #81 ':'
< #81 TYPEID Int
< #81 IN
< #82 '{'
< #83 OBJECTID x
< #83 ASSIGN
< #83 OBJECTID num
< #83 '*'
< #83 OBJECTID num
< #83 ';'
< #84 '('
< #84 NEW
< #84 TYPEID E
< #84 ')'
< #84 '.'
< #84 OBJECTID set_var
< #84 '('
< #84 OBJECTID x
< #84 ')'
< #84 ';'
< #85 '}'
< #86 ')'
< #87 '}'
< #87 ';'
< #89 '}'
< #89 ';'
< #91 CLASS
< #91 TYPEID C
< #91 INHERITS
< #91 TYPEID B
< #91 '{'
< #93 OBJECTID method6
< #93 '('
< #93 OBJECTID num
< #93 ':'
< #93 TYPEID Int
< #93 ')'
< #93 ':'
< #93 TYPEID A
< #93 '{'
< #94 '('
< #94 LET
< #94 OBJECTID x
< #94 ':'
< #94 TYPEID Int
< #94 IN
< #95 '{'
< #96 OBJECTID x
< #96 ASSIGN
< #96 '~'
< #96 OBJECTID num
< #96 ';'
< #97 '('
< #97 NEW
< #97 TYPEID A
< #97 ')'
< #97 '.'
< #97 OBJECTID set_var
< #97 '('
< #97 OBJECTID x
< #97 ')'
< #97 ';'
< #98 '}'
< #99 ')'
< #100 '}'
< #100 ';'
< #102 OBJECTID method5
< #102 '('
< #102 OBJECTID num
< #102 ':'
< #102 TYPEID Int
< #102 ')'
< #102 ':'
< #102 TYPEID E
< #102 '{'
< #103 '('
< #103 LET
< #103 OBJECTID x
< #103 ':'
< #103 TYPEID Int
< #103 IN
< #104 '{'
< #105 OBJECTID x
< #105 ASSIGN
< #105 OBJECTID num
< #105 '*'
< #105 OBJECTID num
< #105 '*'
< #105 OBJECTID num
< #105 ';'
< #106 '('
< #106 NEW
< #106 TYPEID E
< #106 ')'
< #106 '.'
< #106 OBJECTID set_var
< #106 '('
< #106 OBJECTID x
< #106 ')'
< #106 ';'
< #107 '}'
< #108 ')'
< #109 '}'
< #109 ';'
< #111 '}'
< #111 ';'
< #113 CLASS
< #113 TYPEID D
< #113 INHERITS
< #113 TYPEID B
< #113 '{'
< #115 OBJECTID method7
< #115 '('
< #115 OBJECTID num
< #115 ':'
< #115 TYPEID Int
< #115 ')'
< #115 ':'
< #115 TYPEID Bool
< #115 '{'
< #116 '('
< #116 LET
< #116 OBJECTID x
< #116 ':'
< #116 TYPEID Int
< #116 ASSIGN
< #116 OBJECTID num
< #116 IN
< #117 IF
< #117 OBJECTID x
< #117 '<'
< #117 INT_CONST 0
< #117 THEN
< #117 OBJECTID method7
< #117 '('
< #117 '~'
< #117 OBJECTID x
< #117 ')'
< #117 ELSE
< #118 IF
< #118 INT_CONST 0
< #118 '='
< #118 OBJECTID x
< #118 THEN
< #118 BOOL_CONST true
< #118 ELSE
< #119 IF
< #119 INT_CONST 1
< #119 '='
< #119 OBJECTID x
< #119 THEN
< #119 BOOL_CONST false
< #119 ELSE
< #120 IF
< #120 INT_CONST 2
< #120 '='
< #120 OBJECTID x
< #120 THEN
< #120 BOOL_CONST false
< #120 ELSE
< #121 OBJECTID method7
< #121 '('
< #121 OBJECTID x
< #121 '-'
< #121 INT_CONST 3
< #121 ')'
< #122 FI
< #122 FI
< #122 FI
< #122 FI
< #123 ')'
< #124 '}'
< #124 ';'
< #126 '}'
< #126 ';'
< #128 CLASS
< #128 TYPEID E
< #128 INHERITS
< #128 TYPEID D
< #128 '{'
< #130 OBJECTID method6
< #130 '('
< #130 OBJECTID num
< #130 ':'
< #130 TYPEID Int
< #130 ')'
< #130 ':'
< #130 TYPEID A
< #130 '{'
< #131 '('
< #131 LET
< #131 OBJECTID x
< #131 ':'
< #131 TYPEID Int
< #131 IN
< #132 '{'
< #133 OBJECTID x
< #133 ASSIGN
< #133 OBJECTID num
< #133 '/'
< #133 INT_CONST 8
< #133 ';'
< #134 '('
< #134 NEW
< #134 TYPEID A
< #134 ')'
< #134 '.'
< #134 OBJECTID set_var
< #134 '('
< #134 OBJECTID x
< #134 ')'
< #134 ';'
< #135 '}'
< #136 ')'
< #137 '}'
< #137 ';'
< #139 '}'
< #139 ';'
< #155 CLASS
< #155 TYPEID A2I
< #155 '{'
< #157 OBJECTID c2i
< #157 '('
< #157 OBJECTID char
< #157 ':'
< #157 TYPEID String
< #157 ')'
< #157 ':'
< #157 TYPEID Int
< #157 '{'
< #158 IF
< #158 OBJECTID char
< #158 '='
< #158 STR_CONST "0"
< #158 THEN
< #158 INT_CONST 0
< #158 ELSE
< #159 IF
< #159 OBJECTID char
< #159 '='
< #159 STR_CONST "1"
< #159 THEN
< #159 INT_CONST 1
< #159 ELSE
< #160 IF
< #160 OBJECTID char
< #160 '='
< #160 STR_CONST "2"
< #160 THEN
< #160 INT_CONST 2
< #160 ELSE
< #161 IF
< #161 OBJECTID char
< #161 '='
< #161 STR_CONST "3"
< #161 THEN
< #161 INT_CONST 3
< #161 ELSE
< #162 IF
< #162 OBJECTID char
< #162 '='
< #162 STR_CONST "4"
< #162 THEN
< #162 INT_CONST 4
< #162 ELSE
< #163 IF
< #163 OBJECTID char
< #163 '='
< #163 STR_CONST "5"
< #163 THEN
< #163 INT_CONST 5
< #163 ELSE
< #164 IF
< #164 OBJECTID char
< #164 '='
< #164 STR_CONST "6"
< #164 THEN
< #164 INT_CONST 6
< #164 ELSE
< #165 IF
< #165 OBJECTID char
< #165 '='
< #165 STR_CONST "7"
< #165 THEN
< #165 INT_CONST 7
< #165 ELSE
< #166 IF
< #166 OBJECTID char
< #166 '='
< #166 STR_CONST "8"
< #166 THEN
< #166 INT_CONST 8
< #166 ELSE
< #167 IF
< #167 OBJECTID char
< #167 '='
< #167 STR_CONST "9"
< #167 THEN
< #167 INT_CONST 9
< #167 ELSE
< #168 '{'
< #168 OBJECTID abort
< #168 '('
< #168 ')'
< #168 ';'
< #168 INT_CONST 0
< #168 ';'
< #168 '}'
< #170 FI
< #170 FI
< #170 FI
< #170 FI
< #170 FI
< #170 FI
< #170 FI
< #170 FI
< #170 FI
< #170 FI
< #171 '}'
< #171 ';'
< #176 OBJECTID i2c
< #176 '('
< #176 OBJECTID i
< #176 ':'
< #176 TYPEID Int
< #176 ')'
< #176 ':'
< #176 TYPEID String
< #176 '{'
< #177 IF
< #177 OBJECTID i
< #177 '='
< #177 INT_CONST 0
< #177 THEN
< #177 STR_CONST "0"
< #177 ELSE
< #178 IF
< #178 OBJECTID i
< #178 '='
< #178 INT_CONST 1
< #178 THEN
< #178 STR_CONST "1"
< #178 ELSE
< #179 IF
< #179 OBJECTID i
< #179 '='
< #179 INT_CONST 2
< #179 THEN
< #179 STR_CONST "2"
< #179 ELSE
< #180 IF
< #180 OBJECTID i
< #180 '='
< #180 INT_CONST 3
< #180 THEN
< #180 STR_CONST "3"
< #180 ELSE
< #181 IF
< #181 OBJECTID i
< #181 '='
< #181 INT_CONST 4
< #181 THEN
< #181 STR_CONST "4"
< #181 ELSE
< #182 IF
< #182 OBJECTID i
< #182 '='
< #182 INT_CONST 5
< #182 THEN
< #182 STR_CONST "5"
< #182 ELSE
< #183 IF
< #183 OBJECTID i
< #183 '='
< #183 INT_CONST 6
< #183 THEN
< #183 STR_CONST "6"
< #183 ELSE
< #184 IF
< #184 OBJECTID i
< #184 '='
< #184 INT_CONST 7
< #184 THEN
< #184 STR_CONST "7"
< #184 ELSE
< #185 IF
< #185 OBJECTID i
< #185 '='
< #185 INT_CONST 8
< #185 THEN
< #185 STR_CONST "8"
< #185 ELSE
< #186 IF
< #186 OBJECTID i
< #186 '='
< #186 INT_CONST 9
< #186 THEN
< #186 STR_CONST "9"
< #186 ELSE
< #187 '{'
< #187 OBJECTID abort
< #187 '('
< #187 ')'
< #187 ';'
< #187 STR_CONST ""
< #187 ';'
< #187 '}'
< #188 FI
< #188 FI
< #188 FI
< #188 FI
< #188 FI
< #188 FI
< #188 FI
< #188 FI
< #188 FI
< #188 FI
< #189 '}'
< #189 ';'
< #199 OBJECTID a2i
< #199 '('
< #199 OBJECTID s
< #199 ':'
< #199 TYPEID String
< #199 ')'
< #199 ':'
< #199 TYPEID Int
< #199 '{'
< #200 IF
< #200 OBJECTID s
< #200 '.'
< #200 OBJECTID length
< #200 '('
< #200 ')'
< #200 '='
< #200 INT_CONST 0
< #200 THEN
< #200 INT_CONST 0
< #200 ELSE
< #201 IF
< #201 OBJECTID s
< #201 '.'
< #201 OBJECTID substr
< #201 '('
< #201 INT_CONST 0
< #201 ','
< #201 INT_CONST 1
< #201 ')'
< #201 '='
< #201 STR_CONST "-"
< #201 THEN
< #201 '~'
< #201 OBJECTID a2i_aux
< #201 '('
< #201 OBJECTID s
< #201 '.'
< #201 OBJECTID substr
< #201 '('
< #201 INT_CONST 1
< #201 ','
< #201 OBJECTID s
< #201 '.'
< #201 OBJECTID length
< #201 '('
< #201 ')'
< #201 '-'
< #201 INT_CONST 1
< #201 ')'
< #201 ')'
< #201 ELSE
< #202 IF
< #202 OBJECTID s
< #202 '.'
< #202 OBJECTID substr
< #202 '('
< #202 INT_CONST 0
< #202 ','
< #202 INT_CONST 1
< #202 ')'
< #202 '='
< #202 STR_CONST "+"
< #202 THEN
< #202 OBJECTID a2i_aux
< #202 '('
< #202 OBJECTID s
< #202 '.'
< #202 OBJECTID substr
< #202 '('
< #202 INT_CONST 1
< #202 ','
< #202 OBJECTID s
< #202 '.'
< #202 OBJECTID length
< #202 '('
< #202 ')'
< #202 '-'
< #202 INT_CONST 1
< #202 ')'
< #202 ')'
< #202 ELSE
< #203 OBJECTID a2i_aux
< #203 '('
< #203 OBJECTID s
< #203 ')'
< #204 FI
< #204 FI
< #204 FI
< #205 '}'
< #205 ';'
< #211 OBJECTID a2i_aux
< #211 '('
< #211 OBJECTID s
< #211 ':'
< #211 TYPEID String
< #211 ')'
< #211 ':'
< #211 TYPEID Int
< #211 '{'
< #212 '('
< #212 LET
< #212 OBJECTID int
< #212 ':'
< #212 TYPEID Int
< #212 ASSIGN
< #212 INT_CONST 0
< #212 IN
< #213 '{'
< #214 '('
< #214 LET
< #214 OBJECTID j
< #214 ':'
< #214 TYPEID Int
< #214 ASSIGN
< #214 OBJECTID s
< #214 '.'
< #214 OBJECTID length
< #214 '('
< #214 ')'
< #214 IN
< #215 '('
< #215 LET
< #215 OBJECTID i
< #215 ':'
< #215 TYPEID Int
< #215 ASSIGN
< #215 INT_CONST 0
< #215 IN
< #216 WHILE
< #216 OBJECTID i
< #216 '<'
< #216 OBJECTID j
< #216 LOOP
< #217 '{'
< #218 OBJECTID int
< #218 ASSIGN
< #218 OBJECTID int
< #218 '*'
< #218 INT_CONST 10
< #218 '+'
< #218 OBJECTID c2i
< #218 '('
< #218 OBJECTID s
< #218 '.'
< #218 OBJECTID substr
< #218 '('
< #218 OBJECTID i
< #218 ','
< #218 INT_CONST 1
< #218 ')'
< #218 ')'
< #218 ';'
< #219 OBJECTID i
< #219 ASSIGN
< #219 OBJECTID i
< #219 '+'
< #219 INT_CONST 1
< #219 ';'
< #220 '}'
< #221 POOL
< #222 ')'
< #223 ')'
< #223 ';'
< #224 OBJECTID int
< #224 ';'
< #225 '}'
< #226 ')'
< #227 '}'
< #227 ';'
< #232 OBJECTID i2a
< #232 '('
< #232 OBJECTID i
< #232 ':'
< #232 TYPEID Int
< #232 ')'
< #232 ':'
< #232 TYPEID String
< #232 '{'
< #233 IF
< #233 OBJECTID i
< #233 '='
< #233 INT_CONST 0
< #233 THEN
< #233 STR_CONST "0"
< #233 ELSE
< #234 IF
< #234 INT_CONST 0
< #234 '<'
< #234 OBJECTID i
< #234 THEN
< #234 OBJECTID i2a_aux
< #234 '('
< #234 OBJECTID i
< #234 ')'
< #234 ELSE
< #235 STR_CONST "-"
< #235 '.'
< #235 OBJECTID concat
< #235 '('
< #235 OBJECTID i2a_aux
< #235 '('
< #235 OBJECTID i
< #235 '*'
< #235 '~'
< #235 INT_CONST 1
< #235 ')'
< #235 ')'
< #236 FI
< #236 FI
< #237 '}'
< #237 ';'
< #241 OBJECTID i2a_aux
< #241 '('
< #241 OBJECTID i
< #241 ':'
< #241 TYPEID Int
< #241 ')'
< #241 ':'
< #241 TYPEID String
< #241 '{'
< #242 IF
< #242 OBJECTID i
< #242 '='
< #242 INT_CONST 0
< #242 THEN
< #242 STR_CONST ""
< #242 ELSE
< #243 '('
< #243 LET
< #243 OBJECTID next
< #243 ':'
< #243 TYPEID Int
< #243 ASSIGN
< #243 OBJECTID i
< #243 '/'
< #243 INT_CONST 10
< #243 IN
< #244 OBJECTID i2a_aux
< #244 '('
< #244 OBJECTID next
< #244 ')'
< #244 '.'
< #244 OBJECTID concat
< #244 '('
< #244 OBJECTID i2c
< #244 '('
< #244 OBJECTID i
< #244 '-'
< #244 OBJECTID next
< #244 '*'
< #244 INT_CONST 10
< #244 ')'
< #244 ')'
< #245 ')'
< #246 FI
< #247 '}'
< #247 ';'
< #249 '}'
< #249 ';'
< #251 CLASS
< #251 TYPEID Main
< #251 INHERITS
< #251 TYPEID IO
< #251 '{'
< #253 OBJECTID char
< #253 ':'
< #253 TYPEID String
< #253 ';'
< #254 OBJECTID avar
< #254 ':'
< #254 TYPEID A
< #254 ';'
< #255 OBJECTID a_var
< #255 ':'
< #255 TYPEID A
< #255 ';'
< #256 OBJECTID flag
< #256 ':'
< #256 TYPEID Bool
< #256 ASSIGN
< #256 BOOL_CONST true
< #256 ';'
< #259 OBJECTID menu
< #259 '('
< #259 ')'
< #259 ':'
< #259 TYPEID String
< #259 '{'
< #260 '{'
< #261 OBJECTID out_string
< #261 '('
< #261 STR_CONST "\n\tTo add a number to "
< #261 ')'
< #261 ';'
< #262 OBJECTID print
< #262 '('
< #262 OBJECTID avar
< #262 ')'
< #262 ';'
< #263 OBJECTID out_string
< #263 '('
< #263 STR_CONST "...enter a:\n"
< #263 ')'
< #263 ';'
< #264 OBJECTID out_string
< #264 '('
< #264 STR_CONST "\tTo negate "
< #264 ')'
< #264 ';'
< #265 OBJECTID print
< #265 '('
< #265 OBJECTID avar
< #265 ')'
< #265 ';'
< #266 OBJECTID out_string
< #266 '('
< #266 STR_CONST "...enter b:\n"
< #266 ')'
< #266 ';'
< #267 OBJECTID out_string
< #267 '('
< #267 STR_CONST "\tTo find the difference between "
< #267 ')'
< #267 ';'
< #268 OBJECTID print
< #268 '('
< #268 OBJECTID avar
< #268 ')'
< #268 ';'
< #269 OBJECTID out_string
< #269 '('
< #269 STR_CONST "and another number...enter c:\n"
< #269 ')'
< #269 ';'
< #270 OBJECTID out_string
< #270 '('
< #270 STR_CONST "\tTo find the factorial of "
< #270 ')'
< #270 ';'
< #271 OBJECTID print
< #271 '('
< #271 OBJECTID avar
< #271 ')'
< #271 ';'
< #272 OBJECTID out_string
< #272 '('
< #272 STR_CONST "...enter d:\n"
< #272 ')'
< #272 ';'
< #273 OBJECTID out_string
< #273 '('
< #273 STR_CONST "\tTo square "
< #273 ')'
< #273 ';'
< #274 OBJECTID print
< #274 '('
< #274 OBJECTID avar
< #274 ')'
< #274 ';'
< #275 OBJECTID out_string
< #275 '('
< #275 STR_CONST "...enter e:\n"
< #275 ')'
< #275 ';'
< #276 OBJECTID out_string
< #276 '('
< #276 STR_CONST "\tTo cube "
< #276 ')'
< #276 ';'
< #277 OBJECTID print
< #277 '('
< #277 OBJECTID avar
< #277 ')'
< #277 ';'
< #278 OBJECTID out_string
< #278 '('
< #278 STR_CONST "...enter f:\n"
< #278 ')'
< #278 ';'
< #279 OBJECTID out_string
< #279 '('
< #279 STR_CONST "\tTo find out if "
< #279 ')'
< #279 ';'
< #280 OBJECTID print
< #280 '('
< #280 OBJECTID avar
< #280 ')'
< #280 ';'
< #281 OBJECTID out_string
< #281 '('
< #281 STR_CONST "is a multiple of 3...enter g:\n"
< #281 ')'
< #281 ';'
< #282 OBJECTID out_string
< #282 '('
< #282 STR_CONST "\tTo divide "
< #282 ')'
< #282 ';'
< #283 OBJECTID print
< #283 '('
< #283 OBJECTID avar
< #283 ')'
< #283 ';'
< #284 OBJECTID out_string
< #284 '('
< #284 STR_CONST "by 8...enter h:\n"
< #284 ')'
< #284 ';'
< #285 OBJECTID out_string
< #285 '('
< #285 STR_CONST "\tTo get a new number...enter j:\n"
< #285 ')'
< #285 ';'
< #286 OBJECTID out_string
< #286 '('
< #286 STR_CONST "\tTo quit...enter q:\n\n"
< #286 ')'
< #286 ';'
< #287 OBJECTID in_string
< #287 '('
< #287 ')'
< #287 ';'
< #288 '}'
< #289 '}'
< #289 ';'
< #291 OBJECTID prompt
< #291 '('
< #291 ')'
< #291 ':'
< #291 TYPEID String
< #291 '{'
< #292 '{'
< #293 OBJECTID out_string
< #293 '('
< #293 STR_CONST "\n"
< #293 ')'
< #293 ';'
< #294 OBJECTID out_string
< #294 '('
< #294 STR_CONST "Please enter a number...  "
< #294 ')'
< #294 ';'
< #295 OBJECTID in_string
< #295 '('
< #295 ')'
< #295 ';'
< #296 '}'
< #297 '}'
< #297 ';'
< #299 OBJECTID get_int
< #299 '('
< #299 ')'
< #299 ':'
< #299 TYPEID Int
< #299 '{'
< #300 '{'
< #301 '('
< #301 LET
< #301 OBJECTID z
< #301 ':'
< #301 TYPEID A2I
< #301 ASSIGN
< #301 NEW
< #301 TYPEID A2I
< #301 IN
< #302 '('
< #302 LET
< #302 OBJECTID s
< #302 ':'
< #302 TYPEID String
< #302 ASSIGN
< #302 OBJECTID prompt
< #302 '('
< #302 ')'
< #302 IN
< #303 OBJECTID z
< #303 '.'
< #303 OBJECTID a2i
< #303 '('
< #303 OBJECTID s
< #303 ')'
< #304 ')'
< #305 ')'
< #305 ';'
< #306 '}'
< #307 '}'
< #307 ';'
< #309 OBJECTID is_even
< #309 '('
< #309 OBJECTID num
< #309 ':'
< #309 TYPEID Int
< #309 ')'
< #309 ':'
< #309 TYPEID Bool
< #309 '{'
< #310 '('
< #310 LET
< #310 OBJECTID x
< #310 ':'
< #310 TYPEID Int
< #310 ASSIGN
< #310 OBJECTID num
< #310 IN
< #311 IF
< #311 OBJECTID x
< #311 '<'
< #311 INT_CONST 0
< #311 THEN
< #311 OBJECTID is_even
< #311 '('
< #311 '~'
< #311 OBJECTID x
< #311 ')'
< #311 ELSE
< #312 IF
< #312 INT_CONST 0
< #312 '='
< #312 OBJECTID x
< #312 THEN
< #312 BOOL_CONST true
< #312 ELSE
< #313 IF
< #313 INT_CONST 1
< #313 '='
< #313 OBJECTID x
< #313 THEN
< #313 BOOL_CONST false
< #313 ELSE
< #314 OBJECTID is_even
< #314 '('
< #314 OBJECTID x
< #314 '-'
< #314 INT_CONST 2
< #314 ')'
< #315 FI
< #315 FI
< #315 FI
< #316 ')'
< #317 '}'
< #317 ';'
< #319 OBJECTID class_type
< #319 '('
< #319 OBJECTID var
< #319 ':'
< #319 TYPEID A
< #319 ')'
< #319 ':'
< #319 TYPEID SELF_TYPE
< #319 '{'
< #320 CASE
< #320 OBJECTID var
< #320 OF
< #321 OBJECTID a
< #321 ':'
< #321 TYPEID A
< #321 DARROW
< #321 OBJECTID out_string
< #321 '('
< #321 STR_CONST "Class type is now A\n"
< #321 ')'
< #321 ';'
< #322 OBJECTID b
< #322 ':'
< #322 TYPEID B
< #322 DARROW
< #322 OBJECTID out_string
< #322 '('
< #322 STR_CONST "Class type is now B\n"
< #322 ')'
< #322 ';'
< #323 OBJECTID c
< #323 ':'
< #323 TYPEID C
< #323 DARROW
< #323 OBJECTID out_string
< #323 '('
< #323 STR_CONST "Class type is now C\n"
< #323 ')'
< #323 ';'
< #324 OBJECTID d
< #324 ':'
< #324 TYPEID D
< #324 DARROW
< #324 OBJECTID out_string
< #324 '('
< #324 STR_CONST "Class type is now D\n"
< #324 ')'
< #324 ';'
< #325 OBJECTID e
< #325 ':'
< #325 TYPEID E
< #325 DARROW
< #325 OBJECTID out_string
< #325 '('
< #325 STR_CONST "Class type is now E\n"
< #325 ')'
< #325 ';'
< #326 OBJECTID o
< #326 ':'
< #326 TYPEID Object
< #326 DARROW
< #326 OBJECTID out_string
< #326 '('
< #326 STR_CONST "Oooops\n"
< #326 ')'
< #326 ';'
< #327 ESAC
< #328 '}'
< #328 ';'
< #330 OBJECTID print
< #330 '('
< #330 OBJECTID var
< #330 ':'
< #330 TYPEID A
< #330 ')'
< #330 ':'
< #330 TYPEID SELF_TYPE
< #330 '{'
< #331 '('
< #331 LET
< #331 OBJECTID z
< #331 ':'
< #331 TYPEID A2I
< #331 ASSIGN
< #331 NEW
< #331 TYPEID A2I
< #331 IN
< #332 '{'
< #333 OBJECTID out_string
< #333 '('
< #333 OBJECTID z
< #333 '.'
< #333 OBJECTID i2a
< #333 '('
< #333 OBJECTID var
< #333 '.'
< #333 OBJECTID value
< #333 '('
< #333 ')'
< #333 ')'
< #333 ')'
< #333 ';'
< #334 OBJECTID out_string
< #334 '('
< #334 STR_CONST " "
< #334 ')'
< #334 ';'
< #335 '}'
< #336 ')'
< #337 '}'
< #337 ';'
< #339 OBJECTID main
< #339 '('
< #339 ')'
< #339 ':'
< #339 TYPEID Object
< #339 '{'
< #340 '{'
< #341 OBJECTID avar
< #341 ASSIGN
< #341 '('
< #341 NEW
< #341 TYPEID A
< #341 ')'
< #341 ';'
< #342 WHILE
< #342 OBJECTID flag
< #342 LOOP
< #343 '{'
< #345 OBJECTID out_string
< #345 '('
< #345 STR_CONST "number "
< #345 ')'
< #345 ';'
< #346 OBJECTID print
< #346 '('
< #346 OBJECTID avar
< #346 ')'
< #346 ';'
< #347 IF
< #347 OBJECTID is_even
< #347 '('
< #347 OBJECTID avar
< #347 '.'
< #347 OBJECTID value
< #347 '('
< #347 ')'
< #347 ')'
< #347 THEN
< #348 OBJECTID out_string
< #348 '('
< #348 STR_CONST "is even!\n"
< #348 ')'
< #349 ELSE
< #350 OBJECTID out_string
< #350 '('
< #350 STR_CONST "is odd!\n"
< #350 ')'
< #351 FI
< #351 ';'
< #353 OBJECTID class_type
< #353 '('
< #353 OBJECTID avar
< #353 ')'
< #353 ';'
< #354 OBJECTID char
< #354 ASSIGN
< #354 OBJECTID menu
< #354 '('
< #354 ')'
< #354 ';'
< #355 IF
< #355 OBJECTID char
< #355 '='
< #355 STR_CONST "a"
< #355 THEN
< #356 '{'
< #357 OBJECTID a_var
< #357 ASSIGN
< #357 '('
< #357 NEW
< #357 TYPEID A
< #357 ')'
< #357 '.'
< #357 OBJECTID set_var
< #357 '('
< #357 OBJECTID get_int
< #357 '('
< #357 ')'
< #357 ')'
< #357 ';'
< #358 OBJECTID avar
< #358 ASSIGN
< #358 '('
< #358 NEW
< #358 TYPEID B
< #358 ')'
< #358 '.'
< #358 OBJECTID method2
< #358 '('
< #358 OBJECTID avar
< #358 '.'
< #358 OBJECTID value
< #358 '('
< #358 ')'
< #358 ','
< #358 OBJECTID a_var
< #358 '.'
< #358 OBJECTID value
< #358 '('
< #358 ')'
< #358 ')'
< #358 ';'
< #359 '}'
< #359 ELSE
< #360 IF
< #360 OBJECTID char
< #360 '='
< #360 STR_CONST "b"
< #360 THEN
< #361 CASE
< #361 OBJECTID avar
< #361 OF
< #362 OBJECTID c
< #362 ':'
< #362 TYPEID C
< #362 DARROW
< #362 OBJECTID avar
< #362 ASSIGN
< #362 OBJECTID c
< #362 '.'
< #362 OBJECTID method6
< #362 '('
< #362 OBJECTID c
< #362 '.'
< #362 OBJECTID value
< #362 '('
< #362 ')'
< #362 ')'
< #362 ';'
< #363 OBJECTID a
< #363 ':'
< #363 TYPEID A
< #363 DARROW
< #363 OBJECTID avar
< #363 ASSIGN
< #363 OBJECTID a
< #363 '.'
< #363 OBJECTID method3
< #363 '('
< #363 OBJECTID a
< #363 '.'
< #363 OBJECTID value
< #363 '('
< #363 ')'
< #363 ')'
< #363 ';'
< #364 OBJECTID o
< #364 ':'
< #364 TYPEID Object
< #364 DARROW
< #364 '{'
< #365 OBJECTID out_string
< #365 '('
< #365 STR_CONST "Oooops\n"
< #365 ')'
< #365 ';'
< #366 OBJECTID abort
< #366 '('
< #366 ')'
< #366 ';'
< #366 INT_CONST 0
< #366 ';'
< #367 '}'
< #367 ';'
< #368 ESAC
< #368 ELSE
< #369 IF
< #369 OBJECTID char
< #369 '='
< #369 STR_CONST "c"
< #369 THEN
< #370 '{'
< #371 OBJECTID a_var
< #371 ASSIGN
< #371 '('
< #371 NEW
< #371 TYPEID A
< #371 ')'
< #371 '.'
< #371 OBJECTID set_var
< #371 '('
< #371 OBJECTID get_int
< #371 '('
< #371 ')'
< #371 ')'
< #371 ';'
< #372 OBJECTID avar
< #372 ASSIGN
< #372 '('
< #372 NEW
< #372 TYPEID D
< #372 ')'
< #372 '.'
< #372 OBJECTID method4
< #372 '('
< #372 OBJECTID avar
< #372 '.'
< #372 OBJECTID value
< #372 '('
< #372 ')'
< #372 ','
< #372 OBJECTID a_var
< #372 '.'
< #372 OBJECTID value
< #372 '('
< #372 ')'
< #372 ')'
< #372 ';'
< #373 '}'
< #373 ELSE
< #374 IF
< #374 OBJECTID char
< #374 '='
< #374 STR_CONST "d"
< #374 THEN
< #374 OBJECTID avar
< #374 ASSIGN
< #374 '('
< #374 NEW
< #374 TYPEID C
< #374 ')'
< #374 '@'
< #374 TYPEID A
< #374 '.'
< #374 OBJECTID method5
< #374 '('
< #374 OBJECTID avar
< #374 '.'
< #374 OBJECTID value
< #374 '('
< #374 ')'
< #374 ')'
< #374 ELSE
< #376 IF
< #376 OBJECTID char
< #376 '='
< #376 STR_CONST "e"
< #376 THEN
< #376 OBJECTID avar
< #376 ASSIGN
< #376 '('
< #376 NEW
< #376 TYPEID C
< #376 ')'
< #376 '@'
< #376 TYPEID B
< #376 '.'
< #376 OBJECTID method5
< #376 '('
< #376 OBJECTID avar
< #376 '.'
< #376 OBJECTID value
< #376 '('
< #376 ')'
< #376 ')'
< #376 ELSE
< #378 IF
< #378 OBJECTID char
< #378 '='
< #378 STR_CONST "f"
< #378 THEN
< #378 OBJECTID avar
< #378 ASSIGN
< #378 '('
< #378 NEW
< #378 TYPEID C
< #378 ')'
< #378 '@'
< #378 TYPEID C
< #378 '.'
< #378 OBJECTID method5
< #378 '('
< #378 OBJECTID avar
< #378 '.'
< #378 OBJECTID value
< #378 '('
< #378 ')'
< #378 ')'
< #378 ELSE
< #380 IF
< #380 OBJECTID char
< #380 '='
< #380 STR_CONST "g"
< #380 THEN
< #381 IF
< #381 '('
< #381 '('
< #381 NEW
< #381 TYPEID D
< #381 ')'
< #381 '.'
< #381 OBJECTID method7
< #381 '('
< #381 OBJECTID avar
< #381 '.'
< #381 OBJECTID value
< #381 '('
< #381 ')'
< #381 ')'
< #381 ')'
< #382 THEN
< #383 '{'
< #384 OBJECTID out_string
< #384 '('
< #384 STR_CONST "number "
< #384 ')'
< #384 ';'
< #385 OBJECTID print
< #385 '('
< #385 OBJECTID avar
< #385 ')'
< #385 ';'
< #386 OBJECTID out_string
< #386 '('
< #386 STR_CONST "is divisible by 3.\n"
< #386 ')'
< #386 ';'
< #387 '}'
< #388 ELSE
< #389 '{'
< #390 OBJECTID out_string
< #390 '('
< #390 STR_CONST "number "
< #390 ')'
< #390 ';'
< #391 OBJECTID print
< #391 '('
< #391 OBJECTID avar
< #391 ')'
< #391 ';'
< #392 OBJECTID out_string
< #392 '('
< #392 STR_CONST "is not divisible by 3.\n"
< #392 ')'
< #392 ';'
< #393 '}'
< #394 FI
< #394 ELSE
< #395 IF
< #395 OBJECTID char
< #395 '='
< #395 STR_CONST "h"
< #395 THEN
< #396 '('
< #396 LET
< #396 OBJECTID x
< #396 ':'
< #396 TYPEID A
< #396 IN
< #397 '{'
< #398 OBJECTID x
< #398 ASSIGN
< #398 '('
< #398 NEW
< #398 TYPEID E
< #398 ')'
< #398 '.'
< #398 OBJECTID method6
< #398 '('
< #398 OBJECTID avar
< #398 '.'
< #398 OBJECTID value
< #398 '('
< #398 ')'
< #398 ')'
< #398 ';'
< #399 '('
< #399 LET
< #399 OBJECTID r
< #399 ':'
< #399 TYPEID Int
< #399 ASSIGN
< #399 '('
< #399 OBJECTID avar
< #399 '.'
< #399 OBJECTID value
< #399 '('
< #399 ')'
< #399 '-'
< #399 '('
< #399 OBJECTID x
< #399 '.'
< #399 OBJECTID value
< #399 '('
< #399 ')'
< #399 '*'
< #399 INT_CONST 8
< #399 ')'
< #399 ')'
< #399 IN
< #400 '{'
< #401 OBJECTID out_string
< #401 '('
< #401 STR_CONST "number "
< #401 ')'
< #401 ';'
< #402 OBJECTID print
< #402 '('
< #402 OBJECTID avar
< #402 ')'
< #402 ';'
< #403 OBJECTID out_string
< #403 '('
< #403 STR_CONST "is equal to "
< #403 ')'
< #403 ';'
< #404 OBJECTID print
< #404 '('
< #404 OBJECTID x
< #404 ')'
< #404 ';'
< #405 OBJECTID out_string
< #405 '('
< #405 STR_CONST "times 8 with a remainder of "
< #405 ')'
< #405 ';'
< #406 '('
< #406 LET
< #406 OBJECTID a
< #406 ':'
< #406 TYPEID A2I
< #406 ASSIGN
< #406 NEW
< #406 TYPEID A2I
< #406 IN
< #407 '{'
< #408 OBJECTID out_string
< #408 '('
< #408 OBJECTID a
< #408 '.'
< #408 OBJECTID i2a
< #408 '('
< #408 OBJECTID r
< #408 ')'
< #408 ')'
< #408 ';'
< #409 OBJECTID out_string
< #409 '('
< #409 STR_CONST "\n"
< #409 ')'
< #409 ';'
< #410 '}'
< #411 ')'
< #411 ';'
< #412 '}'
< #413 ')'
< #413 ';'
< #414 OBJECTID avar
< #414 ASSIGN
< #414 OBJECTID x
< #414 ';'
< #415 '}'
< #416 ')'
< #417 ELSE
< #418 IF
< #418 OBJECTID char
< #418 '='
< #418 STR_CONST "j"
< #418 THEN
< #418 OBJECTID avar
< #418 ASSIGN
< #418 '('
< #418 NEW
< #418 TYPEID A
< #418 ')'
< #419 ELSE
< #420 IF
< #420 OBJECTID char
< #420 '='
< #420 STR_CONST "q"
< #420 THEN
< #420 OBJECTID flag
< #420 ASSIGN
< #420 BOOL_CONST false
< #421 ELSE
< #422 OBJECTID avar
< #422 ASSIGN
< #422 '('
< #422 NEW
< #422 TYPEID A
< #422 ')'
< #422 '.'
< #422 OBJECTID method1
< #422 '('
< #422 OBJECTID avar
< #422 '.'
< #422 OBJECTID value
< #422 '('
< #422 ')'
< #422 ')'
< #423 FI
< #423 FI
< #423 FI
< #423 FI
< #423 FI
< #423 FI
< #423 FI
< #423 FI
< #423 FI
< #423 FI
< #423 ';'
< #424 '}'
< #425 POOL
< #425 ';'
< #426 '}'
< #427 '}'
< #427 ';'
< #429 '}'
< #429 ';'
---
> (*
>  *  A contribution from Anne Sheets (sheets@cory)
>  *
>  *  Tests the arithmetic operations and various other things
>  *)
> 
> class A {
> 
>    var : Int <- 0;
> 
>    value() : Int { var };
> 
>    set_var(num : Int) : SELF_TYPE {
>       {
>          var <- num;
>          self;
>       }
>    };
> 
>    method1(num : Int) : SELF_TYPE {  -- same
>       self
>    };
> 
>    method2(num1 : Int, num2 : Int) : B {  -- plus
>       (let x : Int in
> 	 {
>             x <- num1 + num2;
> 	    (new B).set_var(x);
> 	 }
>       )
>    };
> 
>    method3(num : Int) : C {  -- negate
>       (let x : Int in
> 	 {
>             x <- ~num;
> 	    (new C).set_var(x);
> 	 }
>       )
>    };
> 
>    method4(num1 : Int, num2 : Int) : D {  -- diff
>             if num2 < num1 then
>                (let x : Int in
> 		  {
>                      x <- num1 - num2;
> 	             (new D).set_var(x);
> 	          }
>                )
>             else
>                (let x : Int in
> 		  {
> 	             x <- num2 - num1;
> 	             (new D).set_var(x);
> 		  }
>                )
>             fi
>    };
> 
>    method5(num : Int) : E {  -- factorial
>       (let x : Int <- 1 in
> 	 {
> 	    (let y : Int <- 1 in
> 	       while y <= num loop
> 	          {
>                      x <- x * y;
> 	             y <- y + 1;
> 	          }
> 	       pool
> 	    );
> 	    (new E).set_var(x);
> 	 }
>       )
>    };
> 
> };
> 
> class B inherits A {  -- B is a number squared
> 
>    method5(num : Int) : E { -- square
>       (let x : Int in
> 	 {
>             x <- num * num;
> 	    (new E).set_var(x);
> 	 }
>       )
>    };
> 
> };
> 
> class C inherits B {
> 
>    method6(num : Int) : A { -- negate
>       (let x : Int in
>          {
>             x <- ~num;
> 	    (new A).set_var(x);
>          }
>       )
>    };
> 
>    method5(num : Int) : E {  -- cube
>       (let x : Int in
> 	 {
>             x <- num * num * num;
> 	    (new E).set_var(x);
> 	 }
>       )
>    };
> 
> };
> 
> class D inherits B {  
> 		
>    method7(num : Int) : Bool {  -- divisible by 3
>       (let x : Int <- num in
>             if x < 0 then method7(~x) else
>             if 0 = x then true else
>             if 1 = x then false else
> 	    if 2 = x then false else
> 	       method7(x - 3)
> 	    fi fi fi fi
>       )
>    };
> 
> };
> 
> class E inherits D {
> 
>    method6(num : Int) : A {  -- division
>       (let x : Int in
>          {
>             x <- num / 8;
> 	    (new A).set_var(x);
>          }
>       )
>    };
> 
> };
> 
> (* The following code is from atoi.cl in ~cs164/examples *)
> 
> (*
>    The class A2I provides integer-to-string and string-to-integer
> conversion routines.  To use these routines, either inherit them
> in the class where needed, have a dummy variable bound to
> something of type A2I, or simpl write (new A2I).method(argument).
> *)
> 
> 
> (*
>    c2i   Converts a 1-character string to an integer.  Aborts
>          if the string is not "0" through "9"
> *)
> class A2I {
> 
>      c2i(char : String) : Int {
> 	if char = "0" then 0 else
> 	if char = "1" then 1 else
> 	if char = "2" then 2 else
>         if char = "3" then 3 else
>         if char = "4" then 4 else
>         if char = "5" then 5 else
>         if char = "6" then 6 else
>         if char = "7" then 7 else
>         if char = "8" then 8 else
>         if char = "9" then 9 else
>         { abort(); 0; }  (* the 0 is needed to satisfy the
> 				  typchecker *)
>         fi fi fi fi fi fi fi fi fi fi
>      };
> 
> (*
>    i2c is the inverse of c2i.
> *)
>      i2c(i : Int) : String {
> 	if i = 0 then "0" else
> 	if i = 1 then "1" else
> 	if i = 2 then "2" else
> 	if i = 3 then "3" else
> 	if i = 4 then "4" else
> 	if i = 5 then "5" else
> 	if i = 6 then "6" else
> 	if i = 7 then "7" else
> 	if i = 8 then "8" else
> 	if i = 9 then "9" else
> 	{ abort(); ""; }  -- the "" is needed to satisfy the typchecker
>         fi fi fi fi fi fi fi fi fi fi
>      };
> 
> (*
>    a2i converts an ASCII string into an integer.  The empty string
> is converted to 0.  Signed and unsigned strings are handled.  The
> method aborts if the string does not represent an integer.  Very
> long strings of digits produce strange answers because of arithmetic 
> overflow.
> 
> *)
>      a2i(s : String) : Int {
>         if s.length() = 0 then 0 else
> 	if s.substr(0,1) = "-" then ~a2i_aux(s.substr(1,s.length()-1)) else
>         if s.substr(0,1) = "+" then a2i_aux(s.substr(1,s.length()-1)) else
>            a2i_aux(s)
>         fi fi fi
>      };
> 
> (* a2i_aux converts the usigned portion of the string.  As a
>    programming example, this method is written iteratively.  *)
> 
> 
>      a2i_aux(s : String) : Int {
> 	(let int : Int <- 0 in	
>            {	
>                (let j : Int <- s.length() in
> 	          (let i : Int <- 0 in
> 		    while i < j loop
> 			{
> 			    int <- int * 10 + c2i(s.substr(i,1));
> 			    i <- i + 1;
> 			}
> 		    pool
> 		  )
> 	       );
>               int;
> 	    }
>         )
>      };
> 
> (* i2a converts an integer to a string.  Positive and negative 
>    numbers are handled correctly.  *)
> 
>     i2a(i : Int) : String {
> 	if i = 0 then "0" else 
>         if 0 < i then i2a_aux(i) else
>           "-".concat(i2a_aux(i * ~1)) 
>         fi fi
>     };
> 	
> (* i2a_aux is an example using recursion.  *)		
> 
>     i2a_aux(i : Int) : String {
>         if i = 0 then "" else 
> 	    (let next : Int <- i / 10 in
> 		i2a_aux(next).concat(i2c(i - next * 10))
> 	    )
>         fi
>     };
> 
> };
> 
> class Main inherits IO {
>    
>    char : String;
>    avar : A; 
>    a_var : A;
>    flag : Bool <- true;
> 
> 
>    menu() : String {
>       {
>          out_string("\n\tTo add a number to ");
>          print(avar);
>          out_string("...enter a:\n");
>          out_string("\tTo negate ");
>          print(avar);
>          out_string("...enter b:\n");
>          out_string("\tTo find the difference between ");
>          print(avar);
>          out_string("and another number...enter c:\n");
>          out_string("\tTo find the factorial of ");
>          print(avar);
>          out_string("...enter d:\n");
>          out_string("\tTo square ");
>          print(avar);
>          out_string("...enter e:\n");
>          out_string("\tTo cube ");
>          print(avar);
>          out_string("...enter f:\n");
>          out_string("\tTo find out if ");
>          print(avar);
>          out_string("is a multiple of 3...enter g:\n");
>          out_string("\tTo divide ");
>          print(avar);
>          out_string("by 8...enter h:\n");
> 	 out_string("\tTo get a new number...enter j:\n");
> 	 out_string("\tTo quit...enter q:\n\n");
>          in_string();
>       }
>    };
> 
>    prompt() : String {
>       {
>          out_string("\n");
>          out_string("Please enter a number...  ");
>          in_string();
>       }
>    };
> 
>    get_int() : Int {
>       {
> 	 (let z : A2I <- new A2I in
> 	    (let s : String <- prompt() in
> 	       z.a2i(s)
> 	    )
>          );
>       }
>    };
> 
>    is_even(num : Int) : Bool {
>       (let x : Int <- num in
>             if x < 0 then is_even(~x) else
>             if 0 = x then true else
> 	    if 1 = x then false else
> 	          is_even(x - 2)
> 	    fi fi fi
>       )
>    };
> 
>    class_type(var : A) : SELF_TYPE {
>       case var of
> 	 a : A #1 DARROW
>  out_string("Class type is now A\n");
> 	 b : B #1 DARROW
>  out_string("Class type is now B\n");
> 	 c : C #1 DARROW
>  out_string("Class type is now C\n");
> 	 d : D #1 DARROW
>  out_string("Class type is now D\n");
> 	 e : E #1 DARROW
>  out_string("Class type is now E\n");
> 	 o : Object #1 DARROW
>  out_string("Oooops\n");
>       esac
>    };
>  
>    print(var : A) : SELF_TYPE {
>      (let z : A2I <- new A2I in
> 	{
> 	   out_string(z.i2a(var.value()));
> 	   out_string(" ");
> 	}
>      )
>    };
> 
>    main() : Object {
>       {
>          avar <- (new A);
>          while flag loop
>             {
> 	       -- avar <- (new A).set_var(get_int());
> 	       out_string("number ");
> 	       print(avar);
> 	       if is_even(avar.value()) then
> 	          out_string("is even!\n")
> 	       else
> 	          out_string("is odd!\n")
> 	       fi;
> 	       -- print(avar); -- prints out answer
> 	       class_type(avar);
> 	       char <- menu();
>                   if char = "a" then -- add
>                      {
>                         a_var <- (new A).set_var(get_int());
> 	                avar <- (new B).method2(avar.value(), a_var.value());
> 	             } else
>                   if char = "b" then -- negate
>                      case avar of
> 	                   c : C #1 DARROW
>  avar <- c.method6(c.value());
> 	                   a : A #1 DARROW
>  avar <- a.method3(a.value());
> 	                   o : Object #1 DARROW
>  {
> 		                  out_string("Oooops\n");
> 		                  abort(); 0;
> 		               };
>                      esac else
>                   if char = "c" then -- diff
>                      {
>                         a_var <- (new A).set_var(get_int());
> 	                avar <- (new D).method4(avar.value(), a_var.value());
> 	             } else
>                   if char = "d" then avar <- (new C)@A.method5(avar.value()) else
> 		          -- factorial
>                   if char = "e" then avar <- (new C)@B.method5(avar.value()) else
> 			  -- square
>                   if char = "f" then avar <- (new C)@C.method5(avar.value()) else
> 			  -- cube
>                   if char = "g" then -- multiple of 3?
> 		      if ((new D).method7(avar.value()))
> 		                       then -- avar <- (new A).method1(avar.value())
> 			 {
> 	                    out_string("number ");
> 	                    print(avar);
> 	                    out_string("is divisible by 3.\n");
> 			 }
> 			 else  -- avar <- (new A).set_var(0)
> 			 {
> 	                    out_string("number ");
> 	                    print(avar);
> 	                    out_string("is not divisible by 3.\n");
> 			 }
> 		      fi else
>                   if char = "h" then 
> 		      (let x : A in
> 			 {
> 		            x <- (new E).method6(avar.value());
> 			    (let r : Int <- (avar.value() - (x.value() * 8)) in
> 			       {
> 			          out_string("number ");
> 			          print(avar);
> 			          out_string("is equal to ");
> 			          print(x);
> 			          out_string("times 8 with a remainder of ");
> 				  (let a : A2I <- new A2I in
> 				     {
> 			                out_string(a.i2a(r));
> 			                out_string("\n");
> 				     }
> 				  ); -- end let a:
> 			       }
>                             ); -- end let r:
> 			    avar <- x;
> 		         } 
> 		      )  -- end let x:
> 		      else
>                   if char = "j" then avar <- (new A)
> 		      else
>                   if char = "q" then flag <- false
> 		      else
>                       avar <- (new A).method1(avar.value()) -- divide/8
>                   fi fi fi fi fi fi fi fi fi fi;
>             }
>          pool;
>        }
>    };
> 
> };
> 
pass!
---------  Test  ../../examples/atoi.cl  ---------
2,461c2,109
< #13 CLASS
< #13 TYPEID A2I
< #13 '{'
< #15 OBJECTID c2i
< #15 '('
< #15 OBJECTID char
< #15 ':'
< #15 TYPEID String
< #15 ')'
< #15 ':'
< #15 TYPEID Int
< #15 '{'
< #16 IF
< #16 OBJECTID char
< #16 '='
< #16 STR_CONST "0"
< #16 THEN
< #16 INT_CONST 0
< #16 ELSE
< #17 IF
< #17 OBJECTID char
< #17 '='
< #17 STR_CONST "1"
< #17 THEN
< #17 INT_CONST 1
< #17 ELSE
< #18 IF
< #18 OBJECTID char
< #18 '='
< #18 STR_CONST "2"
< #18 THEN
< #18 INT_CONST 2
< #18 ELSE
< #19 IF
< #19 OBJECTID char
< #19 '='
< #19 STR_CONST "3"
< #19 THEN
< #19 INT_CONST 3
< #19 ELSE
< #20 IF
< #20 OBJECTID char
< #20 '='
< #20 STR_CONST "4"
< #20 THEN
< #20 INT_CONST 4
< #20 ELSE
< #21 IF
< #21 OBJECTID char
< #21 '='
< #21 STR_CONST "5"
< #21 THEN
< #21 INT_CONST 5
< #21 ELSE
< #22 IF
< #22 OBJECTID char
< #22 '='
< #22 STR_CONST "6"
< #22 THEN
< #22 INT_CONST 6
< #22 ELSE
< #23 IF
< #23 OBJECTID char
< #23 '='
< #23 STR_CONST "7"
< #23 THEN
< #23 INT_CONST 7
< #23 ELSE
< #24 IF
< #24 OBJECTID char
< #24 '='
< #24 STR_CONST "8"
< #24 THEN
< #24 INT_CONST 8
< #24 ELSE
< #25 IF
< #25 OBJECTID char
< #25 '='
< #25 STR_CONST "9"
< #25 THEN
< #25 INT_CONST 9
< #25 ELSE
< #26 '{'
< #26 OBJECTID abort
< #26 '('
< #26 ')'
< #26 ';'
< #26 INT_CONST 0
< #26 ';'
< #26 '}'
< #27 FI
< #27 FI
< #27 FI
< #27 FI
< #27 FI
< #27 FI
< #27 FI
< #27 FI
< #27 FI
< #27 FI
< #28 '}'
< #28 ';'
< #33 OBJECTID i2c
< #33 '('
< #33 OBJECTID i
< #33 ':'
< #33 TYPEID Int
< #33 ')'
< #33 ':'
< #33 TYPEID String
< #33 '{'
< #34 IF
< #34 OBJECTID i
< #34 '='
< #34 INT_CONST 0
< #34 THEN
< #34 STR_CONST "0"
< #34 ELSE
< #35 IF
< #35 OBJECTID i
< #35 '='
< #35 INT_CONST 1
< #35 THEN
< #35 STR_CONST "1"
< #35 ELSE
< #36 IF
< #36 OBJECTID i
< #36 '='
< #36 INT_CONST 2
< #36 THEN
< #36 STR_CONST "2"
< #36 ELSE
< #37 IF
< #37 OBJECTID i
< #37 '='
< #37 INT_CONST 3
< #37 THEN
< #37 STR_CONST "3"
< #37 ELSE
< #38 IF
< #38 OBJECTID i
< #38 '='
< #38 INT_CONST 4
< #38 THEN
< #38 STR_CONST "4"
< #38 ELSE
< #39 IF
< #39 OBJECTID i
< #39 '='
< #39 INT_CONST 5
< #39 THEN
< #39 STR_CONST "5"
< #39 ELSE
< #40 IF
< #40 OBJECTID i
< #40 '='
< #40 INT_CONST 6
< #40 THEN
< #40 STR_CONST "6"
< #40 ELSE
< #41 IF
< #41 OBJECTID i
< #41 '='
< #41 INT_CONST 7
< #41 THEN
< #41 STR_CONST "7"
< #41 ELSE
< #42 IF
< #42 OBJECTID i
< #42 '='
< #42 INT_CONST 8
< #42 THEN
< #42 STR_CONST "8"
< #42 ELSE
< #43 IF
< #43 OBJECTID i
< #43 '='
< #43 INT_CONST 9
< #43 THEN
< #43 STR_CONST "9"
< #43 ELSE
< #44 '{'
< #44 OBJECTID abort
< #44 '('
< #44 ')'
< #44 ';'
< #44 STR_CONST ""
< #44 ';'
< #44 '}'
< #45 FI
< #45 FI
< #45 FI
< #45 FI
< #45 FI
< #45 FI
< #45 FI
< #45 FI
< #45 FI
< #45 FI
< #46 '}'
< #46 ';'
< #56 OBJECTID a2i
< #56 '('
< #56 OBJECTID s
< #56 ':'
< #56 TYPEID String
< #56 ')'
< #56 ':'
< #56 TYPEID Int
< #56 '{'
< #57 IF
< #57 OBJECTID s
< #57 '.'
< #57 OBJECTID length
< #57 '('
< #57 ')'
< #57 '='
< #57 INT_CONST 0
< #57 THEN
< #57 INT_CONST 0
< #57 ELSE
< #58 IF
< #58 OBJECTID s
< #58 '.'
< #58 OBJECTID substr
< #58 '('
< #58 INT_CONST 0
< #58 ','
< #58 INT_CONST 1
< #58 ')'
< #58 '='
< #58 STR_CONST "-"
< #58 THEN
< #58 '~'
< #58 OBJECTID a2i_aux
< #58 '('
< #58 OBJECTID s
< #58 '.'
< #58 OBJECTID substr
< #58 '('
< #58 INT_CONST 1
< #58 ','
< #58 OBJECTID s
< #58 '.'
< #58 OBJECTID length
< #58 '('
< #58 ')'
< #58 '-'
< #58 INT_CONST 1
< #58 ')'
< #58 ')'
< #58 ELSE
< #59 IF
< #59 OBJECTID s
< #59 '.'
< #59 OBJECTID substr
< #59 '('
< #59 INT_CONST 0
< #59 ','
< #59 INT_CONST 1
< #59 ')'
< #59 '='
< #59 STR_CONST "+"
< #59 THEN
< #59 OBJECTID a2i_aux
< #59 '('
< #59 OBJECTID s
< #59 '.'
< #59 OBJECTID substr
< #59 '('
< #59 INT_CONST 1
< #59 ','
< #59 OBJECTID s
< #59 '.'
< #59 OBJECTID length
< #59 '('
< #59 ')'
< #59 '-'
< #59 INT_CONST 1
< #59 ')'
< #59 ')'
< #59 ELSE
< #60 OBJECTID a2i_aux
< #60 '('
< #60 OBJECTID s
< #60 ')'
< #61 FI
< #61 FI
< #61 FI
< #62 '}'
< #62 ';'
< #68 OBJECTID a2i_aux
< #68 '('
< #68 OBJECTID s
< #68 ':'
< #68 TYPEID String
< #68 ')'
< #68 ':'
< #68 TYPEID Int
< #68 '{'
< #69 '('
< #69 LET
< #69 OBJECTID int
< #69 ':'
< #69 TYPEID Int
< #69 ASSIGN
< #69 INT_CONST 0
< #69 IN
< #70 '{'
< #71 '('
< #71 LET
< #71 OBJECTID j
< #71 ':'
< #71 TYPEID Int
< #71 ASSIGN
< #71 OBJECTID s
< #71 '.'
< #71 OBJECTID length
< #71 '('
< #71 ')'
< #71 IN
< #72 '('
< #72 LET
< #72 OBJECTID i
< #72 ':'
< #72 TYPEID Int
< #72 ASSIGN
< #72 INT_CONST 0
< #72 IN
< #73 WHILE
< #73 OBJECTID i
< #73 '<'
< #73 OBJECTID j
< #73 LOOP
< #74 '{'
< #75 OBJECTID int
< #75 ASSIGN
< #75 OBJECTID int
< #75 '*'
< #75 INT_CONST 10
< #75 '+'
< #75 OBJECTID c2i
< #75 '('
< #75 OBJECTID s
< #75 '.'
< #75 OBJECTID substr
< #75 '('
< #75 OBJECTID i
< #75 ','
< #75 INT_CONST 1
< #75 ')'
< #75 ')'
< #75 ';'
< #76 OBJECTID i
< #76 ASSIGN
< #76 OBJECTID i
< #76 '+'
< #76 INT_CONST 1
< #76 ';'
< #77 '}'
< #78 POOL
< #79 ')'
< #80 ')'
< #80 ';'
< #81 OBJECTID int
< #81 ';'
< #82 '}'
< #83 ')'
< #84 '}'
< #84 ';'
< #90 OBJECTID i2a
< #90 '('
< #90 OBJECTID i
< #90 ':'
< #90 TYPEID Int
< #90 ')'
< #90 ':'
< #90 TYPEID String
< #90 '{'
< #91 IF
< #91 OBJECTID i
< #91 '='
< #91 INT_CONST 0
< #91 THEN
< #91 STR_CONST "0"
< #91 ELSE
< #92 IF
< #92 INT_CONST 0
< #92 '<'
< #92 OBJECTID i
< #92 THEN
< #92 OBJECTID i2a_aux
< #92 '('
< #92 OBJECTID i
< #92 ')'
< #92 ELSE
< #93 STR_CONST "-"
< #93 '.'
< #93 OBJECTID concat
< #93 '('
< #93 OBJECTID i2a_aux
< #93 '('
< #93 OBJECTID i
< #93 '*'
< #93 '~'
< #93 INT_CONST 1
< #93 ')'
< #93 ')'
< #94 FI
< #94 FI
< #95 '}'
< #95 ';'
< #100 OBJECTID i2a_aux
< #100 '('
< #100 OBJECTID i
< #100 ':'
< #100 TYPEID Int
< #100 ')'
< #100 ':'
< #100 TYPEID String
< #100 '{'
< #101 IF
< #101 OBJECTID i
< #101 '='
< #101 INT_CONST 0
< #101 THEN
< #101 STR_CONST ""
< #101 ELSE
< #102 '('
< #102 LET
< #102 OBJECTID next
< #102 ':'
< #102 TYPEID Int
< #102 ASSIGN
< #102 OBJECTID i
< #102 '/'
< #102 INT_CONST 10
< #102 IN
< #103 OBJECTID i2a_aux
< #103 '('
< #103 OBJECTID next
< #103 ')'
< #103 '.'
< #103 OBJECTID concat
< #103 '('
< #103 OBJECTID i2c
< #103 '('
< #103 OBJECTID i
< #103 '-'
< #103 OBJECTID next
< #103 '*'
< #103 INT_CONST 10
< #103 ')'
< #103 ')'
< #104 ')'
< #105 FI
< #106 '}'
< #106 ';'
< #108 '}'
< #108 ';'
---
> (*
>    The class A2I provides integer-to-string and string-to-integer
> conversion routines.  To use these routines, either inherit them
> in the class where needed, have a dummy variable bound to
> something of type A2I, or simpl write (new A2I).method(argument).
> *)
> 
> 
> (*
>    c2i   Converts a 1-character string to an integer.  Aborts
>          if the string is not "0" through "9"
> *)
> class A2I {
> 
>      c2i(char : String) : Int {
> 	if char = "0" then 0 else
> 	if char = "1" then 1 else
> 	if char = "2" then 2 else
>         if char = "3" then 3 else
>         if char = "4" then 4 else
>         if char = "5" then 5 else
>         if char = "6" then 6 else
>         if char = "7" then 7 else
>         if char = "8" then 8 else
>         if char = "9" then 9 else
>         { abort(); 0; }  -- the 0 is needed to satisfy the typchecker
>         fi fi fi fi fi fi fi fi fi fi
>      };
> 
> (*
>    i2c is the inverse of c2i.
> *)
>      i2c(i : Int) : String {
> 	if i = 0 then "0" else
> 	if i = 1 then "1" else
> 	if i = 2 then "2" else
> 	if i = 3 then "3" else
> 	if i = 4 then "4" else
> 	if i = 5 then "5" else
> 	if i = 6 then "6" else
> 	if i = 7 then "7" else
> 	if i = 8 then "8" else
> 	if i = 9 then "9" else
> 	{ abort(); ""; }  -- the "" is needed to satisfy the typchecker
>         fi fi fi fi fi fi fi fi fi fi
>      };
> 
> (*
>    a2i converts an ASCII string into an integer.  The empty string
> is converted to 0.  Signed and unsigned strings are handled.  The
> method aborts if the string does not represent an integer.  Very
> long strings of digits produce strange answers because of arithmetic 
> overflow.
> 
> *)
>      a2i(s : String) : Int {
>         if s.length() = 0 then 0 else
> 	if s.substr(0,1) = "-" then ~a2i_aux(s.substr(1,s.length()-1)) else
>         if s.substr(0,1) = "+" then a2i_aux(s.substr(1,s.length()-1)) else
>            a2i_aux(s)
>         fi fi fi
>      };
> 
> (*
>   a2i_aux converts the usigned portion of the string.  As a programming
> example, this method is written iteratively.
> *)
>      a2i_aux(s : String) : Int {
> 	(let int : Int <- 0 in	
>            {	
>                (let j : Int <- s.length() in
> 	          (let i : Int <- 0 in
> 		    while i < j loop
> 			{
> 			    int <- int * 10 + c2i(s.substr(i,1));
> 			    i <- i + 1;
> 			}
> 		    pool
> 		  )
> 	       );
>               int;
> 	    }
>         )
>      };
> 
> (*
>     i2a converts an integer to a string.  Positive and negative 
> numbers are handled correctly.  
> *)
>     i2a(i : Int) : String {
> 	if i = 0 then "0" else 
>         if 0 < i then i2a_aux(i) else
>           "-".concat(i2a_aux(i * ~1)) 
>         fi fi
>     };
> 	
> (*
>     i2a_aux is an example using recursion.
> *)		
>     i2a_aux(i : Int) : String {
>         if i = 0 then "" else 
> 	    (let next : Int <- i / 10 in
> 		i2a_aux(next).concat(i2c(i - next * 10))
> 	    )
>         fi
>     };
> 
> };
pass!
---------  Test  ../../examples/atoi_test.cl  ---------
2,130c2,47
< #9 CLASS
< #9 TYPEID Main
< #9 INHERITS
< #9 TYPEID IO
< #9 '{'
< #10 OBJECTID newline
< #10 '('
< #10 ')'
< #10 ':'
< #10 TYPEID Object
< #10 '{'
< #11 OBJECTID out_string
< #11 '('
< #11 STR_CONST "\n"
< #11 ')'
< #12 '}'
< #12 ';'
< #14 OBJECTID prompt
< #14 '('
< #14 ')'
< #14 ':'
< #14 TYPEID String
< #14 '{'
< #15 '{'
< #16 OBJECTID out_string
< #16 '('
< #16 STR_CONST "Enter a number>"
< #16 ')'
< #16 ';'
< #17 OBJECTID in_string
< #17 '('
< #17 ')'
< #17 ';'
< #18 '}'
< #19 '}'
< #19 ';'
< #21 OBJECTID main
< #21 '('
< #21 ')'
< #21 ':'
< #21 TYPEID Object
< #21 '{'
< #25 '('
< #25 LET
< #25 OBJECTID z
< #25 ':'
< #25 TYPEID A2I
< #25 ASSIGN
< #25 NEW
< #25 TYPEID A2I
< #25 IN
< #26 WHILE
< #26 BOOL_CONST true
< #26 LOOP
< #27 '('
< #27 LET
< #27 OBJECTID s
< #27 ':'
< #27 TYPEID String
< #27 ASSIGN
< #27 OBJECTID prompt
< #27 '('
< #27 ')'
< #27 IN
< #28 IF
< #28 OBJECTID s
< #28 '='
< #28 STR_CONST "stop"
< #28 THEN
< #29 OBJECTID abort
< #29 '('
< #29 ')'
< #30 ELSE
< #31 '('
< #31 LET
< #31 OBJECTID i
< #31 ':'
< #31 TYPEID Int
< #31 ASSIGN
< #31 OBJECTID z
< #31 '.'
< #31 OBJECTID a2i
< #31 '('
< #31 OBJECTID s
< #31 ')'
< #31 IN
< #32 '('
< #32 LET
< #32 OBJECTID news
< #32 ':'
< #32 TYPEID String
< #32 ASSIGN
< #32 OBJECTID z
< #32 '.'
< #32 OBJECTID i2a
< #32 '('
< #32 OBJECTID i
< #32 ')'
< #32 IN
< #33 '{'
< #34 OBJECTID out_int
< #34 '('
< #34 OBJECTID i
< #34 ')'
< #34 ';'
< #35 OBJECTID newline
< #35 '('
< #35 ')'
< #35 ';'
< #36 OBJECTID out_string
< #36 '('
< #36 OBJECTID news
< #36 ')'
< #36 ';'
< #37 OBJECTID newline
< #37 '('
< #37 ')'
< #37 ';'
< #38 '}'
< #39 ')'
< #40 ')'
< #41 FI
< #42 ')'
< #43 POOL
< #44 ')'
< #45 '}'
< #45 ';'
< #46 '}'
< #46 ';'
---
> (*
>    This method implements a driver for testing the ATOI class.
> The program repeatedly asks the user to enter a number, which
> is then coverted from its string form to an integer and back
> again to a string.  The results of both conversions are printed
> on the screen.  Typing "stop" at the prompt exits the program.
> *)
> 
> class Main inherits IO {
>    newline() : Object {
> 	out_string("\n")
>    };
> 
>    prompt() : String {
> 	{
> 	   out_string("Enter a number>");
> 	   in_string();
> 	}
>    };
> 
>    main() : Object {
>    (* Since we didn't bother to inherit from the A2I class, we have
> 	to have an object of type A2I in order to access the
> 	methods of that class. *)
>      (let z : A2I <- new A2I in
> 	while true loop  
> 	   (let s : String <- prompt() in
> 		if s = "stop" then 
> 		    abort() -- we don't bother to terminate gracefully
> 		else
> 		   (let i : Int <- z.a2i(s) in
> 			(let news : String <- z.i2a(i) in
> 			   {
> 			     out_int(i);
> 			     newline();
> 			     out_string(news);
> 			     newline();
> 			   }
> 	                )
>                   )
> 		fi
> 	   )
>         pool
>      )
>    };
> };
pass!
---------  Test  ../../examples/book_list.cl  ---------
2,481c2,135
< #3 CLASS
< #3 TYPEID Book
< #3 INHERITS
< #3 TYPEID IO
< #3 '{'
< #4 OBJECTID title
< #4 ':'
< #4 TYPEID String
< #4 ';'
< #5 OBJECTID author
< #5 ':'
< #5 TYPEID String
< #5 ';'
< #7 OBJECTID initBook
< #7 '('
< #7 OBJECTID title_p
< #7 ':'
< #7 TYPEID String
< #7 ','
< #7 OBJECTID author_p
< #7 ':'
< #7 TYPEID String
< #7 ')'
< #7 ':'
< #7 TYPEID Book
< #7 '{'
< #8 '{'
< #9 OBJECTID title
< #9 ASSIGN
< #9 OBJECTID title_p
< #9 ';'
< #10 OBJECTID author
< #10 ASSIGN
< #10 OBJECTID author_p
< #10 ';'
< #11 OBJECTID self
< #11 ';'
< #12 '}'
< #13 '}'
< #13 ';'
< #15 OBJECTID print
< #15 '('
< #15 ')'
< #15 ':'
< #15 TYPEID Book
< #15 '{'
< #16 '{'
< #17 OBJECTID out_string
< #17 '('
< #17 STR_CONST "title:      "
< #17 ')'
< #17 '.'
< #17 OBJECTID out_string
< #17 '('
< #17 OBJECTID title
< #17 ')'
< #17 '.'
< #17 OBJECTID out_string
< #17 '('
< #17 STR_CONST "\n"
< #17 ')'
< #17 ';'
< #18 OBJECTID out_string
< #18 '('
< #18 STR_CONST "author:     "
< #18 ')'
< #18 '.'
< #18 OBJECTID out_string
< #18 '('
< #18 OBJECTID author
< #18 ')'
< #18 '.'
< #18 OBJECTID out_string
< #18 '('
< #18 STR_CONST "\n"
< #18 ')'
< #18 ';'
< #19 OBJECTID self
< #19 ';'
< #20 '}'
< #21 '}'
< #21 ';'
< #22 '}'
< #22 ';'
< #24 CLASS
< #24 TYPEID Article
< #24 INHERITS
< #24 TYPEID Book
< #24 '{'
< #25 OBJECTID per_title
< #25 ':'
< #25 TYPEID String
< #25 ';'
< #27 OBJECTID initArticle
< #27 '('
< #27 OBJECTID title_p
< #27 ':'
< #27 TYPEID String
< #27 ','
< #27 OBJECTID author_p
< #27 ':'
< #27 TYPEID String
< #27 ','
< #28 OBJECTID per_title_p
< #28 ':'
< #28 TYPEID String
< #28 ')'
< #28 ':'
< #28 TYPEID Article
< #28 '{'
< #29 '{'
< #30 OBJECTID initBook
< #30 '('
< #30 OBJECTID title_p
< #30 ','
< #30 OBJECTID author_p
< #30 ')'
< #30 ';'
< #31 OBJECTID per_title
< #31 ASSIGN
< #31 OBJECTID per_title_p
< #31 ';'
< #32 OBJECTID self
< #32 ';'
< #33 '}'
< #34 '}'
< #34 ';'
< #36 OBJECTID print
< #36 '('
< #36 ')'
< #36 ':'
< #36 TYPEID Book
< #36 '{'
< #37 '{'
< #38 OBJECTID self
< #38 '@'
< #38 TYPEID Book
< #38 '.'
< #38 OBJECTID print
< #38 '('
< #38 ')'
< #38 ';'
< #39 OBJECTID out_string
< #39 '('
< #39 STR_CONST "periodical:  "
< #39 ')'
< #39 '.'
< #39 OBJECTID out_string
< #39 '('
< #39 OBJECTID per_title
< #39 ')'
< #39 '.'
< #39 OBJECTID out_string
< #39 '('
< #39 STR_CONST "\n"
< #39 ')'
< #39 ';'
< #40 OBJECTID self
< #40 ';'
< #41 '}'
< #42 '}'
< #42 ';'
< #43 '}'
< #43 ';'
< #45 CLASS
< #45 TYPEID BookList
< #45 INHERITS
< #45 TYPEID IO
< #45 '{'
< #50 OBJECTID isNil
< #50 '('
< #50 ')'
< #50 ':'
< #50 TYPEID Bool
< #50 '{'
< #50 '{'
< #50 OBJECTID abort
< #50 '('
< #50 ')'
< #50 ';'
< #50 BOOL_CONST true
< #50 ';'
< #50 '}'
< #50 '}'
< #50 ';'
< #52 OBJECTID cons
< #52 '('
< #52 OBJECTID hd
< #52 ':'
< #52 TYPEID Book
< #52 ')'
< #52 ':'
< #52 TYPEID Cons
< #52 '{'
< #53 '('
< #53 LET
< #53 OBJECTID new_cell
< #53 ':'
< #53 TYPEID Cons
< #53 ASSIGN
< #53 NEW
< #53 TYPEID Cons
< #53 IN
< #54 OBJECTID new_cell
< #54 '.'
< #54 OBJECTID init
< #54 '('
< #54 OBJECTID hd
< #54 ','
< #54 OBJECTID self
< #54 ')'
< #55 ')'
< #56 '}'
< #56 ';'
< #62 OBJECTID car
< #62 '('
< #62 ')'
< #62 ':'
< #62 TYPEID Book
< #62 '{'
< #62 '{'
< #62 OBJECTID abort
< #62 '('
< #62 ')'
< #62 ';'
< #62 NEW
< #62 TYPEID Book
< #62 ';'
< #62 '}'
< #62 '}'
< #62 ';'
< #68 OBJECTID cdr
< #68 '('
< #68 ')'
< #68 ':'
< #68 TYPEID BookList
< #68 '{'
< #68 '{'
< #68 OBJECTID abort
< #68 '('
< #68 ')'
< #68 ';'
< #68 NEW
< #68 TYPEID BookList
< #68 ';'
< #68 '}'
< #68 '}'
< #68 ';'
< #70 OBJECTID print_list
< #70 '('
< #70 ')'
< #70 ':'
< #70 TYPEID Object
< #70 '{'
< #70 OBJECTID abort
< #70 '('
< #70 ')'
< #70 '}'
< #70 ';'
< #71 '}'
< #71 ';'
< #73 CLASS
< #73 TYPEID Cons
< #73 INHERITS
< #73 TYPEID BookList
< #73 '{'
< #74 OBJECTID xcar
< #74 ':'
< #74 TYPEID Book
< #74 ';'
< #75 OBJECTID xcdr
< #75 ':'
< #75 TYPEID BookList
< #75 ';'
< #79 OBJECTID isNil
< #79 '('
< #79 ')'
< #79 ':'
< #79 TYPEID Bool
< #79 '{'
< #79 BOOL_CONST false
< #79 '}'
< #79 ';'
< #81 OBJECTID init
< #81 '('
< #81 OBJECTID hd
< #81 ':'
< #81 TYPEID Book
< #81 ','
< #81 OBJECTID tl
< #81 ':'
< #81 TYPEID BookList
< #81 ')'
< #81 ':'
< #81 TYPEID Cons
< #81 '{'
< #82 '{'
< #83 OBJECTID xcar
< #83 ASSIGN
< #83 OBJECTID hd
< #83 ';'
< #84 OBJECTID xcdr
< #84 ASSIGN
< #84 OBJECTID tl
< #84 ';'
< #85 OBJECTID self
< #85 ';'
< #86 '}'
< #87 '}'
< #87 ';'
< #89 OBJECTID car
< #89 '('
< #89 ')'
< #89 ':'
< #89 TYPEID Book
< #89 '{'
< #89 OBJECTID xcar
< #89 '}'
< #89 ';'
< #91 OBJECTID cdr
< #91 '('
< #91 ')'
< #91 ':'
< #91 TYPEID BookList
< #91 '{'
< #91 OBJECTID xcdr
< #91 '}'
< #91 ';'
< #93 OBJECTID print_list
< #93 '('
< #93 ')'
< #93 ':'
< #93 TYPEID Object
< #93 '{'
< #94 '{'
< #95 CASE
< #95 OBJECTID xcar
< #95 '.'
< #95 OBJECTID print
< #95 '('
< #95 ')'
< #95 OF
< #96 OBJECTID dummy
< #96 ':'
< #96 TYPEID Book
< #96 DARROW
< #96 OBJECTID out_string
< #96 '('
< #96 STR_CONST "- dynamic type was Book -\n"
< #96 ')'
< #96 ';'
< #97 OBJECTID dummy
< #97 ':'
< #97 TYPEID Article
< #97 DARROW
< #97 OBJECTID out_string
< #97 '('
< #97 STR_CONST "- dynamic type was Article -\n"
< #97 ')'
< #97 ';'
< #98 ESAC
< #98 ';'
< #99 OBJECTID xcdr
< #99 '.'
< #99 OBJECTID print_list
< #99 '('
< #99 ')'
< #99 ';'
< #100 '}'
< #101 '}'
< #101 ';'
< #102 '}'
< #102 ';'
< #104 CLASS
< #104 TYPEID Nil
< #104 INHERITS
< #104 TYPEID BookList
< #104 '{'
< #105 OBJECTID isNil
< #105 '('
< #105 ')'
< #105 ':'
< #105 TYPEID Bool
< #105 '{'
< #105 BOOL_CONST true
< #105 '}'
< #105 ';'
< #107 OBJECTID print_list
< #107 '('
< #107 ')'
< #107 ':'
< #107 TYPEID Object
< #107 '{'
< #107 BOOL_CONST true
< #107 '}'
< #107 ';'
< #108 '}'
< #108 ';'
< #111 CLASS
< #111 TYPEID Main
< #111 '{'
< #113 OBJECTID books
< #113 ':'
< #113 TYPEID BookList
< #113 ';'
< #115 OBJECTID main
< #115 '('
< #115 ')'
< #115 ':'
< #115 TYPEID Object
< #115 '{'
< #116 '('
< #116 LET
< #116 OBJECTID a_book
< #116 ':'
< #116 TYPEID Book
< #116 ASSIGN
< #117 '('
< #117 NEW
< #117 TYPEID Book
< #117 ')'
< #117 '.'
< #117 OBJECTID initBook
< #117 '('
< #117 STR_CONST "Compilers, Principles, Techniques, and Tools"
< #117 ','
< #118 STR_CONST "Aho, Sethi, and Ullman"
< #118 ')'
< #119 IN
< #120 '('
< #120 LET
< #120 OBJECTID an_article
< #120 ':'
< #120 TYPEID Article
< #120 ASSIGN
< #121 '('
< #121 NEW
< #121 TYPEID Article
< #121 ')'
< #121 '.'
< #121 OBJECTID initArticle
< #121 '('
< #121 STR_CONST "The Top 100 CD_ROMs"
< #121 ','
< #122 STR_CONST "Ulanoff"
< #122 ','
< #123 STR_CONST "PC Magazine"
< #123 ')'
< #124 IN
< #125 '{'
< #126 OBJECTID books
< #126 ASSIGN
< #126 '('
< #126 NEW
< #126 TYPEID Nil
< #126 ')'
< #126 '.'
< #126 OBJECTID cons
< #126 '('
< #126 OBJECTID a_book
< #126 ')'
< #126 '.'
< #126 OBJECTID cons
< #126 '('
< #126 OBJECTID an_article
< #126 ')'
< #126 ';'
< #127 OBJECTID books
< #127 '.'
< #127 OBJECTID print_list
< #127 '('
< #127 ')'
< #127 ';'
< #128 '}'
< #129 ')'
< #130 ')'
< #131 '}'
< #131 ';'
< #132 '}'
< #132 ';'
---
> -- example of static and dynamic type differing for a dispatch
> 
> Class Book inherits IO {
>     title : String;
>     author : String;
> 
>     initBook(title_p : String, author_p : String) : Book {
>         {
>             title <- title_p;
>             author <- author_p;
>             self;
>         }
>     };
> 
>     print() : Book {
>         {
>             out_string("title:      ").out_string(title).out_string("\n");
>             out_string("author:     ").out_string(author).out_string("\n");
>             self;
>         }
>     };
> };
> 
> Class Article inherits Book {
>     per_title : String;
> 
>     initArticle(title_p : String, author_p : String,
> 		per_title_p : String) : Article {
>         {
>             initBook(title_p, author_p);
>             per_title <- per_title_p;
>             self;
>         }
>     };
> 
>     print() : Book {
>         {
> 	    self@Book.print();
>             out_string("periodical:  ").out_string(per_title).out_string("\n");
>             self;
>         }
>     };
> };
> 
> Class BookList inherits IO { 
>     (* Since abort "returns" type Object, we have to add
>        an expression of type Bool here to satisfy the typechecker.
>        This code is unreachable, since abort() halts the program.
>     *)
>     isNil() : Bool { { abort(); true; } };
>     
>     cons(hd : Book) : Cons {
>         (let new_cell : Cons <- new Cons in
>             new_cell.init(hd,self)
>         )
>     };
> 
>     (* Since abort "returns" type Object, we have to add
>        an expression of type Book here to satisfy the typechecker.
>        This code is unreachable, since abort() halts the program.
>     *)
>     car() : Book { { abort(); new Book; } };
>     
>     (* Since abort "returns" type Object, we have to add
>        an expression of type BookList here to satisfy the typechecker.
>        This code is unreachable, since abort() halts the program.
>     *)
>     cdr() : BookList { { abort(); new BookList; } };
>     
>     print_list() : Object { abort() };
> };
> 
> Class Cons inherits BookList {
>     xcar : Book;  -- We keep the car and cdr in attributes.
>     xcdr : BookList; -- Because methods and features must have different names,
>     -- we use xcar and xcdr for the attributes and reserve
>     -- car and cdr for the features.
>     
>     isNil() : Bool { false };
>     
>     init(hd : Book, tl : BookList) : Cons {
>         {
>             xcar <- hd;
>             xcdr <- tl;
>             self;
>         }
>     };
> 
>     car() : Book { xcar };
> 
>     cdr() : BookList { xcdr };
>     
>     print_list() : Object {
>         {
>             case xcar.print() of
>                 dummy : Book #1 DARROW
>  out_string("- dynamic type was Book -\n");
>                 dummy : Article #1 DARROW
>  out_string("- dynamic type was Article -\n");
>             esac;
>             xcdr.print_list();
>         }
>     };
> };
> 
> Class Nil inherits BookList {
>     isNil() : Bool { true };
> 
>     print_list() : Object { true };
> };
> 
> 
> Class Main {
> 
>     books : BookList;
> 
>     main() : Object {
>         (let a_book : Book <-
>             (new Book).initBook("Compilers, Principles, Techniques, and Tools",
>                                 "Aho, Sethi, and Ullman")
>         in
>             (let an_article : Article <-
>                 (new Article).initArticle("The Top 100 CD_ROMs",
>                                           "Ulanoff",
>                                           "PC Magazine")
>             in
>                 {
>                     books <- (new Nil).cons(a_book).cons(an_article);
>                     books.print_list();
>                 }
>             )  -- end let an_article
>         )  -- end let a_book
>     };
> };
pass!
---------  Test  ../../examples/cells.cl  ---------
2,351c2,98
< #5 CLASS
< #5 TYPEID CellularAutomaton
< #5 INHERITS
< #5 TYPEID IO
< #5 '{'
< #6 OBJECTID population_map
< #6 ':'
< #6 TYPEID String
< #6 ';'
< #8 OBJECTID init
< #8 '('
< #8 OBJECTID map
< #8 ':'
< #8 TYPEID String
< #8 ')'
< #8 ':'
< #8 TYPEID SELF_TYPE
< #8 '{'
< #9 '{'
< #10 OBJECTID population_map
< #10 ASSIGN
< #10 OBJECTID map
< #10 ';'
< #11 OBJECTID self
< #11 ';'
< #12 '}'
< #13 '}'
< #13 ';'
< #15 OBJECTID print
< #15 '('
< #15 ')'
< #15 ':'
< #15 TYPEID SELF_TYPE
< #15 '{'
< #16 '{'
< #17 OBJECTID out_string
< #17 '('
< #17 OBJECTID population_map
< #17 '.'
< #17 OBJECTID concat
< #17 '('
< #17 STR_CONST "\n"
< #17 ')'
< #17 ')'
< #17 ';'
< #18 OBJECTID self
< #18 ';'
< #19 '}'
< #20 '}'
< #20 ';'
< #22 OBJECTID num_cells
< #22 '('
< #22 ')'
< #22 ':'
< #22 TYPEID Int
< #22 '{'
< #23 OBJECTID population_map
< #23 '.'
< #23 OBJECTID length
< #23 '('
< #23 ')'
< #24 '}'
< #24 ';'
< #26 OBJECTID cell
< #26 '('
< #26 OBJECTID position
< #26 ':'
< #26 TYPEID Int
< #26 ')'
< #26 ':'
< #26 TYPEID String
< #26 '{'
< #27 OBJECTID population_map
< #27 '.'
< #27 OBJECTID substr
< #27 '('
< #27 OBJECTID position
< #27 ','
< #27 INT_CONST 1
< #27 ')'
< #28 '}'
< #28 ';'
< #30 OBJECTID cell_left_neighbor
< #30 '('
< #30 OBJECTID position
< #30 ':'
< #30 TYPEID Int
< #30 ')'
< #30 ':'
< #30 TYPEID String
< #30 '{'
< #31 IF
< #31 OBJECTID position
< #31 '='
< #31 INT_CONST 0
< #31 THEN
< #32 OBJECTID cell
< #32 '('
< #32 OBJECTID num_cells
< #32 '('
< #32 ')'
< #32 '-'
< #32 INT_CONST 1
< #32 ')'
< #33 ELSE
< #34 OBJECTID cell
< #34 '('
< #34 OBJECTID position
< #34 '-'
< #34 INT_CONST 1
< #34 ')'
< #35 FI
< #36 '}'
< #36 ';'
< #38 OBJECTID cell_right_neighbor
< #38 '('
< #38 OBJECTID position
< #38 ':'
< #38 TYPEID Int
< #38 ')'
< #38 ':'
< #38 TYPEID String
< #38 '{'
< #39 IF
< #39 OBJECTID position
< #39 '='
< #39 OBJECTID num_cells
< #39 '('
< #39 ')'
< #39 '-'
< #39 INT_CONST 1
< #39 THEN
< #40 OBJECTID cell
< #40 '('
< #40 INT_CONST 0
< #40 ')'
< #41 ELSE
< #42 OBJECTID cell
< #42 '('
< #42 OBJECTID position
< #42 '+'
< #42 INT_CONST 1
< #42 ')'
< #43 FI
< #44 '}'
< #44 ';'
< #48 OBJECTID cell_at_next_evolution
< #48 '('
< #48 OBJECTID position
< #48 ':'
< #48 TYPEID Int
< #48 ')'
< #48 ':'
< #48 TYPEID String
< #48 '{'
< #49 IF
< #49 '('
< #49 IF
< #49 OBJECTID cell
< #49 '('
< #49 OBJECTID position
< #49 ')'
< #49 '='
< #49 STR_CONST "X"
< #49 THEN
< #49 INT_CONST 1
< #49 ELSE
< #49 INT_CONST 0
< #49 FI
< #50 '+'
< #50 IF
< #50 OBJECTID cell_left_neighbor
< #50 '('
< #50 OBJECTID position
< #50 ')'
< #50 '='
< #50 STR_CONST "X"
< #50 THEN
< #50 INT_CONST 1
< #50 ELSE
< #50 INT_CONST 0
< #50 FI
< #51 '+'
< #51 IF
< #51 OBJECTID cell_right_neighbor
< #51 '('
< #51 OBJECTID position
< #51 ')'
< #51 '='
< #51 STR_CONST "X"
< #51 THEN
< #51 INT_CONST 1
< #51 ELSE
< #51 INT_CONST 0
< #51 FI
< #52 '='
< #52 INT_CONST 1
< #52 ')'
< #53 THEN
< #54 STR_CONST "X"
< #55 ELSE
< #56 STR_CONST "."
< #57 FI
< #58 '}'
< #58 ';'
< #60 OBJECTID evolve
< #60 '('
< #60 ')'
< #60 ':'
< #60 TYPEID SELF_TYPE
< #60 '{'
< #61 '('
< #61 LET
< #61 OBJECTID position
< #61 ':'
< #61 TYPEID Int
< #61 IN
< #62 '('
< #62 LET
< #62 OBJECTID num
< #62 ':'
< #62 TYPEID Int
< #62 ASSIGN
< #62 OBJECTID num_cells
< #62 '('
< #62 ')'
< #62 IN
< #63 '('
< #63 LET
< #63 OBJECTID temp
< #63 ':'
< #63 TYPEID String
< #63 IN
< #64 '{'
< #65 WHILE
< #65 OBJECTID position
< #65 '<'
< #65 OBJECTID num
< #65 LOOP
< #66 '{'
< #67 OBJECTID temp
< #67 ASSIGN
< #67 OBJECTID temp
< #67 '.'
< #67 OBJECTID concat
< #67 '('
< #67 OBJECTID cell_at_next_evolution
< #67 '('
< #67 OBJECTID position
< #67 ')'
< #67 ')'
< #67 ';'
< #68 OBJECTID position
< #68 ASSIGN
< #68 OBJECTID position
< #68 '+'
< #68 INT_CONST 1
< #68 ';'
< #69 '}'
< #70 POOL
< #70 ';'
< #71 OBJECTID population_map
< #71 ASSIGN
< #71 OBJECTID temp
< #71 ';'
< #72 OBJECTID self
< #72 ';'
< #73 '}'
< #74 ')'
< #74 ')'
< #74 ')'
< #75 '}'
< #75 ';'
< #76 '}'
< #76 ';'
< #78 CLASS
< #78 TYPEID Main
< #78 '{'
< #79 OBJECTID cells
< #79 ':'
< #79 TYPEID CellularAutomaton
< #79 ';'
< #81 OBJECTID main
< #81 '('
< #81 ')'
< #81 ':'
< #81 TYPEID SELF_TYPE
< #81 '{'
< #82 '{'
< #83 OBJECTID cells
< #83 ASSIGN
< #83 '('
< #83 NEW
< #83 TYPEID CellularAutomaton
< #83 ')'
< #83 '.'
< #83 OBJECTID init
< #83 '('
< #83 STR_CONST "         X         "
< #83 ')'
< #83 ';'
< #84 OBJECTID cells
< #84 '.'
< #84 OBJECTID print
< #84 '('
< #84 ')'
< #84 ';'
< #85 '('
< #85 LET
< #85 OBJECTID countdown
< #85 ':'
< #85 TYPEID Int
< #85 ASSIGN
< #85 INT_CONST 20
< #85 IN
< #86 WHILE
< #86 INT_CONST 0
< #86 '<'
< #86 OBJECTID countdown
< #86 LOOP
< #87 '{'
< #88 OBJECTID cells
< #88 '.'
< #88 OBJECTID evolve
< #88 '('
< #88 ')'
< #88 ';'
< #89 OBJECTID cells
< #89 '.'
< #89 OBJECTID print
< #89 '('
< #89 ')'
< #89 ';'
< #90 OBJECTID countdown
< #90 ASSIGN
< #90 OBJECTID countdown
< #90 '-'
< #90 INT_CONST 1
< #90 ';'
< #91 '}'
< #92 POOL
< #93 ')'
< #93 ';'
< #94 OBJECTID self
< #94 ';'
< #95 '}'
< #96 '}'
< #96 ';'
< #97 '}'
< #97 ';'
---
> (* models one-dimensional cellular automaton on a circle of finite radius
>    arrays are faked as Strings,
>    X's respresent live cells, dots represent dead cells,
>    no error checking is done *)
> class CellularAutomaton inherits IO {
>     population_map : String;
>    
>     init(map : String) : SELF_TYPE {
>         {
>             population_map <- map;
>             self;
>         }
>     };
>    
>     print() : SELF_TYPE {
>         {
>             out_string(population_map.concat("\n"));
>             self;
>         }
>     };
>    
>     num_cells() : Int {
>         population_map.length()
>     };
>    
>     cell(position : Int) : String {
>         population_map.substr(position, 1)
>     };
>    
>     cell_left_neighbor(position : Int) : String {
>         if position = 0 then
>             cell(num_cells() - 1)
>         else
>             cell(position - 1)
>         fi
>     };
>    
>     cell_right_neighbor(position : Int) : String {
>         if position = num_cells() - 1 then
>             cell(0)
>         else
>             cell(position + 1)
>         fi
>     };
>    
>     (* a cell will live if exactly 1 of itself and it's immediate
>        neighbors are alive *)
>     cell_at_next_evolution(position : Int) : String {
>         if (if cell(position) = "X" then 1 else 0 fi
>             + if cell_left_neighbor(position) = "X" then 1 else 0 fi
>             + if cell_right_neighbor(position) = "X" then 1 else 0 fi
>             = 1)
>         then
>             "X"
>         else
>             "."
>         fi
>     };
>    
>     evolve() : SELF_TYPE {
>         (let position : Int in
>         (let num : Int <- num_cells() in
>         (let temp : String in
>             {
>                 while position < num loop
>                     {
>                         temp <- temp.concat(cell_at_next_evolution(position));
>                         position <- position + 1;
>                     }
>                 pool;
>                 population_map <- temp;
>                 self;
>             }
>         ) ) )
>     };
> };
> 
> class Main {
>     cells : CellularAutomaton;
>    
>     main() : SELF_TYPE {
>         {
>             cells <- (new CellularAutomaton).init("         X         ");
>             cells.print();
>             (let countdown : Int <- 20 in
>                 while 0 < countdown loop
>                     {
>                         cells.evolve();
>                         cells.print();
>                         countdown <- countdown - 1;
>                     }
>                 pool
>             );
>             self;
>         }
>     };
> };
pass!
---------  Test  ../../examples/complex.cl  ---------
2,198c2,53
< #1 CLASS
< #1 TYPEID Main
< #1 INHERITS
< #1 TYPEID IO
< #1 '{'
< #2 OBJECTID main
< #2 '('
< #2 ')'
< #2 ':'
< #2 TYPEID SELF_TYPE
< #2 '{'
< #3 '('
< #3 LET
< #3 OBJECTID c
< #3 ':'
< #3 TYPEID Complex
< #3 ASSIGN
< #3 '('
< #3 NEW
< #3 TYPEID Complex
< #3 ')'
< #3 '.'
< #3 OBJECTID init
< #3 '('
< #3 INT_CONST 1
< #3 ','
< #3 INT_CONST 1
< #3 ')'
< #3 IN
< #4 IF
< #4 OBJECTID c
< #4 '.'
< #4 OBJECTID reflect_X
< #4 '('
< #4 ')'
< #4 '.'
< #4 OBJECTID reflect_Y
< #4 '('
< #4 ')'
< #4 '='
< #4 OBJECTID c
< #4 '.'
< #4 OBJECTID reflect_0
< #4 '('
< #4 ')'
< #5 THEN
< #5 OBJECTID out_string
< #5 '('
< #5 STR_CONST "=)\n"
< #5 ')'
< #6 ELSE
< #6 OBJECTID out_string
< #6 '('
< #6 STR_CONST "=(\n"
< #6 ')'
< #7 FI
< #8 ')'
< #9 '}'
< #9 ';'
< #10 '}'
< #10 ';'
< #12 CLASS
< #12 TYPEID Complex
< #12 INHERITS
< #12 TYPEID IO
< #12 '{'
< #13 OBJECTID x
< #13 ':'
< #13 TYPEID Int
< #13 ';'
< #14 OBJECTID y
< #14 ':'
< #14 TYPEID Int
< #14 ';'
< #16 OBJECTID init
< #16 '('
< #16 OBJECTID a
< #16 ':'
< #16 TYPEID Int
< #16 ','
< #16 OBJECTID b
< #16 ':'
< #16 TYPEID Int
< #16 ')'
< #16 ':'
< #16 TYPEID Complex
< #16 '{'
< #17 '{'
< #18 OBJECTID x
< #18 '='
< #18 OBJECTID a
< #18 ';'
< #19 OBJECTID y
< #19 '='
< #19 OBJECTID b
< #19 ';'
< #20 OBJECTID self
< #20 ';'
< #21 '}'
< #22 '}'
< #22 ';'
< #24 OBJECTID print
< #24 '('
< #24 ')'
< #24 ':'
< #24 TYPEID Object
< #24 '{'
< #25 IF
< #25 OBJECTID y
< #25 '='
< #25 INT_CONST 0
< #26 THEN
< #26 OBJECTID out_int
< #26 '('
< #26 OBJECTID x
< #26 ')'
< #27 ELSE
< #27 OBJECTID out_int
< #27 '('
< #27 OBJECTID x
< #27 ')'
< #27 '.'
< #27 OBJECTID out_string
< #27 '('
< #27 STR_CONST "+"
< #27 ')'
< #27 '.'
< #27 OBJECTID out_int
< #27 '('
< #27 OBJECTID y
< #27 ')'
< #27 '.'
< #27 OBJECTID out_string
< #27 '('
< #27 STR_CONST "I"
< #27 ')'
< #28 FI
< #29 '}'
< #29 ';'
< #31 OBJECTID reflect_0
< #31 '('
< #31 ')'
< #31 ':'
< #31 TYPEID Complex
< #31 '{'
< #32 '{'
< #33 OBJECTID x
< #33 '='
< #33 '~'
< #33 OBJECTID x
< #33 ';'
< #34 OBJECTID y
< #34 '='
< #34 '~'
< #34 OBJECTID y
< #34 ';'
< #35 OBJECTID self
< #35 ';'
< #36 '}'
< #37 '}'
< #37 ';'
< #39 OBJECTID reflect_X
< #39 '('
< #39 ')'
< #39 ':'
< #39 TYPEID Complex
< #39 '{'
< #40 '{'
< #41 OBJECTID y
< #41 '='
< #41 '~'
< #41 OBJECTID y
< #41 ';'
< #42 OBJECTID self
< #42 ';'
< #43 '}'
< #44 '}'
< #44 ';'
< #46 OBJECTID reflect_Y
< #46 '('
< #46 ')'
< #46 ':'
< #46 TYPEID Complex
< #46 '{'
< #47 '{'
< #48 OBJECTID x
< #48 '='
< #48 '~'
< #48 OBJECTID x
< #48 ';'
< #49 OBJECTID self
< #49 ';'
< #50 '}'
< #51 '}'
< #51 ';'
< #52 '}'
< #52 ';'
---
> class Main inherits IO {
>     main() : SELF_TYPE {
> 	(let c : Complex <- (new Complex).init(1, 1) in
> 	    if c.reflect_X().reflect_Y() = c.reflect_0()
> 	    then out_string("=)\n")
> 	    else out_string("=(\n")
> 	    fi
> 	)
>     };
> };
> 
> class Complex inherits IO {
>     x : Int;
>     y : Int;
> 
>     init(a : Int, b : Int) : Complex {
> 	{
> 	    x = a;
> 	    y = b;
> 	    self;
> 	}
>     };
> 
>     print() : Object {
> 	if y = 0
> 	then out_int(x)
> 	else out_int(x).out_string("+").out_int(y).out_string("I")
> 	fi
>     };
> 
>     reflect_0() : Complex {
> 	{
> 	    x = ~x;
> 	    y = ~y;
> 	    self;
> 	}
>     };
> 
>     reflect_X() : Complex {
> 	{
> 	    y = ~y;
> 	    self;
> 	}
>     };
> 
>     reflect_Y() : Complex {
> 	{
> 	    x = ~x;
> 	    self;
> 	}
>     };
> };
pass!
---------  Test  ../../examples/cool.cl  ---------
2,61c2,10
< #1 CLASS
< #1 TYPEID Main
< #1 INHERITS
< #1 TYPEID IO
< #1 '{'
< #2 OBJECTID main
< #2 '('
< #2 ')'
< #2 ':'
< #2 TYPEID SELF_TYPE
< #2 '{'
< #3 '{'
< #4 OBJECTID out_string
< #4 '('
< #4 '('
< #4 NEW
< #4 TYPEID Object
< #4 ')'
< #4 '.'
< #4 OBJECTID type_name
< #4 '('
< #4 ')'
< #4 '.'
< #4 OBJECTID substr
< #4 '('
< #4 INT_CONST 4
< #4 ','
< #4 INT_CONST 1
< #4 ')'
< #4 ')'
< #4 '.'
< #5 OBJECTID out_string
< #5 '('
< #5 '('
< #5 ISVOID
< #5 OBJECTID self
< #5 ')'
< #5 '.'
< #5 OBJECTID type_name
< #5 '('
< #5 ')'
< #5 '.'
< #5 OBJECTID substr
< #5 '('
< #5 INT_CONST 1
< #5 ','
< #5 INT_CONST 3
< #5 ')'
< #5 ')'
< #5 ';'
< #6 OBJECTID out_string
< #6 '('
< #6 STR_CONST "\n"
< #6 ')'
< #6 ';'
< #7 '}'
< #8 '}'
< #8 ';'
< #9 '}'
< #9 ';'
---
> class Main inherits IO {
>     main() : SELF_TYPE {
> 	{
> 	    out_string((new Object).type_name().substr(4,1)).
> 	    out_string((isvoid self).type_name().substr(1,3));
> 	    out_string("\n");
> 	}
>     };
> };
pass!
---------  Test  ../../examples/graph.cl  ---------
2,1296c2,382
< #38 CLASS
< #38 TYPEID Graph
< #38 '{'
< #40 OBJECTID vertices
< #40 ':'
< #40 TYPEID VList
< #40 ASSIGN
< #40 NEW
< #40 TYPEID VList
< #40 ';'
< #41 OBJECTID edges
< #41 ':'
< #41 TYPEID EList
< #41 ASSIGN
< #41 NEW
< #41 TYPEID EList
< #41 ';'
< #43 OBJECTID add_vertice
< #43 '('
< #43 OBJECTID v
< #43 ':'
< #43 TYPEID Vertice
< #43 ')'
< #43 ':'
< #43 TYPEID Object
< #43 '{'
< #43 '{'
< #44 OBJECTID edges
< #44 ASSIGN
< #44 OBJECTID v
< #44 '.'
< #44 OBJECTID outgoing
< #44 '('
< #44 ')'
< #44 '.'
< #44 OBJECTID append
< #44 '('
< #44 OBJECTID edges
< #44 ')'
< #44 ';'
< #45 OBJECTID vertices
< #45 ASSIGN
< #45 OBJECTID vertices
< #45 '.'
< #45 OBJECTID cons
< #45 '('
< #45 OBJECTID v
< #45 ')'
< #45 ';'
< #46 '}'
< #46 '}'
< #46 ';'
< #48 OBJECTID print_E
< #48 '('
< #48 ')'
< #48 ':'
< #48 TYPEID Object
< #48 '{'
< #48 OBJECTID edges
< #48 '.'
< #48 OBJECTID print
< #48 '('
< #48 ')'
< #48 '}'
< #48 ';'
< #49 OBJECTID print_V
< #49 '('
< #49 ')'
< #49 ':'
< #49 TYPEID Object
< #49 '{'
< #49 OBJECTID vertices
< #49 '.'
< #49 OBJECTID print
< #49 '('
< #49 ')'
< #49 '}'
< #49 ';'
< #51 '}'
< #51 ';'
< #53 CLASS
< #53 TYPEID Vertice
< #53 INHERITS
< #53 TYPEID IO
< #53 '{'
< #55 OBJECTID num
< #55 ':'
< #55 TYPEID Int
< #55 ';'
< #56 OBJECTID out
< #56 ':'
< #56 TYPEID EList
< #56 ASSIGN
< #56 NEW
< #56 TYPEID EList
< #56 ';'
< #58 OBJECTID outgoing
< #58 '('
< #58 ')'
< #58 ':'
< #58 TYPEID EList
< #58 '{'
< #58 OBJECTID out
< #58 '}'
< #58 ';'
< #60 OBJECTID number
< #60 '('
< #60 ')'
< #60 ':'
< #60 TYPEID Int
< #60 '{'
< #60 OBJECTID num
< #60 '}'
< #60 ';'
< #62 OBJECTID init
< #62 '('
< #62 OBJECTID n
< #62 ':'
< #62 TYPEID Int
< #62 ')'
< #62 ':'
< #62 TYPEID SELF_TYPE
< #62 '{'
< #63 '{'
< #64 OBJECTID num
< #64 ASSIGN
< #64 OBJECTID n
< #64 ';'
< #65 OBJECTID self
< #65 ';'
< #66 '}'
< #67 '}'
< #67 ';'
< #70 OBJECTID add_out
< #70 '('
< #70 OBJECTID s
< #70 ':'
< #70 TYPEID Edge
< #70 ')'
< #70 ':'
< #70 TYPEID SELF_TYPE
< #70 '{'
< #71 '{'
< #72 OBJECTID out
< #72 ASSIGN
< #72 OBJECTID out
< #72 '.'
< #72 OBJECTID cons
< #72 '('
< #72 OBJECTID s
< #72 ')'
< #72 ';'
< #73 OBJECTID self
< #73 ';'
< #74 '}'
< #75 '}'
< #75 ';'
< #77 OBJECTID print
< #77 '('
< #77 ')'
< #77 ':'
< #77 TYPEID Object
< #77 '{'
< #78 '{'
< #79 OBJECTID out_int
< #79 '('
< #79 OBJECTID num
< #79 ')'
< #79 ';'
< #80 OBJECTID out
< #80 '.'
< #80 OBJECTID print
< #80 '('
< #80 ')'
< #80 ';'
< #81 '}'
< #82 '}'
< #82 ';'
< #84 '}'
< #84 ';'
< #86 CLASS
< #86 TYPEID Edge
< #86 INHERITS
< #86 TYPEID IO
< #86 '{'
< #88 OBJECTID from
< #88 ':'
< #88 TYPEID Int
< #88 ';'
< #89 OBJECTID to
< #89 ':'
< #89 TYPEID Int
< #89 ';'
< #90 OBJECTID weight
< #90 ':'
< #90 TYPEID Int
< #90 ';'
< #92 OBJECTID init
< #92 '('
< #92 OBJECTID f
< #92 ':'
< #92 TYPEID Int
< #92 ','
< #92 OBJECTID t
< #92 ':'
< #92 TYPEID Int
< #92 ','
< #92 OBJECTID w
< #92 ':'
< #92 TYPEID Int
< #92 ')'
< #92 ':'
< #92 TYPEID SELF_TYPE
< #92 '{'
< #93 '{'
< #94 OBJECTID from
< #94 ASSIGN
< #94 OBJECTID f
< #94 ';'
< #95 OBJECTID to
< #95 ASSIGN
< #95 OBJECTID t
< #95 ';'
< #96 OBJECTID weight
< #96 ASSIGN
< #96 OBJECTID w
< #96 ';'
< #97 OBJECTID self
< #97 ';'
< #98 '}'
< #99 '}'
< #99 ';'
< #101 OBJECTID print
< #101 '('
< #101 ')'
< #101 ':'
< #101 TYPEID Object
< #101 '{'
< #102 '{'
< #103 OBJECTID out_string
< #103 '('
< #103 STR_CONST " ("
< #103 ')'
< #103 ';'
< #104 OBJECTID out_int
< #104 '('
< #104 OBJECTID from
< #104 ')'
< #104 ';'
< #105 OBJECTID out_string
< #105 '('
< #105 STR_CONST ","
< #105 ')'
< #105 ';'
< #106 OBJECTID out_int
< #106 '('
< #106 OBJECTID to
< #106 ')'
< #106 ';'
< #107 OBJECTID out_string
< #107 '('
< #107 STR_CONST ")"
< #107 ')'
< #107 ';'
< #108 OBJECTID out_int
< #108 '('
< #108 OBJECTID weight
< #108 ')'
< #108 ';'
< #109 '}'
< #110 '}'
< #110 ';'
< #112 '}'
< #112 ';'
< #116 CLASS
< #116 TYPEID EList
< #116 INHERITS
< #116 TYPEID IO
< #116 '{'
< #119 OBJECTID car
< #119 ':'
< #119 TYPEID Edge
< #119 ';'
< #121 OBJECTID isNil
< #121 '('
< #121 ')'
< #121 ':'
< #121 TYPEID Bool
< #121 '{'
< #121 BOOL_CONST true
< #121 '}'
< #121 ';'
< #123 OBJECTID head
< #123 '('
< #123 ')'
< #123 ':'
< #123 TYPEID Edge
< #123 '{'
< #123 '{'
< #123 OBJECTID abort
< #123 '('
< #123 ')'
< #123 ';'
< #123 OBJECTID car
< #123 ';'
< #123 '}'
< #123 '}'
< #123 ';'
< #125 OBJECTID tail
< #125 '('
< #125 ')'
< #125 ':'
< #125 TYPEID EList
< #125 '{'
< #125 '{'
< #125 OBJECTID abort
< #125 '('
< #125 ')'
< #125 ';'
< #125 OBJECTID self
< #125 ';'
< #125 '}'
< #125 '}'
< #125 ';'
< #134 OBJECTID cons
< #134 '('
< #134 OBJECTID e
< #134 ':'
< #134 TYPEID Edge
< #134 ')'
< #134 ':'
< #134 TYPEID EList
< #134 '{'
< #135 '('
< #135 NEW
< #135 TYPEID ECons
< #135 ')'
< #135 '.'
< #135 OBJECTID init
< #135 '('
< #135 OBJECTID e
< #135 ','
< #135 OBJECTID self
< #135 ')'
< #136 '}'
< #136 ';'
< #138 OBJECTID append
< #138 '('
< #138 OBJECTID l
< #138 ':'
< #138 TYPEID EList
< #138 ')'
< #138 ':'
< #138 TYPEID EList
< #138 '{'
< #139 IF
< #139 OBJECTID self
< #139 '.'
< #139 OBJECTID isNil
< #139 '('
< #139 ')'
< #139 THEN
< #139 OBJECTID l
< #140 ELSE
< #140 OBJECTID tail
< #140 '('
< #140 ')'
< #140 '.'
< #140 OBJECTID append
< #140 '('
< #140 OBJECTID l
< #140 ')'
< #140 '.'
< #140 OBJECTID cons
< #140 '('
< #140 OBJECTID head
< #140 '('
< #140 ')'
< #140 ')'
< #141 FI
< #142 '}'
< #142 ';'
< #144 OBJECTID print
< #144 '('
< #144 ')'
< #144 ':'
< #144 TYPEID Object
< #144 '{'
< #145 OBJECTID out_string
< #145 '('
< #145 STR_CONST "\n"
< #145 ')'
< #146 '}'
< #146 ';'
< #148 '}'
< #148 ';'
< #164 CLASS
< #164 TYPEID ECons
< #164 INHERITS
< #164 TYPEID EList
< #164 '{'
< #166 OBJECTID cdr
< #166 ':'
< #166 TYPEID EList
< #166 ';'
< #168 OBJECTID isNil
< #168 '('
< #168 ')'
< #168 ':'
< #168 TYPEID Bool
< #168 '{'
< #168 BOOL_CONST false
< #168 '}'
< #168 ';'
< #170 OBJECTID head
< #170 '('
< #170 ')'
< #170 ':'
< #170 TYPEID Edge
< #170 '{'
< #170 OBJECTID car
< #170 '}'
< #170 ';'
< #172 OBJECTID tail
< #172 '('
< #172 ')'
< #172 ':'
< #172 TYPEID EList
< #172 '{'
< #172 OBJECTID cdr
< #172 '}'
< #172 ';'
< #174 OBJECTID init
< #174 '('
< #174 OBJECTID e
< #174 ':'
< #174 TYPEID Edge
< #174 ','
< #174 OBJECTID rest
< #174 ':'
< #174 TYPEID EList
< #174 ')'
< #174 ':'
< #174 TYPEID EList
< #174 '{'
< #175 '{'
< #176 OBJECTID car
< #176 ASSIGN
< #176 OBJECTID e
< #176 ';'
< #177 OBJECTID cdr
< #177 ASSIGN
< #177 OBJECTID rest
< #177 ';'
< #178 OBJECTID self
< #178 ';'
< #179 '}'
< #180 '}'
< #180 ';'
< #182 OBJECTID print
< #182 '('
< #182 ')'
< #182 ':'
< #182 TYPEID Object
< #182 '{'
< #183 '{'
< #184 OBJECTID car
< #184 '.'
< #184 OBJECTID print
< #184 '('
< #184 ')'
< #184 ';'
< #185 OBJECTID cdr
< #185 '.'
< #185 OBJECTID print
< #185 '('
< #185 ')'
< #185 ';'
< #186 '}'
< #187 '}'
< #187 ';'
< #189 '}'
< #189 ';'
< #194 CLASS
< #194 TYPEID VList
< #194 INHERITS
< #194 TYPEID IO
< #194 '{'
< #197 OBJECTID car
< #197 ':'
< #197 TYPEID Vertice
< #197 ';'
< #199 OBJECTID isNil
< #199 '('
< #199 ')'
< #199 ':'
< #199 TYPEID Bool
< #199 '{'
< #199 BOOL_CONST true
< #199 '}'
< #199 ';'
< #201 OBJECTID head
< #201 '('
< #201 ')'
< #201 ':'
< #201 TYPEID Vertice
< #201 '{'
< #201 '{'
< #201 OBJECTID abort
< #201 '('
< #201 ')'
< #201 ';'
< #201 OBJECTID car
< #201 ';'
< #201 '}'
< #201 '}'
< #201 ';'
< #203 OBJECTID tail
< #203 '('
< #203 ')'
< #203 ':'
< #203 TYPEID VList
< #203 '{'
< #203 '{'
< #203 OBJECTID abort
< #203 '('
< #203 ')'
< #203 ';'
< #203 OBJECTID self
< #203 ';'
< #203 '}'
< #203 '}'
< #203 ';'
< #212 OBJECTID cons
< #212 '('
< #212 OBJECTID v
< #212 ':'
< #212 TYPEID Vertice
< #212 ')'
< #212 ':'
< #212 TYPEID VList
< #212 '{'
< #213 '('
< #213 NEW
< #213 TYPEID VCons
< #213 ')'
< #213 '.'
< #213 OBJECTID init
< #213 '('
< #213 OBJECTID v
< #213 ','
< #213 OBJECTID self
< #213 ')'
< #214 '}'
< #214 ';'
< #216 OBJECTID print
< #216 '('
< #216 ')'
< #216 ':'
< #216 TYPEID Object
< #216 '{'
< #216 OBJECTID out_string
< #216 '('
< #216 STR_CONST "\n"
< #216 ')'
< #216 '}'
< #216 ';'
< #218 '}'
< #218 ';'
< #221 CLASS
< #221 TYPEID VCons
< #221 INHERITS
< #221 TYPEID VList
< #221 '{'
< #223 OBJECTID cdr
< #223 ':'
< #223 TYPEID VList
< #223 ';'
< #225 OBJECTID isNil
< #225 '('
< #225 ')'
< #225 ':'
< #225 TYPEID Bool
< #225 '{'
< #225 BOOL_CONST false
< #225 '}'
< #225 ';'
< #227 OBJECTID head
< #227 '('
< #227 ')'
< #227 ':'
< #227 TYPEID Vertice
< #227 '{'
< #227 OBJECTID car
< #227 '}'
< #227 ';'
< #229 OBJECTID tail
< #229 '('
< #229 ')'
< #229 ':'
< #229 TYPEID VList
< #229 '{'
< #229 OBJECTID cdr
< #229 '}'
< #229 ';'
< #231 OBJECTID init
< #231 '('
< #231 OBJECTID v
< #231 ':'
< #231 TYPEID Vertice
< #231 ','
< #231 OBJECTID rest
< #231 ':'
< #231 TYPEID VList
< #231 ')'
< #231 ':'
< #231 TYPEID VList
< #231 '{'
< #232 '{'
< #233 OBJECTID car
< #233 ASSIGN
< #233 OBJECTID v
< #233 ';'
< #234 OBJECTID cdr
< #234 ASSIGN
< #234 OBJECTID rest
< #234 ';'
< #235 OBJECTID self
< #235 ';'
< #236 '}'
< #237 '}'
< #237 ';'
< #239 OBJECTID print
< #239 '('
< #239 ')'
< #239 ':'
< #239 TYPEID Object
< #239 '{'
< #240 '{'
< #241 OBJECTID car
< #241 '.'
< #241 OBJECTID print
< #241 '('
< #241 ')'
< #241 ';'
< #242 OBJECTID cdr
< #242 '.'
< #242 OBJECTID print
< #242 '('
< #242 ')'
< #242 ';'
< #243 '}'
< #244 '}'
< #244 ';'
< #246 '}'
< #246 ';'
< #249 CLASS
< #249 TYPEID Parse
< #249 INHERITS
< #249 TYPEID IO
< #249 '{'
< #252 OBJECTID boolop
< #252 ':'
< #252 TYPEID BoolOp
< #252 ASSIGN
< #252 NEW
< #252 TYPEID BoolOp
< #252 ';'
< #256 OBJECTID read_input
< #256 '('
< #256 ')'
< #256 ':'
< #256 TYPEID Graph
< #256 '{'
< #258 '('
< #258 LET
< #258 OBJECTID g
< #258 ':'
< #258 TYPEID Graph
< #258 ASSIGN
< #258 NEW
< #258 TYPEID Graph
< #258 IN
< #258 '{'
< #259 '('
< #259 LET
< #259 OBJECTID line
< #259 ':'
< #259 TYPEID String
< #259 ASSIGN
< #259 OBJECTID in_string
< #259 '('
< #259 ')'
< #259 IN
< #260 WHILE
< #260 '('
< #260 OBJECTID boolop
< #260 '.'
< #260 OBJECTID and
< #260 '('
< #260 NOT
< #260 OBJECTID line
< #260 '='
< #260 STR_CONST "\n"
< #260 ','
< #260 NOT
< #260 OBJECTID line
< #260 '='
< #260 STR_CONST ""
< #260 ')'
< #260 ')'
< #260 LOOP
< #260 '{'
< #263 OBJECTID g
< #263 '.'
< #263 OBJECTID add_vertice
< #263 '('
< #263 OBJECTID parse_line
< #263 '('
< #263 OBJECTID line
< #263 ')'
< #263 ')'
< #263 ';'
< #264 OBJECTID line
< #264 ASSIGN
< #264 OBJECTID in_string
< #264 '('
< #264 ')'
< #264 ';'
< #265 '}'
< #265 POOL
< #266 ')'
< #266 ';'
< #267 OBJECTID g
< #267 ';'
< #268 '}'
< #268 ')'
< #269 '}'
< #269 ';'
< #272 OBJECTID parse_line
< #272 '('
< #272 OBJECTID s
< #272 ':'
< #272 TYPEID String
< #272 ')'
< #272 ':'
< #272 TYPEID Vertice
< #272 '{'
< #273 '('
< #273 LET
< #273 OBJECTID v
< #273 ':'
< #273 TYPEID Vertice
< #273 ASSIGN
< #273 '('
< #273 NEW
< #273 TYPEID Vertice
< #273 ')'
< #273 '.'
< #273 OBJECTID init
< #273 '('
< #273 OBJECTID a2i
< #273 '('
< #273 OBJECTID s
< #273 ')'
< #273 ')'
< #273 IN
< #273 '{'
< #274 WHILE
< #274 '('
< #274 NOT
< #274 OBJECTID rest
< #274 '.'
< #274 OBJECTID length
< #274 '('
< #274 ')'
< #274 '='
< #274 INT_CONST 0
< #274 ')'
< #274 LOOP
< #274 '{'
< #277 '('
< #277 LET
< #277 OBJECTID succ
< #277 ':'
< #277 TYPEID Int
< #277 ASSIGN
< #277 OBJECTID a2i
< #277 '('
< #277 OBJECTID rest
< #277 ')'
< #277 IN
< #277 '('
< #277 LET
< #278 OBJECTID weight
< #278 ':'
< #278 TYPEID Int
< #278 ASSIGN
< #278 OBJECTID a2i
< #278 '('
< #278 OBJECTID rest
< #278 ')'
< #279 IN
< #280 OBJECTID v
< #280 '.'
< #280 OBJECTID add_out
< #280 '('
< #280 NEW
< #280 TYPEID Edge
< #280 '.'
< #280 OBJECTID init
< #280 '('
< #280 OBJECTID v
< #280 '.'
< #280 OBJECTID number
< #280 '('
< #280 ')'
< #280 ','
< #281 OBJECTID succ
< #281 ','
< #282 OBJECTID weight
< #282 ')'
< #282 ')'
< #283 ')'
< #283 ')'
< #283 ';'
< #284 '}'
< #284 POOL
< #284 ';'
< #285 OBJECTID v
< #285 ';'
< #286 '}'
< #287 ')'
< #288 '}'
< #288 ';'
< #290 OBJECTID c2i
< #290 '('
< #290 OBJECTID char
< #290 ':'
< #290 TYPEID String
< #290 ')'
< #290 ':'
< #290 TYPEID Int
< #290 '{'
< #291 IF
< #291 OBJECTID char
< #291 '='
< #291 STR_CONST "0"
< #291 THEN
< #291 INT_CONST 0
< #291 ELSE
< #292 IF
< #292 OBJECTID char
< #292 '='
< #292 STR_CONST "1"
< #292 THEN
< #292 INT_CONST 1
< #292 ELSE
< #293 IF
< #293 OBJECTID char
< #293 '='
< #293 STR_CONST "2"
< #293 THEN
< #293 INT_CONST 2
< #293 ELSE
< #294 IF
< #294 OBJECTID char
< #294 '='
< #294 STR_CONST "3"
< #294 THEN
< #294 INT_CONST 3
< #294 ELSE
< #295 IF
< #295 OBJECTID char
< #295 '='
< #295 STR_CONST "4"
< #295 THEN
< #295 INT_CONST 4
< #295 ELSE
< #296 IF
< #296 OBJECTID char
< #296 '='
< #296 STR_CONST "5"
< #296 THEN
< #296 INT_CONST 5
< #296 ELSE
< #297 IF
< #297 OBJECTID char
< #297 '='
< #297 STR_CONST "6"
< #297 THEN
< #297 INT_CONST 6
< #297 ELSE
< #298 IF
< #298 OBJECTID char
< #298 '='
< #298 STR_CONST "7"
< #298 THEN
< #298 INT_CONST 7
< #298 ELSE
< #299 IF
< #299 OBJECTID char
< #299 '='
< #299 STR_CONST "8"
< #299 THEN
< #299 INT_CONST 8
< #299 ELSE
< #300 IF
< #300 OBJECTID char
< #300 '='
< #300 STR_CONST "9"
< #300 THEN
< #300 INT_CONST 9
< #300 ELSE
< #301 '{'
< #301 OBJECTID abort
< #301 '('
< #301 ')'
< #301 ';'
< #301 INT_CONST 0
< #301 ';'
< #301 '}'
< #302 FI
< #302 FI
< #302 FI
< #302 FI
< #302 FI
< #302 FI
< #302 FI
< #302 FI
< #302 FI
< #302 FI
< #303 '}'
< #303 ';'
< #305 OBJECTID rest
< #305 ':'
< #305 TYPEID String
< #305 ';'
< #307 OBJECTID a2i
< #307 '('
< #307 OBJECTID s
< #307 ':'
< #307 TYPEID String
< #307 ')'
< #307 ':'
< #307 TYPEID Int
< #307 '{'
< #308 IF
< #308 OBJECTID s
< #308 '.'
< #308 OBJECTID length
< #308 '('
< #308 ')'
< #308 '='
< #308 INT_CONST 0
< #308 THEN
< #308 INT_CONST 0
< #308 ELSE
< #309 IF
< #309 OBJECTID s
< #309 '.'
< #309 OBJECTID substr
< #309 '('
< #309 INT_CONST 0
< #309 ','
< #309 INT_CONST 1
< #309 ')'
< #309 '='
< #309 STR_CONST "-"
< #309 THEN
< #309 '~'
< #309 OBJECTID a2i_aux
< #309 '('
< #309 OBJECTID s
< #309 '.'
< #309 OBJECTID substr
< #309 '('
< #309 INT_CONST 1
< #309 ','
< #309 OBJECTID s
< #309 '.'
< #309 OBJECTID length
< #309 '('
< #309 ')'
< #309 '-'
< #309 INT_CONST 1
< #309 ')'
< #309 ')'
< #309 ELSE
< #310 IF
< #310 OBJECTID s
< #310 '.'
< #310 OBJECTID substr
< #310 '('
< #310 INT_CONST 0
< #310 ','
< #310 INT_CONST 1
< #310 ')'
< #310 '='
< #310 STR_CONST " "
< #310 THEN
< #310 OBJECTID a2i
< #310 '('
< #310 OBJECTID s
< #310 '.'
< #310 OBJECTID substr
< #310 '('
< #310 INT_CONST 1
< #310 ','
< #310 OBJECTID s
< #310 '.'
< #310 OBJECTID length
< #310 '('
< #310 ')'
< #310 '-'
< #310 INT_CONST 1
< #310 ')'
< #310 ')'
< #310 ELSE
< #311 OBJECTID a2i_aux
< #311 '('
< #311 OBJECTID s
< #311 ')'
< #312 FI
< #312 FI
< #312 FI
< #313 '}'
< #313 ';'
< #321 OBJECTID a2i_aux
< #321 '('
< #321 OBJECTID s
< #321 ':'
< #321 TYPEID String
< #321 ')'
< #321 ':'
< #321 TYPEID Int
< #321 '{'
< #322 '('
< #322 LET
< #322 OBJECTID int
< #322 ':'
< #322 TYPEID Int
< #322 ASSIGN
< #322 INT_CONST 0
< #322 IN
< #323 '{'
< #324 '('
< #324 LET
< #324 OBJECTID j
< #324 ':'
< #324 TYPEID Int
< #324 ASSIGN
< #324 OBJECTID s
< #324 '.'
< #324 OBJECTID length
< #324 '('
< #324 ')'
< #324 IN
< #325 '('
< #325 LET
< #325 OBJECTID i
< #325 ':'
< #325 TYPEID Int
< #325 ASSIGN
< #325 INT_CONST 0
< #325 IN
< #326 WHILE
< #326 OBJECTID i
< #326 '<'
< #326 OBJECTID j
< #326 LOOP
< #327 '('
< #327 LET
< #327 OBJECTID c
< #327 ':'
< #327 TYPEID String
< #327 ASSIGN
< #327 OBJECTID s
< #327 '.'
< #327 OBJECTID substr
< #327 '('
< #327 OBJECTID i
< #327 ','
< #327 INT_CONST 1
< #327 ')'
< #327 IN
< #328 IF
< #328 '('
< #328 OBJECTID c
< #328 '='
< #328 STR_CONST " "
< #328 ')'
< #328 THEN
< #329 '{'
< #330 OBJECTID rest
< #330 ASSIGN
< #330 OBJECTID s
< #330 '.'
< #330 OBJECTID substr
< #330 '('
< #330 OBJECTID i
< #330 '+'
< #330 INT_CONST 1
< #330 ','
< #330 OBJECTID s
< #330 '.'
< #330 OBJECTID length
< #330 '('
< #330 ')'
< #330 '-'
< #330 OBJECTID i
< #330 '-'
< #330 INT_CONST 1
< #330 ')'
< #330 ';'
< #331 OBJECTID i
< #331 ASSIGN
< #331 OBJECTID j
< #331 ';'
< #332 '}'
< #333 ELSE
< #333 IF
< #333 '('
< #333 OBJECTID c
< #333 '='
< #333 STR_CONST ","
< #333 ')'
< #333 THEN
< #334 '{'
< #335 OBJECTID rest
< #335 ASSIGN
< #335 OBJECTID s
< #335 '.'
< #335 OBJECTID substr
< #335 '('
< #335 OBJECTID i
< #335 '+'
< #335 INT_CONST 1
< #335 ','
< #335 OBJECTID s
< #335 '.'
< #335 OBJECTID length
< #335 '('
< #335 ')'
< #335 '-'
< #335 OBJECTID i
< #335 '-'
< #335 INT_CONST 1
< #335 ')'
< #335 ';'
< #336 OBJECTID i
< #336 ASSIGN
< #336 OBJECTID j
< #336 ';'
< #337 '}'
< #338 ELSE
< #339 '{'
< #340 OBJECTID int
< #340 ASSIGN
< #340 OBJECTID int
< #340 '*'
< #340 INT_CONST 10
< #340 '+'
< #340 OBJECTID c2i
< #340 '('
< #340 OBJECTID s
< #340 '.'
< #340 OBJECTID substr
< #340 '('
< #340 OBJECTID i
< #340 ','
< #340 INT_CONST 1
< #340 ')'
< #340 ')'
< #340 ';'
< #341 OBJECTID i
< #341 ASSIGN
< #341 OBJECTID i
< #341 '+'
< #341 INT_CONST 1
< #341 ';'
< #342 IF
< #342 OBJECTID i
< #342 '='
< #342 OBJECTID j
< #342 THEN
< #342 OBJECTID rest
< #342 ASSIGN
< #342 STR_CONST ""
< #342 ELSE
< #342 STR_CONST ""
< #342 FI
< #342 ';'
< #343 '}'
< #344 FI
< #344 FI
< #345 ')'
< #346 POOL
< #347 ')'
< #348 ')'
< #348 ';'
< #349 OBJECTID int
< #349 ';'
< #350 '}'
< #351 ')'
< #352 '}'
< #352 ';'
< #354 '}'
< #354 ';'
< #357 CLASS
< #357 TYPEID Main
< #357 INHERITS
< #357 TYPEID Parse
< #357 '{'
< #359 OBJECTID g
< #359 ':'
< #359 TYPEID Graph
< #359 ASSIGN
< #359 OBJECTID read_input
< #359 '('
< #359 ')'
< #359 ';'
< #361 OBJECTID main
< #361 '('
< #361 ')'
< #361 ':'
< #361 TYPEID Object
< #361 '{'
< #362 '{'
< #363 OBJECTID g
< #363 '.'
< #363 OBJECTID print_V
< #363 '('
< #363 ')'
< #363 ';'
< #364 OBJECTID g
< #364 '.'
< #364 OBJECTID print_E
< #364 '('
< #364 ')'
< #364 ';'
< #365 '}'
< #366 '}'
< #366 ';'
< #368 '}'
< #368 ';'
< #370 CLASS
< #370 TYPEID BoolOp
< #370 '{'
< #372 OBJECTID and
< #372 '('
< #372 OBJECTID b1
< #372 ':'
< #372 TYPEID Bool
< #372 ','
< #372 OBJECTID b2
< #372 ':'
< #372 TYPEID Bool
< #372 ')'
< #372 ':'
< #372 TYPEID Bool
< #372 '{'
< #373 IF
< #373 OBJECTID b1
< #373 THEN
< #373 OBJECTID b2
< #373 ELSE
< #373 BOOL_CONST false
< #373 FI
< #374 '}'
< #374 ';'
< #377 OBJECTID or
< #377 '('
< #377 OBJECTID b1
< #377 ':'
< #377 TYPEID Bool
< #377 ','
< #377 OBJECTID b2
< #377 ':'
< #377 TYPEID Bool
< #377 ')'
< #377 ':'
< #377 TYPEID Bool
< #377 '{'
< #378 IF
< #378 OBJECTID b1
< #378 THEN
< #378 BOOL_CONST true
< #378 ELSE
< #378 OBJECTID b2
< #378 FI
< #379 '}'
< #379 ';'
< #381 '}'
< #381 ';'
---
> (*
>  *   Cool program reading descriptions of weighted directed graphs
>  *   from stdin. It builds up a graph objects with a list of vertices
>  *   and a list of edges. Every vertice has a list of outgoing edges.
>  *
>  *  INPUT FORMAT
>  *      Every line has the form		vertice successor*
>  *      Where vertice is an int, and successor is   vertice,weight
>  *
>  *      An empty line or EOF terminates the input.
>  *
>  *   The list of vertices and the edge list is printed out by the Main
>  *   class. 
>  *
>  *  TEST
>  *     Once compiled, the file g1.graph can be fed to the program.
>  *     The output should look like this:
> 
> nautilus.CS.Berkeley.EDU 53# spim -file graph.s <g1.graph 
> SPIM Version 5.4 of Jan. 17, 1994
> Copyright 1990-1994 by James R. Larus (larus@cs.wisc.edu).
> All Rights Reserved.
> See the file README a full copyright notice.
> Loaded: /home/n/cs164/lib/trap.handler
> 5 (5,5)5 (5,4)4 (5,3)3 (5,2)2 (5,1)1
> 4 (4,5)100 (4,3)55
> 3 (3,2)10
> 2 (2,1)150 (2,3)200
> 1 (1,2)100
> 
>  (5,5)5 (5,4)4 (5,3)3 (5,2)2 (5,1)1 (4,5)100 (4,3)55 (3,2)10 (2,1)150 (2,3)200 (1,2)100
> COOL program successfully executed
> 
>  *)
> 
> 
> 
> class Graph {
> 
>    vertices : VList <- new VList;
>    edges    : EList <- new EList;
> 
>    add_vertice(v : Vertice) : Object { {
>       edges <- v.outgoing().append(edges);
>       vertices <- vertices.cons(v);
>    } };
> 
>    print_E() : Object { edges.print() };
>    print_V() : Object { vertices.print() };
> 
> };
> 
> class Vertice inherits IO { 
> 
>    num  : Int;
>    out  : EList <- new EList;
> 
>    outgoing() : EList { out };
> 
>    number() : Int { num };
> 
>    init(n : Int) : SELF_TYPE {
>       {
>          num <- n;
>          self;
>       }
>    };
> 
> 
>    add_out(s : Edge) : SELF_TYPE {
>       {
> 	 out <- out.cons(s);
>          self;
>       }
>    };
> 
>    print() : Object {
>       {
>          out_int(num);
> 	 out.print();
>       }
>    };
> 
> };
> 
> class Edge inherits IO {
> 
>    from   : Int;
>    to     : Int;
>    weight : Int;
> 
>    init(f : Int, t : Int, w : Int) : SELF_TYPE {
>       {
>          from <- f;
> 	 to <- t;
> 	 weight <- w;
> 	 self;
>       }
>    };
> 
>    print() : Object {
>       {
>          out_string(" (");
> 	 out_int(from);
> 	 out_string(",");
> 	 out_int(to);
> 	 out_string(")");
> 	 out_int(weight);
>       }
>    };
> 
> };
> 
> 
> 
> class EList inherits IO {
>    -- Define operations on empty lists of Edges.
> 
>    car : Edge;
> 
>    isNil() : Bool { true };
> 
>    head()  : Edge { { abort(); car; } };
> 
>    tail()  : EList { { abort(); self; } };
> 
>    -- When we cons and element onto the empty list we get a non-empty
>    -- list. The (new Cons) expression creates a new list cell of class
>    -- Cons, which is initialized by a dispatch to init().
>    -- The result of init() is an element of class Cons, but it
>    -- conforms to the return type List, because Cons is a subclass of
>    -- List.
> 
>    cons(e : Edge) : EList {
>       (new ECons).init(e, self)
>    };
> 
>    append(l : EList) : EList {
>      if self.isNil() then l
>      else tail().append(l).cons(head())
>      fi
>    };
> 
>    print() : Object {
>      out_string("\n")
>    };
> 
> };
> 
> 
> (*
>  *  Cons inherits all operations from List. We can reuse only the cons
>  *  method though, because adding an element to the front of an emtpy
>  *  list is the same as adding it to the front of a non empty
>  *  list. All other methods have to be redefined, since the behaviour
>  *  for them is different from the empty list.
>  *
>  *  Cons needs an extra attribute to hold the rest of the list.
>  *
>  *  The init() method is used by the cons() method to initialize the
>  *  cell.
>  *)
> 
> class ECons inherits EList {
> 
>    cdr : EList;	-- The rest of the list
> 
>    isNil() : Bool { false };
> 
>    head()  : Edge { car };
> 
>    tail()  : EList { cdr };
> 
>    init(e : Edge, rest : EList) : EList {
>       {
> 	 car <- e;
> 	 cdr <- rest;
> 	 self;
>       }
>    };
> 
>    print() : Object {
>      {
>        car.print();
>        cdr.print();
>      } 
>    };
> 
> };
> 
> 
> 
> 
> class VList inherits IO {
>    -- Define operations on empty lists of vertices.
> 
>    car : Vertice;
> 
>    isNil() : Bool { true };
> 
>    head()  : Vertice { { abort(); car; } };
> 
>    tail()  : VList { { abort(); self; } };
> 
>    -- When we cons and element onto the empty list we get a non-empty
>    -- list. The (new Cons) expression creates a new list cell of class
>    -- ECons, which is initialized by a dispatch to init().
>    -- The result of init() is an element of class Cons, but it
>    -- conforms to the return type List, because Cons is a subclass of
>    -- List.
> 
>    cons(v : Vertice) : VList {
>       (new VCons).init(v, self)
>    };
> 
>    print() : Object { out_string("\n") };
> 
> };
> 
> 
> class VCons inherits VList {
> 
>    cdr : VList;	-- The rest of the list
> 
>    isNil() : Bool { false };
> 
>    head()  : Vertice { car };
> 
>    tail()  : VList { cdr };
> 
>    init(v : Vertice, rest : VList) : VList {
>       {
> 	 car <- v;
> 	 cdr <- rest;
> 	 self;
>       }
>    };
> 
>    print() : Object {
>      {
>        car.print();
>        cdr.print();
>      } 
>    };
> 
> };
> 
> 
> class Parse inherits IO {
> 
> 
>    boolop : BoolOp <- new BoolOp;
> 
>    -- Reads the input and parses the fields
> 
>    read_input() : Graph {
> 
>       (let g : Graph <- new Graph in {
>          (let line : String <- in_string() in
>             while (boolop.and(not line="\n", not line="")) loop {
> 		-- out_string(line);
> 		-- out_string("\n");
> 		g.add_vertice(parse_line(line));
> 		line <- in_string();
> 	    } pool
>          );
> 	 g;
>       } )
>    };
> 
> 
>    parse_line(s : String) : Vertice {
>       (let v : Vertice <- (new Vertice).init(a2i(s)) in {
> 	 while (not rest.length() = 0) loop {
> 	       -- out_string(rest);
> 	       -- out_string("\n");
> 	       (let succ : Int <- a2i(rest) in (let
> 	           weight : Int <- a2i(rest)
>                in
> 	          v.add_out(new Edge.init(v.number(), 
>                                           succ,
> 					  weight))
> 	       ) );
> 	 } pool;
> 	 v;
>          }
>       )
>    };
> 
>      c2i(char : String) : Int {
> 	if char = "0" then 0 else
> 	if char = "1" then 1 else
> 	if char = "2" then 2 else
>         if char = "3" then 3 else
>         if char = "4" then 4 else
>         if char = "5" then 5 else
>         if char = "6" then 6 else
>         if char = "7" then 7 else
>         if char = "8" then 8 else
>         if char = "9" then 9 else
>         { abort(); 0; }  -- the 0 is needed to satisfy the typchecker
>         fi fi fi fi fi fi fi fi fi fi
>      };
> 
>      rest : String;
> 
>      a2i(s : String) : Int {
>         if s.length() = 0 then 0 else
> 	if s.substr(0,1) = "-" then ~a2i_aux(s.substr(1,s.length()-1)) else
>         if s.substr(0,1) = " " then a2i(s.substr(1,s.length()-1)) else
>            a2i_aux(s)
>         fi fi fi
>      };
> 
> (*
>   a2i_aux converts the usigned portion of the string.  As a programming
> example, this method is written iteratively.
>   The conversion stops at a space or comma.
>   As a side effect, r is set to the remaining string (without the comma).
> *)
>      a2i_aux(s : String) : Int {
> 	(let int : Int <- 0 in	
>            {	
>                (let j : Int <- s.length() in
> 	          (let i : Int <- 0 in
> 		    while i < j loop
> 			(let c : String <- s.substr(i,1) in
> 			    if (c = " ") then
> 			       {
> 				  rest <- s.substr(i+1,s.length()-i-1);
> 				  i <- j;
> 			       }
> 			    else if (c = ",") then
> 		               {
> 				  rest <- s.substr(i+1, s.length()-i-1);
> 				  i <- j;
> 		               }
> 			    else
> 			       {
> 				 int <- int * 10 + c2i(s.substr(i,1));
> 				 i <- i + 1;
> 				 if i=j then rest <- "" else "" fi;
> 			       }
> 			    fi fi
> 			)
> 		    pool
> 		  )
> 	       );
>               int;
> 	    }
>         )
>      };
> 
> };
> 
> 
> class Main inherits Parse {
> 
>    g : Graph <- read_input();
> 
>    main() : Object {
>       {
> 	 g.print_V();
>          g.print_E();
>       }
>    };
> 
> };
> 
> class BoolOp {
> 
>   and(b1 : Bool, b2 : Bool) : Bool {
>      if b1 then b2 else false fi
>   };
> 
> 
>   or(b1 : Bool, b2 : Bool) : Bool {
>      if b1 then true else b2 fi
>   };
> 
> };
pass!
---------  Test  ../../examples/hairyscary.cl  ---------
2,327c2,77
< #3 CLASS
< #3 TYPEID Foo
< #3 INHERITS
< #3 TYPEID Bazz
< #3 '{'
< #4 OBJECTID a
< #4 ':'
< #4 TYPEID Razz
< #4 ASSIGN
< #4 CASE
< #4 OBJECTID self
< #4 OF
< #5 OBJECTID n
< #5 ':'
< #5 TYPEID Razz
< #5 DARROW
< #5 '('
< #5 NEW
< #5 TYPEID Bar
< #5 ')'
< #5 ';'
< #6 OBJECTID n
< #6 ':'
< #6 TYPEID Foo
< #6 DARROW
< #6 '('
< #6 NEW
< #6 TYPEID Razz
< #6 ')'
< #6 ';'
< #7 OBJECTID n
< #7 ':'
< #7 TYPEID Bar
< #7 DARROW
< #7 OBJECTID n
< #7 ';'
< #8 ESAC
< #8 ';'
< #10 OBJECTID b
< #10 ':'
< #10 TYPEID Int
< #10 ASSIGN
< #10 OBJECTID a
< #10 '.'
< #10 OBJECTID doh
< #10 '('
< #10 ')'
< #10 '+'
< #10 OBJECTID g
< #10 '.'
< #10 OBJECTID doh
< #10 '('
< #10 ')'
< #10 '+'
< #10 OBJECTID doh
< #10 '('
< #10 ')'
< #10 '+'
< #10 OBJECTID printh
< #10 '('
< #10 ')'
< #10 ';'
< #12 OBJECTID doh
< #12 '('
< #12 ')'
< #12 ':'
< #12 TYPEID Int
< #12 '{'
< #12 '('
< #12 LET
< #12 OBJECTID i
< #12 ':'
< #12 TYPEID Int
< #12 ASSIGN
< #12 OBJECTID h
< #12 IN
< #12 '{'
< #12 OBJECTID h
< #12 ASSIGN
< #12 OBJECTID h
< #12 '+'
< #12 INT_CONST 2
< #12 ';'
< #12 OBJECTID i
< #12 ';'
< #12 '}'
< #12 ')'
< #12 '}'
< #12 ';'
< #14 '}'
< #14 ';'
< #16 CLASS
< #16 TYPEID Bar
< #16 INHERITS
< #16 TYPEID Razz
< #16 '{'
< #18 OBJECTID c
< #18 ':'
< #18 TYPEID Int
< #18 ASSIGN
< #18 OBJECTID doh
< #18 '('
< #18 ')'
< #18 ';'
< #20 OBJECTID d
< #20 ':'
< #20 TYPEID Object
< #20 ASSIGN
< #20 OBJECTID printh
< #20 '('
< #20 ')'
< #20 ';'
< #21 '}'
< #21 ';'
< #24 CLASS
< #24 TYPEID Razz
< #24 INHERITS
< #24 TYPEID Foo
< #24 '{'
< #26 OBJECTID e
< #26 ':'
< #26 TYPEID Bar
< #26 ASSIGN
< #26 CASE
< #26 OBJECTID self
< #26 OF
< #27 OBJECTID n
< #27 ':'
< #27 TYPEID Razz
< #27 DARROW
< #27 '('
< #27 NEW
< #27 TYPEID Bar
< #27 ')'
< #27 ';'
< #28 OBJECTID n
< #28 ':'
< #28 TYPEID Bar
< #28 DARROW
< #28 OBJECTID n
< #28 ';'
< #29 ESAC
< #29 ';'
< #31 OBJECTID f
< #31 ':'
< #31 TYPEID Int
< #31 ASSIGN
< #31 OBJECTID a
< #31 '@'
< #31 TYPEID Bazz
< #31 '.'
< #31 OBJECTID doh
< #31 '('
< #31 ')'
< #31 '+'
< #31 OBJECTID g
< #31 '.'
< #31 OBJECTID doh
< #31 '('
< #31 ')'
< #31 '+'
< #31 OBJECTID e
< #31 '.'
< #31 OBJECTID doh
< #31 '('
< #31 ')'
< #31 '+'
< #31 OBJECTID doh
< #31 '('
< #31 ')'
< #31 '+'
< #31 OBJECTID printh
< #31 '('
< #31 ')'
< #31 ';'
< #33 '}'
< #33 ';'
< #35 CLASS
< #35 TYPEID Bazz
< #35 INHERITS
< #35 TYPEID IO
< #35 '{'
< #37 OBJECTID h
< #37 ':'
< #37 TYPEID Int
< #37 ASSIGN
< #37 INT_CONST 1
< #37 ';'
< #39 OBJECTID g
< #39 ':'
< #39 TYPEID Foo
< #39 ASSIGN
< #39 CASE
< #39 OBJECTID self
< #39 OF
< #40 OBJECTID n
< #40 ':'
< #40 TYPEID Bazz
< #40 DARROW
< #40 '('
< #40 NEW
< #40 TYPEID Foo
< #40 ')'
< #40 ';'
< #41 OBJECTID n
< #41 ':'
< #41 TYPEID Razz
< #41 DARROW
< #41 '('
< #41 NEW
< #41 TYPEID Bar
< #41 ')'
< #41 ';'
< #42 OBJECTID n
< #42 ':'
< #42 TYPEID Foo
< #42 DARROW
< #42 '('
< #42 NEW
< #42 TYPEID Razz
< #42 ')'
< #42 ';'
< #43 OBJECTID n
< #43 ':'
< #43 TYPEID Bar
< #43 DARROW
< #43 OBJECTID n
< #43 ';'
< #44 ESAC
< #44 ';'
< #46 OBJECTID i
< #46 ':'
< #46 TYPEID Object
< #46 ASSIGN
< #46 OBJECTID printh
< #46 '('
< #46 ')'
< #46 ';'
< #48 OBJECTID printh
< #48 '('
< #48 ')'
< #48 ':'
< #48 TYPEID Int
< #48 '{'
< #48 '{'
< #48 OBJECTID out_int
< #48 '('
< #48 OBJECTID h
< #48 ')'
< #48 ';'
< #48 INT_CONST 0
< #48 ';'
< #48 '}'
< #48 '}'
< #48 ';'
< #50 OBJECTID doh
< #50 '('
< #50 ')'
< #50 ':'
< #50 TYPEID Int
< #50 '{'
< #50 '('
< #50 LET
< #50 OBJECTID i
< #50 ':'
< #50 TYPEID Int
< #50 ASSIGN
< #50 OBJECTID h
< #50 IN
< #50 '{'
< #50 OBJECTID h
< #50 ASSIGN
< #50 OBJECTID h
< #50 '+'
< #50 INT_CONST 1
< #50 ';'
< #50 OBJECTID i
< #50 ';'
< #50 '}'
< #50 ')'
< #50 '}'
< #50 ';'
< #51 '}'
< #51 ';'
< #54 CLASS
< #54 TYPEID Main
< #54 '{'
< #55 OBJECTID a
< #55 ':'
< #55 TYPEID Bazz
< #55 ASSIGN
< #55 NEW
< #55 TYPEID Bazz
< #55 ';'
< #56 OBJECTID b
< #56 ':'
< #56 TYPEID Foo
< #56 ASSIGN
< #56 NEW
< #56 TYPEID Foo
< #56 ';'
< #57 OBJECTID c
< #57 ':'
< #57 TYPEID Razz
< #57 ASSIGN
< #57 NEW
< #57 TYPEID Razz
< #57 ';'
< #58 OBJECTID d
< #58 ':'
< #58 TYPEID Bar
< #58 ASSIGN
< #58 NEW
< #58 TYPEID Bar
< #58 ';'
< #60 OBJECTID main
< #60 '('
< #60 ')'
< #60 ':'
< #60 TYPEID String
< #60 '{'
< #60 STR_CONST "do nothing"
< #60 '}'
< #60 ';'
< #62 '}'
< #62 ';'
---
> (* hairy  . . .*)
> 
> class Foo inherits Bazz {
>      a : Razz <- case self of
> 		      n : Razz #1 DARROW
>  (new Bar);
> 		      n : Foo #1 DARROW
>  (new Razz);
> 		      n : Bar #1 DARROW
>  n;
>    	         esac;
> 
>      b : Int <- a.doh() + g.doh() + doh() + printh();
> 
>      doh() : Int { (let i : Int <- h in { h <- h + 2; i; } ) };
> 
> };
> 
> class Bar inherits Razz {
> 
>      c : Int <- doh();
> 
>      d : Object <- printh();
> };
> 
> 
> class Razz inherits Foo {
> 
>      e : Bar <- case self of
> 		  n : Razz #1 DARROW
>  (new Bar);
> 		  n : Bar #1 DARROW
>  n;
> 		esac;
> 
>      f : Int <- a@Bazz.doh() + g.doh() + e.doh() + doh() + printh();
> 
> };
> 
> class Bazz inherits IO {
> 
>      h : Int <- 1;
> 
>      g : Foo  <- case self of
> 		     	n : Bazz #1 DARROW
>  (new Foo);
> 		     	n : Razz #1 DARROW
>  (new Bar);
> 			n : Foo  #1 DARROW
>  (new Razz);
> 			n : Bar #1 DARROW
>  n;
> 		  esac;
> 
>      i : Object <- printh();
> 
>      printh() : Int { { out_int(h); 0; } };
> 
>      doh() : Int { (let i: Int <- h in { h <- h + 1; i; } ) };
> };
> 
> (* scary . . . *)
> class Main {
>   a : Bazz <- new Bazz;
>   b : Foo <- new Foo;
>   c : Razz <- new Razz;
>   d : Bar <- new Bar;
> 
>   main(): String { "do nothing" };
> 
> };
> 
> 
> 
> 
> 
pass!
---------  Test  ../../examples/hello_world.cl  ---------
2,20c2,6
< #1 CLASS
< #1 TYPEID Main
< #1 INHERITS
< #1 TYPEID IO
< #1 '{'
< #2 OBJECTID main
< #2 '('
< #2 ')'
< #2 ':'
< #2 TYPEID SELF_TYPE
< #2 '{'
< #3 OBJECTID out_string
< #3 '('
< #3 STR_CONST "Hello, World.\n"
< #3 ')'
< #4 '}'
< #4 ';'
< #5 '}'
< #5 ';'
---
> class Main inherits IO {
>    main(): SELF_TYPE {
> 	out_string("Hello, World.\n")
>    };
> };
pass!
---------  Test  ../../examples/io.cl  ---------
2,144c2,104
< #49 CLASS
< #49 TYPEID A
< #49 '{'
< #53 OBJECTID io
< #53 ':'
< #53 TYPEID IO
< #53 ASSIGN
< #53 NEW
< #53 TYPEID IO
< #53 ';'
< #55 OBJECTID out_a
< #55 '('
< #55 ')'
< #55 ':'
< #55 TYPEID Object
< #55 '{'
< #55 OBJECTID io
< #55 '.'
< #55 OBJECTID out_string
< #55 '('
< #55 STR_CONST "A: Hello world\n"
< #55 ')'
< #55 '}'
< #55 ';'
< #57 '}'
< #57 ';'
< #60 CLASS
< #60 TYPEID B
< #60 INHERITS
< #60 TYPEID A
< #60 '{'
< #64 OBJECTID out_b
< #64 '('
< #64 ')'
< #64 ':'
< #64 TYPEID Object
< #64 '{'
< #64 OBJECTID io
< #64 '.'
< #64 OBJECTID out_string
< #64 '('
< #64 STR_CONST "B: Hello world\n"
< #64 ')'
< #64 '}'
< #64 ';'
< #66 '}'
< #66 ';'
< #69 CLASS
< #69 TYPEID C
< #69 INHERITS
< #69 TYPEID IO
< #69 '{'
< #73 OBJECTID out_c
< #73 '('
< #73 ')'
< #73 ':'
< #73 TYPEID Object
< #73 '{'
< #73 OBJECTID out_string
< #73 '('
< #73 STR_CONST "C: Hello world\n"
< #73 ')'
< #73 '}'
< #73 ';'
< #77 '}'
< #77 ';'
< #80 CLASS
< #80 TYPEID D
< #80 INHERITS
< #80 TYPEID C
< #80 '{'
< #84 OBJECTID out_d
< #84 '('
< #84 ')'
< #84 ':'
< #84 TYPEID Object
< #84 '{'
< #84 OBJECTID out_string
< #84 '('
< #84 STR_CONST "D: Hello world\n"
< #84 ')'
< #84 '}'
< #84 ';'
< #86 '}'
< #86 ';'
< #89 CLASS
< #89 TYPEID Main
< #89 INHERITS
< #89 TYPEID IO
< #89 '{'
< #93 OBJECTID main
< #93 '('
< #93 ')'
< #93 ':'
< #93 TYPEID Object
< #93 '{'
< #94 '{'
< #95 '('
< #95 NEW
< #95 TYPEID A
< #95 ')'
< #95 '.'
< #95 OBJECTID out_a
< #95 '('
< #95 ')'
< #95 ';'
< #96 '('
< #96 NEW
< #96 TYPEID B
< #96 ')'
< #96 '.'
< #96 OBJECTID out_b
< #96 '('
< #96 ')'
< #96 ';'
< #97 '('
< #97 NEW
< #97 TYPEID C
< #97 ')'
< #97 '.'
< #97 OBJECTID out_c
< #97 '('
< #97 ')'
< #97 ';'
< #98 '('
< #98 NEW
< #98 TYPEID D
< #98 ')'
< #98 '.'
< #98 OBJECTID out_d
< #98 '('
< #98 ')'
< #98 ';'
< #99 OBJECTID out_string
< #99 '('
< #99 STR_CONST "Done.\n"
< #99 ')'
< #99 ';'
< #100 '}'
< #101 '}'
< #101 ';'
< #103 '}'
< #103 ';'
---
> (*
>  *  The IO class is predefined and has 4 methods:
>  *
>  *    out_string(s : String) : SELF_TYPE
>  *    out_int(i : Int) : SELF_TYPE
>  *    in_string() : String
>  *    in_int() : Int
>  *
>  *    The out operations print their argument to the terminal. The
>  *    in_string method reads an entire line from the terminal and returns a
>  *    string not containing the new line. The in_int method also reads
>  *    an entire line from the terminal and returns the integer
>  *    corresponding to the first non blank word on the line. If that
>  *    word is not an integer, it returns 0.
>  *
>  *
>  *  Because our language is object oriented, we need an object of type
>  *  IO in order to call any of these methods.
>  *
>  *  There are basically two ways of getting access to IO in a class C.
>  *
>  *   1) Define C to Inherit from IO. This way the IO methods become
>  *      methods of C, and they can be called using the abbreviated
>  *      dispatch, i.e.
>  *
>  *      class C inherits IO is
>  *          ...
>  *          out_string("Hello world\n")
>  *          ...
>  *      end;
>  *
>  *   2) If your class C does not directly or indirectly inherit from
>  *      IO, the best way to access IO is through an initialized
>  *      attribute of type IO. 
>  *
>  *      class C inherits Foo is
>  *         io : IO <- new IO;
>  *         ...
>  *             io.out_string("Hello world\n");
>  *         ...
>  *      end;
>  *
>  *  Approach 1) is most often used, in particular when you need IO
>  *  functions in the Main class.
>  *
>  *)
> 
> 
> class A {
> 
>    -- Let's assume that we don't want A to not inherit from IO.
> 
>    io : IO <- new IO;
> 
>    out_a() : Object { io.out_string("A: Hello world\n") };
> 
> };
> 
> 
> class B inherits A {
> 
>    -- B does not have to an extra attribute, since it inherits io from A.
> 
>    out_b() : Object { io.out_string("B: Hello world\n") };
> 
> };
> 
> 
> class C inherits IO {
> 
>    -- Now the IO methods are part of C.
> 
>    out_c() : Object { out_string("C: Hello world\n") };
> 
>    -- Note that out_string(...) is just a shorthand for self.out_string(...)
> 
> };
> 
> 
> class D inherits C {
> 
>    -- Inherits IO methods from C.
> 
>    out_d() : Object { out_string("D: Hello world\n") };
> 
> };
> 
> 
> class Main inherits IO {
> 
>    -- Same case as class C.
> 
>    main() : Object {
>       {
> 	 (new A).out_a();
> 	 (new B).out_b();
> 	 (new C).out_c();
> 	 (new D).out_d();
> 	 out_string("Done.\n");
>       }
>    };
> 
> };
pass!
---------  Test  ../../examples/lam.cl  ---------
2,2200c2,483
< #21 CLASS
< #21 TYPEID VarList
< #21 INHERITS
< #21 TYPEID IO
< #21 '{'
< #22 OBJECTID isNil
< #22 '('
< #22 ')'
< #22 ':'
< #22 TYPEID Bool
< #22 '{'
< #22 BOOL_CONST true
< #22 '}'
< #22 ';'
< #23 OBJECTID head
< #23 '('
< #23 ')'
< #23 ':'
< #23 TYPEID Variable
< #23 '{'
< #23 '{'
< #23 OBJECTID abort
< #23 '('
< #23 ')'
< #23 ';'
< #23 NEW
< #23 TYPEID Variable
< #23 ';'
< #23 '}'
< #23 '}'
< #23 ';'
< #24 OBJECTID tail
< #24 '('
< #24 ')'
< #24 ':'
< #24 TYPEID VarList
< #24 '{'
< #24 '{'
< #24 OBJECTID abort
< #24 '('
< #24 ')'
< #24 ';'
< #24 NEW
< #24 TYPEID VarList
< #24 ';'
< #24 '}'
< #24 '}'
< #24 ';'
< #25 OBJECTID add
< #25 '('
< #25 OBJECTID x
< #25 ':'
< #25 TYPEID Variable
< #25 ')'
< #25 ':'
< #25 TYPEID VarList
< #25 '{'
< #25 '('
< #25 NEW
< #25 TYPEID VarListNE
< #25 ')'
< #25 '.'
< #25 OBJECTID init
< #25 '('
< #25 OBJECTID x
< #25 ','
< #25 OBJECTID self
< #25 ')'
< #25 '}'
< #25 ';'
< #26 OBJECTID print
< #26 '('
< #26 ')'
< #26 ':'
< #26 TYPEID SELF_TYPE
< #26 '{'
< #26 OBJECTID out_string
< #26 '('
< #26 STR_CONST "\n"
< #26 ')'
< #26 '}'
< #26 ';'
< #27 '}'
< #27 ';'
< #29 CLASS
< #29 TYPEID VarListNE
< #29 INHERITS
< #29 TYPEID VarList
< #29 '{'
< #30 OBJECTID x
< #30 ':'
< #30 TYPEID Variable
< #30 ';'
< #31 OBJECTID rest
< #31 ':'
< #31 TYPEID VarList
< #31 ';'
< #32 OBJECTID isNil
< #32 '('
< #32 ')'
< #32 ':'
< #32 TYPEID Bool
< #32 '{'
< #32 BOOL_CONST false
< #32 '}'
< #32 ';'
< #33 OBJECTID head
< #33 '('
< #33 ')'
< #33 ':'
< #33 TYPEID Variable
< #33 '{'
< #33 OBJECTID x
< #33 '}'
< #33 ';'
< #34 OBJECTID tail
< #34 '('
< #34 ')'
< #34 ':'
< #34 TYPEID VarList
< #34 '{'
< #34 OBJECTID rest
< #34 '}'
< #34 ';'
< #35 OBJECTID init
< #35 '('
< #35 OBJECTID y
< #35 ':'
< #35 TYPEID Variable
< #35 ','
< #35 OBJECTID r
< #35 ':'
< #35 TYPEID VarList
< #35 ')'
< #35 ':'
< #35 TYPEID VarListNE
< #35 '{'
< #35 '{'
< #35 OBJECTID x
< #35 ASSIGN
< #35 OBJECTID y
< #35 ';'
< #35 OBJECTID rest
< #35 ASSIGN
< #35 OBJECTID r
< #35 ';'
< #35 OBJECTID self
< #35 ';'
< #35 '}'
< #35 '}'
< #35 ';'
< #36 OBJECTID print
< #36 '('
< #36 ')'
< #36 ':'
< #36 TYPEID SELF_TYPE
< #36 '{'
< #36 '{'
< #36 OBJECTID x
< #36 '.'
< #36 OBJECTID print_self
< #36 '('
< #36 ')'
< #36 ';'
< #36 OBJECTID out_string
< #36 '('
< #36 STR_CONST " "
< #36 ')'
< #36 ';'
< #37 OBJECTID rest
< #37 '.'
< #37 OBJECTID print
< #37 '('
< #37 ')'
< #37 ';'
< #37 OBJECTID self
< #37 ';'
< #37 '}'
< #37 '}'
< #37 ';'
< #38 '}'
< #38 ';'
< #44 CLASS
< #44 TYPEID LambdaList
< #44 '{'
< #45 OBJECTID isNil
< #45 '('
< #45 ')'
< #45 ':'
< #45 TYPEID Bool
< #45 '{'
< #45 BOOL_CONST true
< #45 '}'
< #45 ';'
< #46 OBJECTID headE
< #46 '('
< #46 ')'
< #46 ':'
< #46 TYPEID VarList
< #46 '{'
< #46 '{'
< #46 OBJECTID abort
< #46 '('
< #46 ')'
< #46 ';'
< #46 NEW
< #46 TYPEID VarList
< #46 ';'
< #46 '}'
< #46 '}'
< #46 ';'
< #47 OBJECTID headC
< #47 '('
< #47 ')'
< #47 ':'
< #47 TYPEID Lambda
< #47 '{'
< #47 '{'
< #47 OBJECTID abort
< #47 '('
< #47 ')'
< #47 ';'
< #47 NEW
< #47 TYPEID Lambda
< #47 ';'
< #47 '}'
< #47 '}'
< #47 ';'
< #48 OBJECTID headN
< #48 '('
< #48 ')'
< #48 ':'
< #48 TYPEID Int
< #48 '{'
< #48 '{'
< #48 OBJECTID abort
< #48 '('
< #48 ')'
< #48 ';'
< #48 INT_CONST 0
< #48 ';'
< #48 '}'
< #48 '}'
< #48 ';'
< #49 OBJECTID tail
< #49 '('
< #49 ')'
< #49 ':'
< #49 TYPEID LambdaList
< #49 '{'
< #49 '{'
< #49 OBJECTID abort
< #49 '('
< #49 ')'
< #49 ';'
< #49 NEW
< #49 TYPEID LambdaList
< #49 ';'
< #49 '}'
< #49 '}'
< #49 ';'
< #50 OBJECTID add
< #50 '('
< #50 OBJECTID e
< #50 ':'
< #50 TYPEID VarList
< #50 ','
< #50 OBJECTID x
< #50 ':'
< #50 TYPEID Lambda
< #50 ','
< #50 OBJECTID n
< #50 ':'
< #50 TYPEID Int
< #50 ')'
< #50 ':'
< #50 TYPEID LambdaList
< #50 '{'
< #51 '('
< #51 NEW
< #51 TYPEID LambdaListNE
< #51 ')'
< #51 '.'
< #51 OBJECTID init
< #51 '('
< #51 OBJECTID e
< #51 ','
< #51 OBJECTID x
< #51 ','
< #51 OBJECTID n
< #51 ','
< #51 OBJECTID self
< #51 ')'
< #52 '}'
< #52 ';'
< #53 '}'
< #53 ';'
< #55 CLASS
< #55 TYPEID LambdaListNE
< #55 INHERITS
< #55 TYPEID LambdaList
< #55 '{'
< #56 OBJECTID lam
< #56 ':'
< #56 TYPEID Lambda
< #56 ';'
< #57 OBJECTID num
< #57 ':'
< #57 TYPEID Int
< #57 ';'
< #58 OBJECTID env
< #58 ':'
< #58 TYPEID VarList
< #58 ';'
< #59 OBJECTID rest
< #59 ':'
< #59 TYPEID LambdaList
< #59 ';'
< #60 OBJECTID isNil
< #60 '('
< #60 ')'
< #60 ':'
< #60 TYPEID Bool
< #60 '{'
< #60 BOOL_CONST false
< #60 '}'
< #60 ';'
< #61 OBJECTID headE
< #61 '('
< #61 ')'
< #61 ':'
< #61 TYPEID VarList
< #61 '{'
< #61 OBJECTID env
< #61 '}'
< #61 ';'
< #62 OBJECTID headC
< #62 '('
< #62 ')'
< #62 ':'
< #62 TYPEID Lambda
< #62 '{'
< #62 OBJECTID lam
< #62 '}'
< #62 ';'
< #63 OBJECTID headN
< #63 '('
< #63 ')'
< #63 ':'
< #63 TYPEID Int
< #63 '{'
< #63 OBJECTID num
< #63 '}'
< #63 ';'
< #64 OBJECTID tail
< #64 '('
< #64 ')'
< #64 ':'
< #64 TYPEID LambdaList
< #64 '{'
< #64 OBJECTID rest
< #64 '}'
< #64 ';'
< #65 OBJECTID init
< #65 '('
< #65 OBJECTID e
< #65 ':'
< #65 TYPEID VarList
< #65 ','
< #65 OBJECTID l
< #65 ':'
< #65 TYPEID Lambda
< #65 ','
< #65 OBJECTID n
< #65 ':'
< #65 TYPEID Int
< #65 ','
< #65 OBJECTID r
< #65 ':'
< #65 TYPEID LambdaList
< #65 ')'
< #65 ':'
< #65 TYPEID LambdaListNE
< #65 '{'
< #66 '{'
< #67 OBJECTID env
< #67 ASSIGN
< #67 OBJECTID e
< #67 ';'
< #68 OBJECTID lam
< #68 ASSIGN
< #68 OBJECTID l
< #68 ';'
< #69 OBJECTID num
< #69 ASSIGN
< #69 OBJECTID n
< #69 ';'
< #70 OBJECTID rest
< #70 ASSIGN
< #70 OBJECTID r
< #70 ';'
< #71 OBJECTID self
< #71 ';'
< #72 '}'
< #73 '}'
< #73 ';'
< #74 '}'
< #74 ';'
< #76 CLASS
< #76 TYPEID LambdaListRef
< #76 '{'
< #77 OBJECTID nextNum
< #77 ':'
< #77 TYPEID Int
< #77 ASSIGN
< #77 INT_CONST 0
< #77 ';'
< #78 OBJECTID l
< #78 ':'
< #78 TYPEID LambdaList
< #78 ';'
< #79 OBJECTID isNil
< #79 '('
< #79 ')'
< #79 ':'
< #79 TYPEID Bool
< #79 '{'
< #79 OBJECTID l
< #79 '.'
< #79 OBJECTID isNil
< #79 '('
< #79 ')'
< #79 '}'
< #79 ';'
< #80 OBJECTID headE
< #80 '('
< #80 ')'
< #80 ':'
< #80 TYPEID VarList
< #80 '{'
< #80 OBJECTID l
< #80 '.'
< #80 OBJECTID headE
< #80 '('
< #80 ')'
< #80 '}'
< #80 ';'
< #81 OBJECTID headC
< #81 '('
< #81 ')'
< #81 ':'
< #81 TYPEID Lambda
< #81 '{'
< #81 OBJECTID l
< #81 '.'
< #81 OBJECTID headC
< #81 '('
< #81 ')'
< #81 '}'
< #81 ';'
< #82 OBJECTID headN
< #82 '('
< #82 ')'
< #82 ':'
< #82 TYPEID Int
< #82 '{'
< #82 OBJECTID l
< #82 '.'
< #82 OBJECTID headN
< #82 '('
< #82 ')'
< #82 '}'
< #82 ';'
< #83 OBJECTID reset
< #83 '('
< #83 ')'
< #83 ':'
< #83 TYPEID SELF_TYPE
< #83 '{'
< #84 '{'
< #85 OBJECTID nextNum
< #85 ASSIGN
< #85 INT_CONST 0
< #85 ';'
< #86 OBJECTID l
< #86 ASSIGN
< #86 NEW
< #86 TYPEID LambdaList
< #86 ';'
< #87 OBJECTID self
< #87 ';'
< #88 '}'
< #89 '}'
< #89 ';'
< #90 OBJECTID add
< #90 '('
< #90 OBJECTID env
< #90 ':'
< #90 TYPEID VarList
< #90 ','
< #90 OBJECTID c
< #90 ':'
< #90 TYPEID Lambda
< #90 ')'
< #90 ':'
< #90 TYPEID Int
< #90 '{'
< #91 '{'
< #92 OBJECTID l
< #92 ASSIGN
< #92 OBJECTID l
< #92 '.'
< #92 OBJECTID add
< #92 '('
< #92 OBJECTID env
< #92 ','
< #92 OBJECTID c
< #92 ','
< #92 OBJECTID nextNum
< #92 ')'
< #92 ';'
< #93 OBJECTID nextNum
< #93 ASSIGN
< #93 OBJECTID nextNum
< #93 '+'
< #93 INT_CONST 1
< #93 ';'
< #94 OBJECTID nextNum
< #94 '-'
< #94 INT_CONST 1
< #94 ';'
< #95 '}'
< #96 '}'
< #96 ';'
< #97 OBJECTID removeHead
< #97 '('
< #97 ')'
< #97 ':'
< #97 TYPEID SELF_TYPE
< #97 '{'
< #98 '{'
< #99 OBJECTID l
< #99 ASSIGN
< #99 OBJECTID l
< #99 '.'
< #99 OBJECTID tail
< #99 '('
< #99 ')'
< #99 ';'
< #100 OBJECTID self
< #100 ';'
< #101 '}'
< #102 '}'
< #102 ';'
< #103 '}'
< #103 ';'
< #111 CLASS
< #111 TYPEID Expr
< #111 INHERITS
< #111 TYPEID IO
< #111 '{'
< #114 OBJECTID print_self
< #114 '('
< #114 ')'
< #114 ':'
< #114 TYPEID SELF_TYPE
< #114 '{'
< #115 '{'
< #116 OBJECTID out_string
< #116 '('
< #116 STR_CONST "\nError: Expr is pure virtual; can't print self\n"
< #116 ')'
< #116 ';'
< #117 OBJECTID abort
< #117 '('
< #117 ')'
< #117 ';'
< #118 OBJECTID self
< #118 ';'
< #119 '}'
< #120 '}'
< #120 ';'
< #123 OBJECTID beta
< #123 '('
< #123 ')'
< #123 ':'
< #123 TYPEID Expr
< #123 '{'
< #124 '{'
< #125 OBJECTID out_string
< #125 '('
< #125 STR_CONST "\nError: Expr is pure virtual; can't beta-reduce\n"
< #125 ')'
< #125 ';'
< #126 OBJECTID abort
< #126 '('
< #126 ')'
< #126 ';'
< #127 OBJECTID self
< #127 ';'
< #128 '}'
< #129 '}'
< #129 ';'
< #132 OBJECTID substitute
< #132 '('
< #132 OBJECTID x
< #132 ':'
< #132 TYPEID Variable
< #132 ','
< #132 OBJECTID e
< #132 ':'
< #132 TYPEID Expr
< #132 ')'
< #132 ':'
< #132 TYPEID Expr
< #132 '{'
< #133 '{'
< #134 OBJECTID out_string
< #134 '('
< #134 STR_CONST "\nError: Expr is pure virtual; can't substitute\n"
< #134 ')'
< #134 ';'
< #135 OBJECTID abort
< #135 '('
< #135 ')'
< #135 ';'
< #136 OBJECTID self
< #136 ';'
< #137 '}'
< #138 '}'
< #138 ';'
< #141 OBJECTID gen_code
< #141 '('
< #141 OBJECTID env
< #141 ':'
< #141 TYPEID VarList
< #141 ','
< #141 OBJECTID closures
< #141 ':'
< #141 TYPEID LambdaListRef
< #141 ')'
< #141 ':'
< #141 TYPEID SELF_TYPE
< #141 '{'
< #142 '{'
< #143 OBJECTID out_string
< #143 '('
< #143 STR_CONST "\nError: Expr is pure virtual; can't gen_code\n"
< #143 ')'
< #143 ';'
< #144 OBJECTID abort
< #144 '('
< #144 ')'
< #144 ';'
< #145 OBJECTID self
< #145 ';'
< #146 '}'
< #147 '}'
< #147 ';'
< #148 '}'
< #148 ';'
< #153 CLASS
< #153 TYPEID Variable
< #153 INHERITS
< #153 TYPEID Expr
< #153 '{'
< #154 OBJECTID name
< #154 ':'
< #154 TYPEID String
< #154 ';'
< #156 OBJECTID init
< #156 '('
< #156 OBJECTID n
< #156 ':'
< #156 TYPEID String
< #156 ')'
< #156 ':'
< #156 TYPEID Variable
< #156 '{'
< #157 '{'
< #158 OBJECTID name
< #158 ASSIGN
< #158 OBJECTID n
< #158 ';'
< #159 OBJECTID self
< #159 ';'
< #160 '}'
< #161 '}'
< #161 ';'
< #163 OBJECTID print_self
< #163 '('
< #163 ')'
< #163 ':'
< #163 TYPEID SELF_TYPE
< #163 '{'
< #164 OBJECTID out_string
< #164 '('
< #164 OBJECTID name
< #164 ')'
< #165 '}'
< #165 ';'
< #167 OBJECTID beta
< #167 '('
< #167 ')'
< #167 ':'
< #167 TYPEID Expr
< #167 '{'
< #167 OBJECTID self
< #167 '}'
< #167 ';'
< #169 OBJECTID substitute
< #169 '('
< #169 OBJECTID x
< #169 ':'
< #169 TYPEID Variable
< #169 ','
< #169 OBJECTID e
< #169 ':'
< #169 TYPEID Expr
< #169 ')'
< #169 ':'
< #169 TYPEID Expr
< #169 '{'
< #170 IF
< #170 OBJECTID x
< #170 '='
< #170 OBJECTID self
< #170 THEN
< #170 OBJECTID e
< #170 ELSE
< #170 OBJECTID self
< #170 FI
< #171 '}'
< #171 ';'
< #173 OBJECTID gen_code
< #173 '('
< #173 OBJECTID env
< #173 ':'
< #173 TYPEID VarList
< #173 ','
< #173 OBJECTID closures
< #173 ':'
< #173 TYPEID LambdaListRef
< #173 ')'
< #173 ':'
< #173 TYPEID SELF_TYPE
< #173 '{'
< #174 LET
< #174 OBJECTID cur_env
< #174 ':'
< #174 TYPEID VarList
< #174 ASSIGN
< #174 OBJECTID env
< #174 IN
< #175 '{'
< #175 WHILE
< #175 '('
< #175 IF
< #175 OBJECTID cur_env
< #175 '.'
< #175 OBJECTID isNil
< #175 '('
< #175 ')'
< #175 THEN
< #176 BOOL_CONST false
< #177 ELSE
< #178 NOT
< #178 '('
< #178 OBJECTID cur_env
< #178 '.'
< #178 OBJECTID head
< #178 '('
< #178 ')'
< #178 '='
< #178 OBJECTID self
< #178 ')'
< #179 FI
< #179 ')'
< #179 LOOP
< #180 '{'
< #180 OBJECTID out_string
< #180 '('
< #180 STR_CONST "get_parent()."
< #180 ')'
< #180 ';'
< #181 OBJECTID cur_env
< #181 ASSIGN
< #181 OBJECTID cur_env
< #181 '.'
< #181 OBJECTID tail
< #181 '('
< #181 ')'
< #181 ';'
< #182 '}'
< #183 POOL
< #183 ';'
< #184 IF
< #184 OBJECTID cur_env
< #184 '.'
< #184 OBJECTID isNil
< #184 '('
< #184 ')'
< #184 THEN
< #185 '{'
< #185 OBJECTID out_string
< #185 '('
< #185 STR_CONST "Error:  free occurrence of "
< #185 ')'
< #185 ';'
< #186 OBJECTID print_self
< #186 '('
< #186 ')'
< #186 ';'
< #187 OBJECTID out_string
< #187 '('
< #187 STR_CONST "\n"
< #187 ')'
< #187 ';'
< #188 OBJECTID abort
< #188 '('
< #188 ')'
< #188 ';'
< #189 OBJECTID self
< #189 ';'
< #190 '}'
< #191 ELSE
< #192 OBJECTID out_string
< #192 '('
< #192 STR_CONST "get_x()"
< #192 ')'
< #193 FI
< #193 ';'
< #194 '}'
< #195 '}'
< #195 ';'
< #196 '}'
< #196 ';'
< #201 CLASS
< #201 TYPEID Lambda
< #201 INHERITS
< #201 TYPEID Expr
< #201 '{'
< #202 OBJECTID arg
< #202 ':'
< #202 TYPEID Variable
< #202 ';'
< #203 OBJECTID body
< #203 ':'
< #203 TYPEID Expr
< #203 ';'
< #205 OBJECTID init
< #205 '('
< #205 OBJECTID a
< #205 ':'
< #205 TYPEID Variable
< #205 ','
< #205 OBJECTID b
< #205 ':'
< #205 TYPEID Expr
< #205 ')'
< #205 ':'
< #205 TYPEID Lambda
< #205 '{'
< #206 '{'
< #207 OBJECTID arg
< #207 ASSIGN
< #207 OBJECTID a
< #207 ';'
< #208 OBJECTID body
< #208 ASSIGN
< #208 OBJECTID b
< #208 ';'
< #209 OBJECTID self
< #209 ';'
< #210 '}'
< #211 '}'
< #211 ';'
< #213 OBJECTID print_self
< #213 '('
< #213 ')'
< #213 ':'
< #213 TYPEID SELF_TYPE
< #213 '{'
< #214 '{'
< #215 OBJECTID out_string
< #215 '('
< #215 STR_CONST "\\"
< #215 ')'
< #215 ';'
< #216 OBJECTID arg
< #216 '.'
< #216 OBJECTID print_self
< #216 '('
< #216 ')'
< #216 ';'
< #217 OBJECTID out_string
< #217 '('
< #217 STR_CONST "."
< #217 ')'
< #217 ';'
< #218 OBJECTID body
< #218 '.'
< #218 OBJECTID print_self
< #218 '('
< #218 ')'
< #218 ';'
< #219 OBJECTID self
< #219 ';'
< #220 '}'
< #221 '}'
< #221 ';'
< #223 OBJECTID beta
< #223 '('
< #223 ')'
< #223 ':'
< #223 TYPEID Expr
< #223 '{'
< #223 OBJECTID self
< #223 '}'
< #223 ';'
< #225 OBJECTID apply
< #225 '('
< #225 OBJECTID actual
< #225 ':'
< #225 TYPEID Expr
< #225 ')'
< #225 ':'
< #225 TYPEID Expr
< #225 '{'
< #226 OBJECTID body
< #226 '.'
< #226 OBJECTID substitute
< #226 '('
< #226 OBJECTID arg
< #226 ','
< #226 OBJECTID actual
< #226 ')'
< #227 '}'
< #227 ';'
< #230 OBJECTID substitute
< #230 '('
< #230 OBJECTID x
< #230 ':'
< #230 TYPEID Variable
< #230 ','
< #230 OBJECTID e
< #230 ':'
< #230 TYPEID Expr
< #230 ')'
< #230 ':'
< #230 TYPEID Expr
< #230 '{'
< #231 IF
< #231 OBJECTID x
< #231 '='
< #231 OBJECTID arg
< #231 THEN
< #232 OBJECTID self
< #233 ELSE
< #234 LET
< #234 OBJECTID new_body
< #234 ':'
< #234 TYPEID Expr
< #234 ASSIGN
< #234 OBJECTID body
< #234 '.'
< #234 OBJECTID substitute
< #234 '('
< #234 OBJECTID x
< #234 ','
< #234 OBJECTID e
< #234 ')'
< #234 ','
< #235 OBJECTID new_lam
< #235 ':'
< #235 TYPEID Lambda
< #235 ASSIGN
< #235 NEW
< #235 TYPEID Lambda
< #235 IN
< #236 OBJECTID new_lam
< #236 '.'
< #236 OBJECTID init
< #236 '('
< #236 OBJECTID arg
< #236 ','
< #236 OBJECTID new_body
< #236 ')'
< #237 FI
< #238 '}'
< #238 ';'
< #240 OBJECTID gen_code
< #240 '('
< #240 OBJECTID env
< #240 ':'
< #240 TYPEID VarList
< #240 ','
< #240 OBJECTID closures
< #240 ':'
< #240 TYPEID LambdaListRef
< #240 ')'
< #240 ':'
< #240 TYPEID SELF_TYPE
< #240 '{'
< #241 '{'
< #242 OBJECTID out_string
< #242 '('
< #242 STR_CONST "((new Closure"
< #242 ')'
< #242 ';'
< #243 OBJECTID out_int
< #243 '('
< #243 OBJECTID closures
< #243 '.'
< #243 OBJECTID add
< #243 '('
< #243 OBJECTID env
< #243 ','
< #243 OBJECTID self
< #243 ')'
< #243 ')'
< #243 ';'
< #244 OBJECTID out_string
< #244 '('
< #244 STR_CONST ").init("
< #244 ')'
< #244 ';'
< #245 IF
< #245 OBJECTID env
< #245 '.'
< #245 OBJECTID isNil
< #245 '('
< #245 ')'
< #245 THEN
< #246 OBJECTID out_string
< #246 '('
< #246 STR_CONST "new Closure))"
< #246 ')'
< #247 ELSE
< #248 OBJECTID out_string
< #248 '('
< #248 STR_CONST "self))"
< #248 ')'
< #248 FI
< #248 ';'
< #249 OBJECTID self
< #249 ';'
< #250 '}'
< #251 '}'
< #251 ';'
< #253 OBJECTID gen_closure_code
< #253 '('
< #253 OBJECTID n
< #253 ':'
< #253 TYPEID Int
< #253 ','
< #253 OBJECTID env
< #253 ':'
< #253 TYPEID VarList
< #253 ','
< #254 OBJECTID closures
< #254 ':'
< #254 TYPEID LambdaListRef
< #254 ')'
< #254 ':'
< #254 TYPEID SELF_TYPE
< #254 '{'
< #255 '{'
< #256 OBJECTID out_string
< #256 '('
< #256 STR_CONST "class Closure"
< #256 ')'
< #256 ';'
< #257 OBJECTID out_int
< #257 '('
< #257 OBJECTID n
< #257 ')'
< #257 ';'
< #258 OBJECTID out_string
< #258 '('
< #258 STR_CONST " inherits Closure {\n"
< #258 ')'
< #258 ';'
< #259 OBJECTID out_string
< #259 '('
< #259 STR_CONST "  apply(y : EvalObject) : EvalObject {\n"
< #259 ')'
< #259 ';'
< #260 OBJECTID out_string
< #260 '('
< #260 STR_CONST "    { out_string(\"Applying closure "
< #260 ')'
< #260 ';'
< #261 OBJECTID out_int
< #261 '('
< #261 OBJECTID n
< #261 ')'
< #261 ';'
< #262 OBJECTID out_string
< #262 '('
< #262 STR_CONST "\\n\");\n"
< #262 ')'
< #262 ';'
< #263 OBJECTID out_string
< #263 '('
< #263 STR_CONST "      x <- y;\n"
< #263 ')'
< #263 ';'
< #264 OBJECTID body
< #264 '.'
< #264 OBJECTID gen_code
< #264 '('
< #264 OBJECTID env
< #264 '.'
< #264 OBJECTID add
< #264 '('
< #264 OBJECTID arg
< #264 ')'
< #264 ','
< #264 OBJECTID closures
< #264 ')'
< #264 ';'
< #265 OBJECTID out_string
< #265 '('
< #265 STR_CONST ";}};\n"
< #265 ')'
< #265 ';'
< #266 OBJECTID out_string
< #266 '('
< #266 STR_CONST "};\n"
< #266 ')'
< #266 ';'
< #267 '}'
< #268 '}'
< #268 ';'
< #269 '}'
< #269 ';'
< #274 CLASS
< #274 TYPEID App
< #274 INHERITS
< #274 TYPEID Expr
< #274 '{'
< #275 OBJECTID fun
< #275 ':'
< #275 TYPEID Expr
< #275 ';'
< #276 OBJECTID arg
< #276 ':'
< #276 TYPEID Expr
< #276 ';'
< #278 OBJECTID init
< #278 '('
< #278 OBJECTID f
< #278 ':'
< #278 TYPEID Expr
< #278 ','
< #278 OBJECTID a
< #278 ':'
< #278 TYPEID Expr
< #278 ')'
< #278 ':'
< #278 TYPEID App
< #278 '{'
< #279 '{'
< #280 OBJECTID fun
< #280 ASSIGN
< #280 OBJECTID f
< #280 ';'
< #281 OBJECTID arg
< #281 ASSIGN
< #281 OBJECTID a
< #281 ';'
< #282 OBJECTID self
< #282 ';'
< #283 '}'
< #284 '}'
< #284 ';'
< #286 OBJECTID print_self
< #286 '('
< #286 ')'
< #286 ':'
< #286 TYPEID SELF_TYPE
< #286 '{'
< #287 '{'
< #288 OBJECTID out_string
< #288 '('
< #288 STR_CONST "(("
< #288 ')'
< #288 ';'
< #289 OBJECTID fun
< #289 '.'
< #289 OBJECTID print_self
< #289 '('
< #289 ')'
< #289 ';'
< #290 OBJECTID out_string
< #290 '('
< #290 STR_CONST ")@("
< #290 ')'
< #290 ';'
< #291 OBJECTID arg
< #291 '.'
< #291 OBJECTID print_self
< #291 '('
< #291 ')'
< #291 ';'
< #292 OBJECTID out_string
< #292 '('
< #292 STR_CONST "))"
< #292 ')'
< #292 ';'
< #293 OBJECTID self
< #293 ';'
< #294 '}'
< #295 '}'
< #295 ';'
< #297 OBJECTID beta
< #297 '('
< #297 ')'
< #297 ':'
< #297 TYPEID Expr
< #297 '{'
< #298 CASE
< #298 OBJECTID fun
< #298 OF
< #299 OBJECTID l
< #299 ':'
< #299 TYPEID Lambda
< #299 DARROW
< #299 OBJECTID l
< #299 '.'
< #299 OBJECTID apply
< #299 '('
< #299 OBJECTID arg
< #299 ')'
< #299 ';'
< #300 OBJECTID e
< #300 ':'
< #300 TYPEID Expr
< #300 DARROW
< #301 LET
< #301 OBJECTID new_fun
< #301 ':'
< #301 TYPEID Expr
< #301 ASSIGN
< #301 OBJECTID fun
< #301 '.'
< #301 OBJECTID beta
< #301 '('
< #301 ')'
< #301 ','
< #302 OBJECTID new_app
< #302 ':'
< #302 TYPEID App
< #302 ASSIGN
< #302 NEW
< #302 TYPEID App
< #302 IN
< #303 OBJECTID new_app
< #303 '.'
< #303 OBJECTID init
< #303 '('
< #303 OBJECTID new_fun
< #303 ','
< #303 OBJECTID arg
< #303 ')'
< #303 ';'
< #304 ESAC
< #305 '}'
< #305 ';'
< #307 OBJECTID substitute
< #307 '('
< #307 OBJECTID x
< #307 ':'
< #307 TYPEID Variable
< #307 ','
< #307 OBJECTID e
< #307 ':'
< #307 TYPEID Expr
< #307 ')'
< #307 ':'
< #307 TYPEID Expr
< #307 '{'
< #308 LET
< #308 OBJECTID new_fun
< #308 ':'
< #308 TYPEID Expr
< #308 ASSIGN
< #308 OBJECTID fun
< #308 '.'
< #308 OBJECTID substitute
< #308 '('
< #308 OBJECTID x
< #308 ','
< #308 OBJECTID e
< #308 ')'
< #308 ','
< #309 OBJECTID new_arg
< #309 ':'
< #309 TYPEID Expr
< #309 ASSIGN
< #309 OBJECTID arg
< #309 '.'
< #309 OBJECTID substitute
< #309 '('
< #309 OBJECTID x
< #309 ','
< #309 OBJECTID e
< #309 ')'
< #309 ','
< #310 OBJECTID new_app
< #310 ':'
< #310 TYPEID App
< #310 ASSIGN
< #310 NEW
< #310 TYPEID App
< #310 IN
< #311 OBJECTID new_app
< #311 '.'
< #311 OBJECTID init
< #311 '('
< #311 OBJECTID new_fun
< #311 ','
< #311 OBJECTID new_arg
< #311 ')'
< #312 '}'
< #312 ';'
< #314 OBJECTID gen_code
< #314 '('
< #314 OBJECTID env
< #314 ':'
< #314 TYPEID VarList
< #314 ','
< #314 OBJECTID closures
< #314 ':'
< #314 TYPEID LambdaListRef
< #314 ')'
< #314 ':'
< #314 TYPEID SELF_TYPE
< #314 '{'
< #315 '{'
< #316 OBJECTID out_string
< #316 '('
< #316 STR_CONST "(let x : EvalObject <- "
< #316 ')'
< #316 ';'
< #317 OBJECTID fun
< #317 '.'
< #317 OBJECTID gen_code
< #317 '('
< #317 OBJECTID env
< #317 ','
< #317 OBJECTID closures
< #317 ')'
< #317 ';'
< #318 OBJECTID out_string
< #318 '('
< #318 STR_CONST ",\n"
< #318 ')'
< #318 ';'
< #319 OBJECTID out_string
< #319 '('
< #319 STR_CONST "     y : EvalObject <- "
< #319 ')'
< #319 ';'
< #320 OBJECTID arg
< #320 '.'
< #320 OBJECTID gen_code
< #320 '('
< #320 OBJECTID env
< #320 ','
< #320 OBJECTID closures
< #320 ')'
< #320 ';'
< #321 OBJECTID out_string
< #321 '('
< #321 STR_CONST " in\n"
< #321 ')'
< #321 ';'
< #322 OBJECTID out_string
< #322 '('
< #322 STR_CONST "  case x of\n"
< #322 ')'
< #322 ';'
< #323 OBJECTID out_string
< #323 '('
< #323 STR_CONST "    c : Closure => c.apply(y);\n"
< #323 ')'
< #323 ';'
< #324 OBJECTID out_string
< #324 '('
< #324 STR_CONST "    o : Object => { abort(); new EvalObject; };\n"
< #324 ')'
< #324 ';'
< #325 OBJECTID out_string
< #325 '('
< #325 STR_CONST "  esac)"
< #325 ')'
< #325 ';'
< #326 '}'
< #327 '}'
< #327 ';'
< #328 '}'
< #328 ';'
< #335 CLASS
< #335 TYPEID Term
< #335 INHERITS
< #335 TYPEID IO
< #335 '{'
< #339 OBJECTID var
< #339 '('
< #339 OBJECTID x
< #339 ':'
< #339 TYPEID String
< #339 ')'
< #339 ':'
< #339 TYPEID Variable
< #339 '{'
< #340 LET
< #340 OBJECTID v
< #340 ':'
< #340 TYPEID Variable
< #340 ASSIGN
< #340 NEW
< #340 TYPEID Variable
< #340 IN
< #341 OBJECTID v
< #341 '.'
< #341 OBJECTID init
< #341 '('
< #341 OBJECTID x
< #341 ')'
< #342 '}'
< #342 ';'
< #344 OBJECTID lam
< #344 '('
< #344 OBJECTID x
< #344 ':'
< #344 TYPEID Variable
< #344 ','
< #344 OBJECTID e
< #344 ':'
< #344 TYPEID Expr
< #344 ')'
< #344 ':'
< #344 TYPEID Lambda
< #344 '{'
< #345 LET
< #345 OBJECTID l
< #345 ':'
< #345 TYPEID Lambda
< #345 ASSIGN
< #345 NEW
< #345 TYPEID Lambda
< #345 IN
< #346 OBJECTID l
< #346 '.'
< #346 OBJECTID init
< #346 '('
< #346 OBJECTID x
< #346 ','
< #346 OBJECTID e
< #346 ')'
< #347 '}'
< #347 ';'
< #349 OBJECTID app
< #349 '('
< #349 OBJECTID e1
< #349 ':'
< #349 TYPEID Expr
< #349 ','
< #349 OBJECTID e2
< #349 ':'
< #349 TYPEID Expr
< #349 ')'
< #349 ':'
< #349 TYPEID App
< #349 '{'
< #350 LET
< #350 OBJECTID a
< #350 ':'
< #350 TYPEID App
< #350 ASSIGN
< #350 NEW
< #350 TYPEID App
< #350 IN
< #351 OBJECTID a
< #351 '.'
< #351 OBJECTID init
< #351 '('
< #351 OBJECTID e1
< #351 ','
< #351 OBJECTID e2
< #351 ')'
< #352 '}'
< #352 ';'
< #357 OBJECTID i
< #357 '('
< #357 ')'
< #357 ':'
< #357 TYPEID Expr
< #357 '{'
< #358 LET
< #358 OBJECTID x
< #358 ':'
< #358 TYPEID Variable
< #358 ASSIGN
< #358 OBJECTID var
< #358 '('
< #358 STR_CONST "x"
< #358 ')'
< #358 IN
< #359 OBJECTID lam
< #359 '('
< #359 OBJECTID x
< #359 ','
< #359 OBJECTID x
< #359 ')'
< #360 '}'
< #360 ';'
< #362 OBJECTID k
< #362 '('
< #362 ')'
< #362 ':'
< #362 TYPEID Expr
< #362 '{'
< #363 LET
< #363 OBJECTID x
< #363 ':'
< #363 TYPEID Variable
< #363 ASSIGN
< #363 OBJECTID var
< #363 '('
< #363 STR_CONST "x"
< #363 ')'
< #363 ','
< #364 OBJECTID y
< #364 ':'
< #364 TYPEID Variable
< #364 ASSIGN
< #364 OBJECTID var
< #364 '('
< #364 STR_CONST "y"
< #364 ')'
< #364 IN
< #365 OBJECTID lam
< #365 '('
< #365 OBJECTID x
< #365 ','
< #365 OBJECTID lam
< #365 '('
< #365 OBJECTID y
< #365 ','
< #365 OBJECTID x
< #365 ')'
< #365 ')'
< #366 '}'
< #366 ';'
< #368 OBJECTID s
< #368 '('
< #368 ')'
< #368 ':'
< #368 TYPEID Expr
< #368 '{'
< #369 LET
< #369 OBJECTID x
< #369 ':'
< #369 TYPEID Variable
< #369 ASSIGN
< #369 OBJECTID var
< #369 '('
< #369 STR_CONST "x"
< #369 ')'
< #369 ','
< #370 OBJECTID y
< #370 ':'
< #370 TYPEID Variable
< #370 ASSIGN
< #370 OBJECTID var
< #370 '('
< #370 STR_CONST "y"
< #370 ')'
< #370 ','
< #371 OBJECTID z
< #371 ':'
< #371 TYPEID Variable
< #371 ASSIGN
< #371 OBJECTID var
< #371 '('
< #371 STR_CONST "z"
< #371 ')'
< #371 IN
< #372 OBJECTID lam
< #372 '('
< #372 OBJECTID x
< #372 ','
< #372 OBJECTID lam
< #372 '('
< #372 OBJECTID y
< #372 ','
< #372 OBJECTID lam
< #372 '('
< #372 OBJECTID z
< #372 ','
< #372 OBJECTID app
< #372 '('
< #372 OBJECTID app
< #372 '('
< #372 OBJECTID x
< #372 ','
< #372 OBJECTID z
< #372 ')'
< #372 ','
< #372 OBJECTID app
< #372 '('
< #372 OBJECTID y
< #372 ','
< #372 OBJECTID z
< #372 ')'
< #372 ')'
< #372 ')'
< #372 ')'
< #372 ')'
< #373 '}'
< #373 ';'
< #375 '}'
< #375 ';'
< #383 CLASS
< #383 TYPEID Main
< #383 INHERITS
< #383 TYPEID Term
< #383 '{'
< #385 OBJECTID beta_reduce
< #385 '('
< #385 OBJECTID e
< #385 ':'
< #385 TYPEID Expr
< #385 ')'
< #385 ':'
< #385 TYPEID Expr
< #385 '{'
< #386 '{'
< #387 OBJECTID out_string
< #387 '('
< #387 STR_CONST "beta-reduce: "
< #387 ')'
< #387 ';'
< #388 OBJECTID e
< #388 '.'
< #388 OBJECTID print_self
< #388 '('
< #388 ')'
< #388 ';'
< #389 LET
< #389 OBJECTID done
< #389 ':'
< #389 TYPEID Bool
< #389 ASSIGN
< #389 BOOL_CONST false
< #389 ','
< #390 OBJECTID new_expr
< #390 ':'
< #390 TYPEID Expr
< #390 IN
< #391 '{'
< #392 WHILE
< #392 '('
< #392 NOT
< #392 OBJECTID done
< #392 ')'
< #392 LOOP
< #393 '{'
< #394 OBJECTID new_expr
< #394 ASSIGN
< #394 OBJECTID e
< #394 '.'
< #394 OBJECTID beta
< #394 '('
< #394 ')'
< #394 ';'
< #395 IF
< #395 '('
< #395 OBJECTID new_expr
< #395 '='
< #395 OBJECTID e
< #395 ')'
< #395 THEN
< #396 OBJECTID done
< #396 ASSIGN
< #396 BOOL_CONST true
< #397 ELSE
< #398 '{'
< #399 OBJECTID e
< #399 ASSIGN
< #399 OBJECTID new_expr
< #399 ';'
< #400 OBJECTID out_string
< #400 '('
< #400 STR_CONST " =>\n"
< #400 ')'
< #400 ';'
< #401 OBJECTID e
< #401 '.'
< #401 OBJECTID print_self
< #401 '('
< #401 ')'
< #401 ';'
< #402 '}'
< #403 FI
< #403 ';'
< #404 '}'
< #405 POOL
< #405 ';'
< #406 OBJECTID out_string
< #406 '('
< #406 STR_CONST "\n"
< #406 ')'
< #406 ';'
< #407 OBJECTID e
< #407 ';'
< #408 '}'
< #408 ';'
< #409 '}'
< #410 '}'
< #410 ';'
< #412 OBJECTID eval_class
< #412 '('
< #412 ')'
< #412 ':'
< #412 TYPEID SELF_TYPE
< #412 '{'
< #413 '{'
< #414 OBJECTID out_string
< #414 '('
< #414 STR_CONST "class EvalObject inherits IO {\n"
< #414 ')'
< #414 ';'
< #415 OBJECTID out_string
< #415 '('
< #415 STR_CONST "  eval() : EvalObject { { abort(); self; } };\n"
< #415 ')'
< #415 ';'
< #416 OBJECTID out_string
< #416 '('
< #416 STR_CONST "};\n"
< #416 ')'
< #416 ';'
< #417 '}'
< #418 '}'
< #418 ';'
< #420 OBJECTID closure_class
< #420 '('
< #420 ')'
< #420 ':'
< #420 TYPEID SELF_TYPE
< #420 '{'
< #421 '{'
< #422 OBJECTID out_string
< #422 '('
< #422 STR_CONST "class Closure inherits EvalObject {\n"
< #422 ')'
< #422 ';'
< #423 OBJECTID out_string
< #423 '('
< #423 STR_CONST "  parent : Closure;\n"
< #423 ')'
< #423 ';'
< #424 OBJECTID out_string
< #424 '('
< #424 STR_CONST "  x : EvalObject;\n"
< #424 ')'
< #424 ';'
< #425 OBJECTID out_string
< #425 '('
< #425 STR_CONST "  get_parent() : Closure { parent };\n"
< #425 ')'
< #425 ';'
< #426 OBJECTID out_string
< #426 '('
< #426 STR_CONST "  get_x() : EvalObject { x };\n"
< #426 ')'
< #426 ';'
< #427 OBJECTID out_string
< #427 '('
< #427 STR_CONST "  init(p : Closure) : Closure {{ parent <- p; self; }};\n"
< #427 ')'
< #427 ';'
< #428 OBJECTID out_string
< #428 '('
< #428 STR_CONST "  apply(y : EvalObject) : EvalObject { { abort(); self; } };\n"
< #428 ')'
< #428 ';'
< #429 OBJECTID out_string
< #429 '('
< #429 STR_CONST "};\n"
< #429 ')'
< #429 ';'
< #430 '}'
< #431 '}'
< #431 ';'
< #433 OBJECTID gen_code
< #433 '('
< #433 OBJECTID e
< #433 ':'
< #433 TYPEID Expr
< #433 ')'
< #433 ':'
< #433 TYPEID SELF_TYPE
< #433 '{'
< #434 LET
< #434 OBJECTID cl
< #434 ':'
< #434 TYPEID LambdaListRef
< #434 ASSIGN
< #434 '('
< #434 NEW
< #434 TYPEID LambdaListRef
< #434 ')'
< #434 '.'
< #434 OBJECTID reset
< #434 '('
< #434 ')'
< #434 IN
< #435 '{'
< #436 OBJECTID out_string
< #436 '('
< #436 STR_CONST "Generating code for "
< #436 ')'
< #436 ';'
< #437 OBJECTID e
< #437 '.'
< #437 OBJECTID print_self
< #437 '('
< #437 ')'
< #437 ';'
< #438 OBJECTID out_string
< #438 '('
< #438 STR_CONST "\n------------------cut here------------------\n"
< #438 ')'
< #438 ';'
< #439 OBJECTID out_string
< #439 '('
< #439 STR_CONST "(*Generated by lam.cl (Jeff Foster, March 2000)*)\n"
< #439 ')'
< #439 ';'
< #440 OBJECTID eval_class
< #440 '('
< #440 ')'
< #440 ';'
< #441 OBJECTID closure_class
< #441 '('
< #441 ')'
< #441 ';'
< #442 OBJECTID out_string
< #442 '('
< #442 STR_CONST "class Main {\n"
< #442 ')'
< #442 ';'
< #443 OBJECTID out_string
< #443 '('
< #443 STR_CONST "  main() : EvalObject {\n"
< #443 ')'
< #443 ';'
< #444 OBJECTID e
< #444 '.'
< #444 OBJECTID gen_code
< #444 '('
< #444 NEW
< #444 TYPEID VarList
< #444 ','
< #444 OBJECTID cl
< #444 ')'
< #444 ';'
< #445 OBJECTID out_string
< #445 '('
< #445 STR_CONST "\n};\n};\n"
< #445 ')'
< #445 ';'
< #446 WHILE
< #446 '('
< #446 NOT
< #446 '('
< #446 OBJECTID cl
< #446 '.'
< #446 OBJECTID isNil
< #446 '('
< #446 ')'
< #446 ')'
< #446 ')'
< #446 LOOP
< #447 LET
< #447 OBJECTID e
< #447 ':'
< #447 TYPEID VarList
< #447 ASSIGN
< #447 OBJECTID cl
< #447 '.'
< #447 OBJECTID headE
< #447 '('
< #447 ')'
< #447 ','
< #448 OBJECTID c
< #448 ':'
< #448 TYPEID Lambda
< #448 ASSIGN
< #448 OBJECTID cl
< #448 '.'
< #448 OBJECTID headC
< #448 '('
< #448 ')'
< #448 ','
< #449 OBJECTID n
< #449 ':'
< #449 TYPEID Int
< #449 ASSIGN
< #449 OBJECTID cl
< #449 '.'
< #449 OBJECTID headN
< #449 '('
< #449 ')'
< #449 IN
< #450 '{'
< #451 OBJECTID cl
< #451 '.'
< #451 OBJECTID removeHead
< #451 '('
< #451 ')'
< #451 ';'
< #452 OBJECTID c
< #452 '.'
< #452 OBJECTID gen_closure_code
< #452 '('
< #452 OBJECTID n
< #452 ','
< #452 OBJECTID e
< #452 ','
< #452 OBJECTID cl
< #452 ')'
< #452 ';'
< #453 '}'
< #454 POOL
< #454 ';'
< #455 OBJECTID out_string
< #455 '('
< #455 STR_CONST "\n------------------cut here------------------\n"
< #455 ')'
< #455 ';'
< #456 '}'
< #457 '}'
< #457 ';'
< #459 OBJECTID main
< #459 '('
< #459 ')'
< #459 ':'
< #459 TYPEID Int
< #459 '{'
< #460 '{'
< #461 OBJECTID i
< #461 '('
< #461 ')'
< #461 '.'
< #461 OBJECTID print_self
< #461 '('
< #461 ')'
< #461 ';'
< #462 OBJECTID out_string
< #462 '('
< #462 STR_CONST "\n"
< #462 ')'
< #462 ';'
< #463 OBJECTID k
< #463 '('
< #463 ')'
< #463 '.'
< #463 OBJECTID print_self
< #463 '('
< #463 ')'
< #463 ';'
< #464 OBJECTID out_string
< #464 '('
< #464 STR_CONST "\n"
< #464 ')'
< #464 ';'
< #465 OBJECTID s
< #465 '('
< #465 ')'
< #465 '.'
< #465 OBJECTID print_self
< #465 '('
< #465 ')'
< #465 ';'
< #466 OBJECTID out_string
< #466 '('
< #466 STR_CONST "\n"
< #466 ')'
< #466 ';'
< #467 OBJECTID beta_reduce
< #467 '('
< #467 OBJECTID app
< #467 '('
< #467 OBJECTID app
< #467 '('
< #467 OBJECTID app
< #467 '('
< #467 OBJECTID s
< #467 '('
< #467 ')'
< #467 ','
< #467 OBJECTID k
< #467 '('
< #467 ')'
< #467 ')'
< #467 ','
< #467 OBJECTID i
< #467 '('
< #467 ')'
< #467 ')'
< #467 ','
< #467 OBJECTID i
< #467 '('
< #467 ')'
< #467 ')'
< #467 ')'
< #467 ';'
< #468 OBJECTID beta_reduce
< #468 '('
< #468 OBJECTID app
< #468 '('
< #468 OBJECTID app
< #468 '('
< #468 OBJECTID k
< #468 '('
< #468 ')'
< #468 ','
< #468 OBJECTID i
< #468 '('
< #468 ')'
< #468 ')'
< #468 ','
< #468 OBJECTID i
< #468 '('
< #468 ')'
< #468 ')'
< #468 ')'
< #468 ';'
< #469 OBJECTID gen_code
< #469 '('
< #469 OBJECTID app
< #469 '('
< #469 OBJECTID i
< #469 '('
< #469 ')'
< #469 ','
< #469 OBJECTID i
< #469 '('
< #469 ')'
< #469 ')'
< #469 ')'
< #469 ';'
< #470 OBJECTID gen_code
< #470 '('
< #470 OBJECTID app
< #470 '('
< #470 OBJECTID app
< #470 '('
< #470 OBJECTID app
< #470 '('
< #470 OBJECTID s
< #470 '('
< #470 ')'
< #470 ','
< #470 OBJECTID k
< #470 '('
< #470 ')'
< #470 ')'
< #470 ','
< #470 OBJECTID i
< #470 '('
< #470 ')'
< #470 ')'
< #470 ','
< #470 OBJECTID i
< #470 '('
< #470 ')'
< #470 ')'
< #470 ')'
< #470 ';'
< #471 OBJECTID gen_code
< #471 '('
< #471 OBJECTID app
< #471 '('
< #471 OBJECTID app
< #471 '('
< #471 OBJECTID app
< #471 '('
< #471 OBJECTID app
< #471 '('
< #471 OBJECTID app
< #471 '('
< #471 OBJECTID app
< #471 '('
< #471 OBJECTID app
< #471 '('
< #471 OBJECTID app
< #471 '('
< #471 OBJECTID i
< #471 '('
< #471 ')'
< #471 ','
< #471 OBJECTID k
< #471 '('
< #471 ')'
< #471 ')'
< #471 ','
< #471 OBJECTID s
< #471 '('
< #471 ')'
< #471 ')'
< #471 ','
< #471 OBJECTID s
< #471 '('
< #471 ')'
< #471 ')'
< #471 ','
< #472 OBJECTID k
< #472 '('
< #472 ')'
< #472 ')'
< #472 ','
< #472 OBJECTID s
< #472 '('
< #472 ')'
< #472 ')'
< #472 ','
< #472 OBJECTID i
< #472 '('
< #472 ')'
< #472 ')'
< #472 ','
< #472 OBJECTID k
< #472 '('
< #472 ')'
< #472 ')'
< #472 ','
< #472 OBJECTID i
< #472 '('
< #472 ')'
< #472 ')'
< #472 ')'
< #472 ';'
< #473 OBJECTID gen_code
< #473 '('
< #473 OBJECTID app
< #473 '('
< #473 OBJECTID app
< #473 '('
< #473 OBJECTID i
< #473 '('
< #473 ')'
< #473 ','
< #473 OBJECTID app
< #473 '('
< #473 OBJECTID k
< #473 '('
< #473 ')'
< #473 ','
< #473 OBJECTID s
< #473 '('
< #473 ')'
< #473 ')'
< #473 ')'
< #473 ','
< #473 OBJECTID app
< #473 '('
< #473 OBJECTID k
< #473 '('
< #473 ')'
< #473 ','
< #473 OBJECTID app
< #473 '('
< #473 OBJECTID s
< #473 '('
< #473 ')'
< #473 ','
< #473 OBJECTID s
< #473 '('
< #473 ')'
< #473 ')'
< #473 ')'
< #473 ')'
< #473 ')'
< #473 ';'
< #474 INT_CONST 0
< #474 ';'
< #475 '}'
< #476 '}'
< #476 ';'
< #477 '}'
< #477 ';'
---
> (* A program for
> 
>    1. Representing lambda terms
>    2. Interpreting lambda terms
>    3. Compiling lambda calculus programs to Cool
> 
>    The lambda calculus is described by the following grammar:
> 
>    e ::= x	       a variable
>       |  \x.e	       a function with argument x
>       |  e1@e2	       apply function e1 to argument e2
> 
>   Jeff Foster (jfoster@cs.berkeley.edu)
>   March 24, 2000
> *)
> 
> (*
>  * A list of variables.  We use this to do de Bruijn numbering
>  *
>  *)
> class VarList inherits IO {
>   isNil() : Bool { true };
>   head()  : Variable { { abort(); new Variable; } };
>   tail()  : VarList { { abort(); new VarList; } };
>   add(x : Variable) : VarList { (new VarListNE).init(x, self) };
>   print() : SELF_TYPE { out_string("\n") };
> };
> 
> class VarListNE inherits VarList {
>   x : Variable;
>   rest : VarList;
>   isNil() : Bool { false };
>   head()  : Variable { x };
>   tail()  : VarList { rest };
>   init(y : Variable, r : VarList) : VarListNE { { x <- y; rest <- r; self; } };
>   print() : SELF_TYPE { { x.print_self(); out_string(" ");
> 	                  rest.print(); self; } };
> };
> 
> (*
>  * A list of closures we need to build.  We need to number (well, name)
>  * the closures uniquely.
>  *)
> class LambdaList {
>   isNil() : Bool { true };
>   headE() : VarList { { abort(); new VarList; } };
>   headC() : Lambda { { abort(); new Lambda; } };
>   headN() : Int { { abort(); 0; } };
>   tail()  : LambdaList { { abort(); new LambdaList; } };
>   add(e : VarList, x : Lambda, n : Int) : LambdaList {
>     (new LambdaListNE).init(e, x, n, self)
>   };
> };
> 
> class LambdaListNE inherits LambdaList {
>   lam : Lambda;
>   num : Int;
>   env : VarList;
>   rest : LambdaList;
>   isNil() : Bool { false };
>   headE() : VarList { env };
>   headC() : Lambda { lam };
>   headN() : Int { num };
>   tail()  : LambdaList { rest };
>   init(e : VarList, l : Lambda, n : Int, r : LambdaList) : LambdaListNE {
>     {
>       env <- e;
>       lam <- l;
>       num <- n;
>       rest <- r;
>       self;
>     }
>   };
> };
> 
> class LambdaListRef {
>   nextNum : Int <- 0;
>   l : LambdaList;
>   isNil() : Bool { l.isNil() };
>   headE() : VarList { l.headE() };
>   headC() : Lambda { l.headC() };
>   headN() : Int { l.headN() };
>   reset() : SELF_TYPE {
>     {
>       nextNum <- 0;
>       l <- new LambdaList;
>       self;
>     }
>   };
>   add(env : VarList, c : Lambda) : Int {
>     {
>       l <- l.add(env, c, nextNum);
>       nextNum <- nextNum + 1;
>       nextNum - 1;
>     }
>   };
>   removeHead() : SELF_TYPE {
>     {
>       l <- l.tail();
>       self;
>     }
>   };
> };
> 
> (*
>  * Lambda expressions
>  *
>  *)
> 
> -- A pure virtual class representing any expression
> class Expr inherits IO {
> 
>   -- Print this lambda term
>   print_self() : SELF_TYPE {
>     {
>       out_string("\nError: Expr is pure virtual; can't print self\n");
>       abort();
>       self;
>     }
>   };
> 
>   -- Do one step of (outermost) beta reduction to this term
>   beta() : Expr {
>     {
>       out_string("\nError: Expr is pure virtual; can't beta-reduce\n");
>       abort();
>       self;
>     }
>   };
> 
>   -- Replace all occurrences of x by e
>   substitute(x : Variable, e : Expr) : Expr {
>     {
>       out_string("\nError: Expr is pure virtual; can't substitute\n");
>       abort();
>       self;
>     }
>   };
> 
>   -- Generate Cool code to evaluate this expression
>   gen_code(env : VarList, closures : LambdaListRef) : SELF_TYPE {
>     {
>       out_string("\nError: Expr is pure virtual; can't gen_code\n");
>       abort();
>       self;
>     }
>   };
> };
> 
> (*
>  * Variables
>  *)
> class Variable inherits Expr {
>   name : String;
> 
>   init(n:String) : Variable {
>     {
>       name <- n;
>       self;
>     }
>   };
> 
>   print_self() : SELF_TYPE {
>     out_string(name)
>   };
> 
>   beta() : Expr { self };
>   
>   substitute(x : Variable, e : Expr) : Expr {
>     if x = self then e else self fi
>   };
> 
>   gen_code(env : VarList, closures : LambdaListRef) : SELF_TYPE {
>     let cur_env : VarList <- env in
>       { while (if cur_env.isNil() then
> 	          false
> 	       else
> 	         not (cur_env.head() = self)
> 	       fi) loop
> 	  { out_string("get_parent().");
> 	    cur_env <- cur_env.tail();
>           }
>         pool;
>         if cur_env.isNil() then
>           { out_string("Error:  free occurrence of ");
>             print_self();
>             out_string("\n");
>             abort();
>             self;
>           }
>         else
>           out_string("get_x()")
>         fi;
>       }
>   };
> };
> 
> (*
>  * Functions
>  *)
> class Lambda inherits Expr {
>   arg : Variable;
>   body : Expr;
> 
>   init(a:Variable, b:Expr) : Lambda {
>     {
>       arg <- a;
>       body <- b;
>       self;
>     }
>   };
> 
>   print_self() : SELF_TYPE {
>     {
>       out_string("\\");
>       arg.print_self();
>       out_string(".");
>       body.print_self();
>       self;
>     }
>   };
> 
>   beta() : Expr { self };
> 
>   apply(actual : Expr) : Expr {
>     body.substitute(arg, actual)
>   };
> 
>   -- We allow variables to be reused
>   substitute(x : Variable, e : Expr) : Expr {
>     if x = arg then
>       self
>     else
>       let new_body : Expr <- body.substitute(x, e),
> 	  new_lam : Lambda <- new Lambda in
> 	new_lam.init(arg, new_body)
>     fi
>   };
> 
>   gen_code(env : VarList, closures : LambdaListRef) : SELF_TYPE {
>     {
>       out_string("((new Closure");
>       out_int(closures.add(env, self));
>       out_string(").init(");
>       if env.isNil() then
>         out_string("new Closure))")
>       else
> 	out_string("self))") fi;
>       self;
>     }
>   };
> 
>   gen_closure_code(n : Int, env : VarList,
> 		   closures : LambdaListRef) : SELF_TYPE {
>     {
>       out_string("class Closure");
>       out_int(n);
>       out_string(" inherits Closure {\n");
>       out_string("  apply(y : EvalObject) : EvalObject {\n");
>       out_string("    { out_string(\"Applying closure ");
>       out_int(n);
>       out_string("\\n\");\n");
>       out_string("      x <- y;\n");
>       body.gen_code(env.add(arg), closures);
>       out_string(";}};\n");
>       out_string("};\n");
>     }
>   };
> };
> 
> (*
>  * Applications
>  *)
> class App inherits Expr {
>   fun : Expr;
>   arg : Expr;
> 
>   init(f : Expr, a : Expr) : App {
>     {
>       fun <- f;
>       arg <- a;
>       self;
>     }
>   };
> 
>   print_self() : SELF_TYPE {
>     {
>       out_string("((");
>       fun.print_self();
>       out_string(")@(");
>       arg.print_self();
>       out_string("))");
>       self;
>     }
>   };
> 
>   beta() : Expr {
>     case fun of
>       l : Lambda #1 DARROW
>  l.apply(arg);     -- Lazy evaluation
>       e : Expr #1 DARROW
> 
> 	let new_fun : Expr <- fun.beta(),
> 	    new_app : App <- new App in
> 	  new_app.init(new_fun, arg);
>     esac
>   };
> 
>   substitute(x : Variable, e : Expr) : Expr {
>     let new_fun : Expr <- fun.substitute(x, e),
>         new_arg : Expr <- arg.substitute(x, e),
>         new_app : App <- new App in
>       new_app.init(new_fun, new_arg)
>   };
> 
>   gen_code(env : VarList, closures : LambdaListRef) : SELF_TYPE {
>     {
>       out_string("(let x : EvalObject <- ");
>       fun.gen_code(env, closures);
>       out_string(",\n");
>       out_string("     y : EvalObject <- ");
>       arg.gen_code(env, closures);
>       out_string(" in\n");
>       out_string("  case x of\n");
>       out_string("    c : Closure #1 DARROW
>  c.apply(y);\n");
>       out_string("    o : Object #1 DARROW
>  { abort(); new EvalObject; };\n");
>       out_string("  esac)");
>     }
>   };
> };
> 
> (*
>  * Term: A class for building up terms
>  *
>  *)
> 
> class Term inherits IO {
>   (*
>    * The basics
>    *)
>   var(x : String) : Variable {
>     let v : Variable <- new Variable in
>       v.init(x)
>   };
> 
>   lam(x : Variable, e : Expr) : Lambda {
>     let l : Lambda <- new Lambda in
>       l.init(x, e)
>   };
> 
>   app(e1 : Expr, e2 : Expr) : App {
>     let a : App <- new App in
>       a.init(e1, e2)
>   };
> 
>   (*
>    * Some useful terms
>    *)
>   i() : Expr {
>     let x : Variable <- var("x") in
>       lam(x,x)
>   };
> 
>   k() : Expr {
>     let x : Variable <- var("x"),
>         y : Variable <- var("y") in
>     lam(x,lam(y,x))
>   };
> 
>   s() : Expr {
>     let x : Variable <- var("x"),
>         y : Variable <- var("y"),
>         z : Variable <- var("z") in
>       lam(x,lam(y,lam(z,app(app(x,z),app(y,z)))))
>   };
> 
> };
> 
> (*
>  *
>  * The main method -- build up some lambda terms and try things out
>  *
>  *)
> 
> class Main inherits Term {
>   -- Beta-reduce an expression, printing out the term at each step
>   beta_reduce(e : Expr) : Expr {
>     {
>       out_string("beta-reduce: ");
>       e.print_self();
>       let done : Bool <- false,
>           new_expr : Expr in
>         {
> 	  while (not done) loop
> 	    {
> 	      new_expr <- e.beta();
> 	      if (new_expr = e) then
> 		done <- true
> 	      else
> 		{
> 		  e <- new_expr;
> 		  out_string(" #1 DARROW
> \n");
> 		  e.print_self();
> 		}
> 	      fi;
> 	    }
>           pool;
> 	  out_string("\n");
>           e;
> 	};
>     }
>   };
> 
>   eval_class() : SELF_TYPE {
>     {
>       out_string("class EvalObject inherits IO {\n");
>       out_string("  eval() : EvalObject { { abort(); self; } };\n");
>       out_string("};\n");
>     }
>   };
> 
>   closure_class() : SELF_TYPE {
>     {
>       out_string("class Closure inherits EvalObject {\n");
>       out_string("  parent : Closure;\n");
>       out_string("  x : EvalObject;\n");
>       out_string("  get_parent() : Closure { parent };\n");
>       out_string("  get_x() : EvalObject { x };\n");
>       out_string("  init(p : Closure) : Closure {{ parent <- p; self; }};\n");
>       out_string("  apply(y : EvalObject) : EvalObject { { abort(); self; } };\n");
>       out_string("};\n");
>     }
>   };
> 
>   gen_code(e : Expr) : SELF_TYPE {
>     let cl : LambdaListRef <- (new LambdaListRef).reset() in
>       {
> 	out_string("Generating code for ");
> 	e.print_self();
> 	out_string("\n------------------cut here------------------\n");
> 	out_string("(*Generated by lam.cl (Jeff Foster, March 2000)*)\n");
> 	eval_class();
> 	closure_class();
> 	out_string("class Main {\n");
> 	out_string("  main() : EvalObject {\n");
> 	e.gen_code(new VarList, cl);
> 	out_string("\n};\n};\n");
> 	while (not (cl.isNil())) loop
> 	  let e : VarList <- cl.headE(),
> 	      c : Lambda <- cl.headC(),
> 	      n : Int <- cl.headN() in
> 	    {
> 	      cl.removeHead();
> 	      c.gen_closure_code(n, e, cl);
> 	    }
> 	pool;
> 	out_string("\n------------------cut here------------------\n");
>       }
>   };
> 
>   main() : Int {
>     {
>       i().print_self();
>       out_string("\n");
>       k().print_self();
>       out_string("\n");
>       s().print_self();
>       out_string("\n");
>       beta_reduce(app(app(app(s(), k()), i()), i()));
>       beta_reduce(app(app(k(),i()),i()));
>       gen_code(app(i(), i()));
>       gen_code(app(app(app(s(), k()), i()), i()));
>       gen_code(app(app(app(app(app(app(app(app(i(), k()), s()), s()),
>                                    k()), s()), i()), k()), i()));
>       gen_code(app(app(i(), app(k(), s())), app(k(), app(s(), s()))));
>       0;
>     }
>   };
> };
pass!
---------  Test  ../../examples/life.cl  ---------
2,1452c2,438
< #45 CLASS
< #45 TYPEID Board
< #45 INHERITS
< #45 TYPEID IO
< #45 '{'
< #47 OBJECTID rows
< #47 ':'
< #47 TYPEID Int
< #47 ';'
< #48 OBJECTID columns
< #48 ':'
< #48 TYPEID Int
< #48 ';'
< #49 OBJECTID board_size
< #49 ':'
< #49 TYPEID Int
< #49 ';'
< #51 OBJECTID size_of_board
< #51 '('
< #51 OBJECTID initial
< #51 ':'
< #51 TYPEID String
< #51 ')'
< #51 ':'
< #51 TYPEID Int
< #51 '{'
< #52 OBJECTID initial
< #52 '.'
< #52 OBJECTID length
< #52 '('
< #52 ')'
< #53 '}'
< #53 ';'
< #55 OBJECTID board_init
< #55 '('
< #55 OBJECTID start
< #55 ':'
< #55 TYPEID String
< #55 ')'
< #55 ':'
< #55 TYPEID SELF_TYPE
< #55 '{'
< #56 '('
< #56 LET
< #56 OBJECTID size
< #56 ':'
< #56 TYPEID Int
< #56 ASSIGN
< #56 OBJECTID size_of_board
< #56 '('
< #56 OBJECTID start
< #56 ')'
< #56 IN
< #57 '{'
< #58 IF
< #58 OBJECTID size
< #58 '='
< #58 INT_CONST 15
< #58 THEN
< #59 '{'
< #60 OBJECTID rows
< #60 ASSIGN
< #60 INT_CONST 3
< #60 ';'
< #61 OBJECTID columns
< #61 ASSIGN
< #61 INT_CONST 5
< #61 ';'
< #62 OBJECTID board_size
< #62 ASSIGN
< #62 OBJECTID size
< #62 ';'
< #63 '}'
< #64 ELSE
< #64 IF
< #64 OBJECTID size
< #64 '='
< #64 INT_CONST 16
< #64 THEN
< #65 '{'
< #66 OBJECTID rows
< #66 ASSIGN
< #66 INT_CONST 4
< #66 ';'
< #67 OBJECTID columns
< #67 ASSIGN
< #67 INT_CONST 4
< #67 ';'
< #68 OBJECTID board_size
< #68 ASSIGN
< #68 OBJECTID size
< #68 ';'
< #69 '}'
< #70 ELSE
< #70 IF
< #70 OBJECTID size
< #70 '='
< #70 INT_CONST 20
< #70 THEN
< #71 '{'
< #72 OBJECTID rows
< #72 ASSIGN
< #72 INT_CONST 4
< #72 ';'
< #73 OBJECTID columns
< #73 ASSIGN
< #73 INT_CONST 5
< #73 ';'
< #74 OBJECTID board_size
< #74 ASSIGN
< #74 OBJECTID size
< #74 ';'
< #75 '}'
< #76 ELSE
< #76 IF
< #76 OBJECTID size
< #76 '='
< #76 INT_CONST 21
< #76 THEN
< #77 '{'
< #78 OBJECTID rows
< #78 ASSIGN
< #78 INT_CONST 3
< #78 ';'
< #79 OBJECTID columns
< #79 ASSIGN
< #79 INT_CONST 7
< #79 ';'
< #80 OBJECTID board_size
< #80 ASSIGN
< #80 OBJECTID size
< #80 ';'
< #81 '}'
< #82 ELSE
< #82 IF
< #82 OBJECTID size
< #82 '='
< #82 INT_CONST 25
< #82 THEN
< #83 '{'
< #84 OBJECTID rows
< #84 ASSIGN
< #84 INT_CONST 5
< #84 ';'
< #85 OBJECTID columns
< #85 ASSIGN
< #85 INT_CONST 5
< #85 ';'
< #86 OBJECTID board_size
< #86 ASSIGN
< #86 OBJECTID size
< #86 ';'
< #87 '}'
< #88 ELSE
< #88 IF
< #88 OBJECTID size
< #88 '='
< #88 INT_CONST 28
< #88 THEN
< #89 '{'
< #90 OBJECTID rows
< #90 ASSIGN
< #90 INT_CONST 7
< #90 ';'
< #91 OBJECTID columns
< #91 ASSIGN
< #91 INT_CONST 4
< #91 ';'
< #92 OBJECTID board_size
< #92 ASSIGN
< #92 OBJECTID size
< #92 ';'
< #93 '}'
< #94 ELSE
< #95 '{'
< #96 OBJECTID rows
< #96 ASSIGN
< #96 INT_CONST 5
< #96 ';'
< #97 OBJECTID columns
< #97 ASSIGN
< #97 INT_CONST 5
< #97 ';'
< #98 OBJECTID board_size
< #98 ASSIGN
< #98 OBJECTID size
< #98 ';'
< #99 '}'
< #100 FI
< #100 FI
< #100 FI
< #100 FI
< #100 FI
< #100 FI
< #100 ';'
< #101 OBJECTID self
< #101 ';'
< #102 '}'
< #103 ')'
< #104 '}'
< #104 ';'
< #106 '}'
< #106 ';'
< #110 CLASS
< #110 TYPEID CellularAutomaton
< #110 INHERITS
< #110 TYPEID Board
< #110 '{'
< #111 OBJECTID population_map
< #111 ':'
< #111 TYPEID String
< #111 ';'
< #113 OBJECTID init
< #113 '('
< #113 OBJECTID map
< #113 ':'
< #113 TYPEID String
< #113 ')'
< #113 ':'
< #113 TYPEID SELF_TYPE
< #113 '{'
< #114 '{'
< #115 OBJECTID population_map
< #115 ASSIGN
< #115 OBJECTID map
< #115 ';'
< #116 OBJECTID board_init
< #116 '('
< #116 OBJECTID map
< #116 ')'
< #116 ';'
< #117 OBJECTID self
< #117 ';'
< #118 '}'
< #119 '}'
< #119 ';'
< #124 OBJECTID print
< #124 '('
< #124 ')'
< #124 ':'
< #124 TYPEID SELF_TYPE
< #124 '{'
< #126 '('
< #126 LET
< #126 OBJECTID i
< #126 ':'
< #126 TYPEID Int
< #126 ASSIGN
< #126 INT_CONST 0
< #126 IN
< #127 '('
< #127 LET
< #127 OBJECTID num
< #127 ':'
< #127 TYPEID Int
< #127 ASSIGN
< #127 OBJECTID board_size
< #127 IN
< #128 '{'
< #129 OBJECTID out_string
< #129 '('
< #129 STR_CONST "\n"
< #129 ')'
< #129 ';'
< #130 WHILE
< #130 OBJECTID i
< #130 '<'
< #130 OBJECTID num
< #130 LOOP
< #131 '{'
< #132 OBJECTID out_string
< #132 '('
< #132 OBJECTID population_map
< #132 '.'
< #132 OBJECTID substr
< #132 '('
< #132 OBJECTID i
< #132 ','
< #132 OBJECTID columns
< #132 ')'
< #132 ')'
< #132 ';'
< #133 OBJECTID out_string
< #133 '('
< #133 STR_CONST "\n"
< #133 ')'
< #133 ';'
< #134 OBJECTID i
< #134 ASSIGN
< #134 OBJECTID i
< #134 '+'
< #134 OBJECTID columns
< #134 ';'
< #135 '}'
< #136 POOL
< #136 ';'
< #137 OBJECTID out_string
< #137 '('
< #137 STR_CONST "\n"
< #137 ')'
< #137 ';'
< #138 OBJECTID self
< #138 ';'
< #139 '}'
< #140 ')'
< #140 ')'
< #141 '}'
< #141 ';'
< #143 OBJECTID num_cells
< #143 '('
< #143 ')'
< #143 ':'
< #143 TYPEID Int
< #143 '{'
< #144 OBJECTID population_map
< #144 '.'
< #144 OBJECTID length
< #144 '('
< #144 ')'
< #145 '}'
< #145 ';'
< #147 OBJECTID cell
< #147 '('
< #147 OBJECTID position
< #147 ':'
< #147 TYPEID Int
< #147 ')'
< #147 ':'
< #147 TYPEID String
< #147 '{'
< #148 IF
< #148 OBJECTID board_size
< #148 '-'
< #148 INT_CONST 1
< #148 '<'
< #148 OBJECTID position
< #148 THEN
< #149 STR_CONST " "
< #150 ELSE
< #151 OBJECTID population_map
< #151 '.'
< #151 OBJECTID substr
< #151 '('
< #151 OBJECTID position
< #151 ','
< #151 INT_CONST 1
< #151 ')'
< #152 FI
< #153 '}'
< #153 ';'
< #155 OBJECTID north
< #155 '('
< #155 OBJECTID position
< #155 ':'
< #155 TYPEID Int
< #155 ')'
< #155 ':'
< #155 TYPEID String
< #155 '{'
< #156 IF
< #156 '('
< #156 OBJECTID position
< #156 '-'
< #156 OBJECTID columns
< #156 ')'
< #156 '<'
< #156 INT_CONST 0
< #156 THEN
< #157 STR_CONST " "
< #158 ELSE
< #159 OBJECTID cell
< #159 '('
< #159 OBJECTID position
< #159 '-'
< #159 OBJECTID columns
< #159 ')'
< #160 FI
< #161 '}'
< #161 ';'
< #163 OBJECTID south
< #163 '('
< #163 OBJECTID position
< #163 ':'
< #163 TYPEID Int
< #163 ')'
< #163 ':'
< #163 TYPEID String
< #163 '{'
< #164 IF
< #164 OBJECTID board_size
< #164 '<'
< #164 '('
< #164 OBJECTID position
< #164 '+'
< #164 OBJECTID columns
< #164 ')'
< #164 THEN
< #165 STR_CONST " "
< #166 ELSE
< #167 OBJECTID cell
< #167 '('
< #167 OBJECTID position
< #167 '+'
< #167 OBJECTID columns
< #167 ')'
< #168 FI
< #169 '}'
< #169 ';'
< #171 OBJECTID east
< #171 '('
< #171 OBJECTID position
< #171 ':'
< #171 TYPEID Int
< #171 ')'
< #171 ':'
< #171 TYPEID String
< #171 '{'
< #172 IF
< #172 '('
< #172 '('
< #172 '('
< #172 OBJECTID position
< #172 '+'
< #172 INT_CONST 1
< #172 ')'
< #172 '/'
< #172 OBJECTID columns
< #172 ')'
< #172 '*'
< #172 OBJECTID columns
< #172 ')'
< #172 '='
< #172 '('
< #172 OBJECTID position
< #172 '+'
< #172 INT_CONST 1
< #172 ')'
< #172 THEN
< #173 STR_CONST " "
< #174 ELSE
< #175 OBJECTID cell
< #175 '('
< #175 OBJECTID position
< #175 '+'
< #175 INT_CONST 1
< #175 ')'
< #176 FI
< #177 '}'
< #177 ';'
< #179 OBJECTID west
< #179 '('
< #179 OBJECTID position
< #179 ':'
< #179 TYPEID Int
< #179 ')'
< #179 ':'
< #179 TYPEID String
< #179 '{'
< #180 IF
< #180 OBJECTID position
< #180 '='
< #180 INT_CONST 0
< #180 THEN
< #181 STR_CONST " "
< #182 ELSE
< #183 IF
< #183 '('
< #183 '('
< #183 OBJECTID position
< #183 '/'
< #183 OBJECTID columns
< #183 ')'
< #183 '*'
< #183 OBJECTID columns
< #183 ')'
< #183 '='
< #183 OBJECTID position
< #183 THEN
< #184 STR_CONST " "
< #185 ELSE
< #186 OBJECTID cell
< #186 '('
< #186 OBJECTID position
< #186 '-'
< #186 INT_CONST 1
< #186 ')'
< #187 FI
< #187 FI
< #188 '}'
< #188 ';'
< #190 OBJECTID northwest
< #190 '('
< #190 OBJECTID position
< #190 ':'
< #190 TYPEID Int
< #190 ')'
< #190 ':'
< #190 TYPEID String
< #190 '{'
< #191 IF
< #191 '('
< #191 OBJECTID position
< #191 '-'
< #191 OBJECTID columns
< #191 ')'
< #191 '<'
< #191 INT_CONST 0
< #191 THEN
< #192 STR_CONST " "
< #193 ELSE
< #193 IF
< #193 '('
< #193 '('
< #193 OBJECTID position
< #193 '/'
< #193 OBJECTID columns
< #193 ')'
< #193 '*'
< #193 OBJECTID columns
< #193 ')'
< #193 '='
< #193 OBJECTID position
< #193 THEN
< #194 STR_CONST " "
< #195 ELSE
< #196 OBJECTID north
< #196 '('
< #196 OBJECTID position
< #196 '-'
< #196 INT_CONST 1
< #196 ')'
< #197 FI
< #197 FI
< #198 '}'
< #198 ';'
< #200 OBJECTID northeast
< #200 '('
< #200 OBJECTID position
< #200 ':'
< #200 TYPEID Int
< #200 ')'
< #200 ':'
< #200 TYPEID String
< #200 '{'
< #201 IF
< #201 '('
< #201 OBJECTID position
< #201 '-'
< #201 OBJECTID columns
< #201 ')'
< #201 '<'
< #201 INT_CONST 0
< #201 THEN
< #202 STR_CONST " "
< #203 ELSE
< #203 IF
< #203 '('
< #203 '('
< #203 '('
< #203 OBJECTID position
< #203 '+'
< #203 INT_CONST 1
< #203 ')'
< #203 '/'
< #203 OBJECTID columns
< #203 ')'
< #203 '*'
< #203 OBJECTID columns
< #203 ')'
< #203 '='
< #203 '('
< #203 OBJECTID position
< #203 '+'
< #203 INT_CONST 1
< #203 ')'
< #203 THEN
< #204 STR_CONST " "
< #205 ELSE
< #206 OBJECTID north
< #206 '('
< #206 OBJECTID position
< #206 '+'
< #206 INT_CONST 1
< #206 ')'
< #207 FI
< #207 FI
< #208 '}'
< #208 ';'
< #210 OBJECTID southeast
< #210 '('
< #210 OBJECTID position
< #210 ':'
< #210 TYPEID Int
< #210 ')'
< #210 ':'
< #210 TYPEID String
< #210 '{'
< #211 IF
< #211 OBJECTID board_size
< #211 '<'
< #211 '('
< #211 OBJECTID position
< #211 '+'
< #211 OBJECTID columns
< #211 ')'
< #211 THEN
< #212 STR_CONST " "
< #213 ELSE
< #213 IF
< #213 '('
< #213 '('
< #213 '('
< #213 OBJECTID position
< #213 '+'
< #213 INT_CONST 1
< #213 ')'
< #213 '/'
< #213 OBJECTID columns
< #213 ')'
< #213 '*'
< #213 OBJECTID columns
< #213 ')'
< #213 '='
< #213 '('
< #213 OBJECTID position
< #213 '+'
< #213 INT_CONST 1
< #213 ')'
< #213 THEN
< #214 STR_CONST " "
< #215 ELSE
< #216 OBJECTID south
< #216 '('
< #216 OBJECTID position
< #216 '+'
< #216 INT_CONST 1
< #216 ')'
< #217 FI
< #217 FI
< #218 '}'
< #218 ';'
< #220 OBJECTID southwest
< #220 '('
< #220 OBJECTID position
< #220 ':'
< #220 TYPEID Int
< #220 ')'
< #220 ':'
< #220 TYPEID String
< #220 '{'
< #221 IF
< #221 OBJECTID board_size
< #221 '<'
< #221 '('
< #221 OBJECTID position
< #221 '+'
< #221 OBJECTID columns
< #221 ')'
< #221 THEN
< #222 STR_CONST " "
< #223 ELSE
< #223 IF
< #223 '('
< #223 '('
< #223 OBJECTID position
< #223 '/'
< #223 OBJECTID columns
< #223 ')'
< #223 '*'
< #223 OBJECTID columns
< #223 ')'
< #223 '='
< #223 OBJECTID position
< #223 THEN
< #224 STR_CONST " "
< #225 ELSE
< #226 OBJECTID south
< #226 '('
< #226 OBJECTID position
< #226 '-'
< #226 INT_CONST 1
< #226 ')'
< #227 FI
< #227 FI
< #228 '}'
< #228 ';'
< #230 OBJECTID neighbors
< #230 '('
< #230 OBJECTID position
< #230 ':'
< #230 TYPEID Int
< #230 ')'
< #230 ':'
< #230 TYPEID Int
< #230 '{'
< #231 '{'
< #232 IF
< #232 OBJECTID north
< #232 '('
< #232 OBJECTID position
< #232 ')'
< #232 '='
< #232 STR_CONST "X"
< #232 THEN
< #232 INT_CONST 1
< #232 ELSE
< #232 INT_CONST 0
< #232 FI
< #233 '+'
< #233 IF
< #233 OBJECTID south
< #233 '('
< #233 OBJECTID position
< #233 ')'
< #233 '='
< #233 STR_CONST "X"
< #233 THEN
< #233 INT_CONST 1
< #233 ELSE
< #233 INT_CONST 0
< #233 FI
< #234 '+'
< #234 IF
< #234 OBJECTID east
< #234 '('
< #234 OBJECTID position
< #234 ')'
< #234 '='
< #234 STR_CONST "X"
< #234 THEN
< #234 INT_CONST 1
< #234 ELSE
< #234 INT_CONST 0
< #234 FI
< #235 '+'
< #235 IF
< #235 OBJECTID west
< #235 '('
< #235 OBJECTID position
< #235 ')'
< #235 '='
< #235 STR_CONST "X"
< #235 THEN
< #235 INT_CONST 1
< #235 ELSE
< #235 INT_CONST 0
< #235 FI
< #236 '+'
< #236 IF
< #236 OBJECTID northeast
< #236 '('
< #236 OBJECTID position
< #236 ')'
< #236 '='
< #236 STR_CONST "X"
< #236 THEN
< #236 INT_CONST 1
< #236 ELSE
< #236 INT_CONST 0
< #236 FI
< #237 '+'
< #237 IF
< #237 OBJECTID northwest
< #237 '('
< #237 OBJECTID position
< #237 ')'
< #237 '='
< #237 STR_CONST "X"
< #237 THEN
< #237 INT_CONST 1
< #237 ELSE
< #237 INT_CONST 0
< #237 FI
< #238 '+'
< #238 IF
< #238 OBJECTID southeast
< #238 '('
< #238 OBJECTID position
< #238 ')'
< #238 '='
< #238 STR_CONST "X"
< #238 THEN
< #238 INT_CONST 1
< #238 ELSE
< #238 INT_CONST 0
< #238 FI
< #239 '+'
< #239 IF
< #239 OBJECTID southwest
< #239 '('
< #239 OBJECTID position
< #239 ')'
< #239 '='
< #239 STR_CONST "X"
< #239 THEN
< #239 INT_CONST 1
< #239 ELSE
< #239 INT_CONST 0
< #239 FI
< #239 ';'
< #240 '}'
< #241 '}'
< #241 ';'
< #247 OBJECTID cell_at_next_evolution
< #247 '('
< #247 OBJECTID position
< #247 ':'
< #247 TYPEID Int
< #247 ')'
< #247 ':'
< #247 TYPEID String
< #247 '{'
< #249 IF
< #249 OBJECTID neighbors
< #249 '('
< #249 OBJECTID position
< #249 ')'
< #249 '='
< #249 INT_CONST 3
< #249 THEN
< #250 STR_CONST "X"
< #251 ELSE
< #252 IF
< #252 OBJECTID neighbors
< #252 '('
< #252 OBJECTID position
< #252 ')'
< #252 '='
< #252 INT_CONST 2
< #252 THEN
< #253 IF
< #253 OBJECTID cell
< #253 '('
< #253 OBJECTID position
< #253 ')'
< #253 '='
< #253 STR_CONST "X"
< #253 THEN
< #254 STR_CONST "X"
< #255 ELSE
< #256 STR_CONST "-"
< #257 FI
< #258 ELSE
< #259 STR_CONST "-"
< #260 FI
< #260 FI
< #261 '}'
< #261 ';'
< #264 OBJECTID evolve
< #264 '('
< #264 ')'
< #264 ':'
< #264 TYPEID SELF_TYPE
< #264 '{'
< #265 '('
< #265 LET
< #265 OBJECTID position
< #265 ':'
< #265 TYPEID Int
< #265 ASSIGN
< #265 INT_CONST 0
< #265 IN
< #266 '('
< #266 LET
< #266 OBJECTID num
< #266 ':'
< #266 TYPEID Int
< #266 ASSIGN
< #266 OBJECTID num_cells
< #266 '('
< #266 ')'
< #266 IN
< #267 '('
< #267 LET
< #267 OBJECTID temp
< #267 ':'
< #267 TYPEID String
< #267 IN
< #268 '{'
< #269 WHILE
< #269 OBJECTID position
< #269 '<'
< #269 OBJECTID num
< #269 LOOP
< #270 '{'
< #271 OBJECTID temp
< #271 ASSIGN
< #271 OBJECTID temp
< #271 '.'
< #271 OBJECTID concat
< #271 '('
< #271 OBJECTID cell_at_next_evolution
< #271 '('
< #271 OBJECTID position
< #271 ')'
< #271 ')'
< #271 ';'
< #272 OBJECTID position
< #272 ASSIGN
< #272 OBJECTID position
< #272 '+'
< #272 INT_CONST 1
< #272 ';'
< #273 '}'
< #274 POOL
< #274 ';'
< #275 OBJECTID population_map
< #275 ASSIGN
< #275 OBJECTID temp
< #275 ';'
< #276 OBJECTID self
< #276 ';'
< #277 '}'
< #278 ')'
< #278 ')'
< #278 ')'
< #279 '}'
< #279 ';'
< #284 OBJECTID option
< #284 '('
< #284 ')'
< #284 ':'
< #284 TYPEID String
< #284 '{'
< #285 '{'
< #286 '('
< #286 LET
< #286 OBJECTID num
< #286 ':'
< #286 TYPEID Int
< #286 IN
< #287 '{'
< #288 OBJECTID out_string
< #288 '('
< #288 STR_CONST "\nPlease chose a number:\n"
< #288 ')'
< #288 ';'
< #289 OBJECTID out_string
< #289 '('
< #289 STR_CONST "\t1: A cross\n"
< #289 ')'
< #289 ';'
< #290 OBJECTID out_string
< #290 '('
< #290 STR_CONST "\t2: A slash from the upper left to lower right\n"
< #290 ')'
< #290 ';'
< #291 OBJECTID out_string
< #291 '('
< #291 STR_CONST "\t3: A slash from the upper right to lower left\n"
< #291 ')'
< #291 ';'
< #292 OBJECTID out_string
< #292 '('
< #292 STR_CONST "\t4: An X\n"
< #292 ')'
< #292 ';'
< #293 OBJECTID out_string
< #293 '('
< #293 STR_CONST "\t5: A greater than sign \n"
< #293 ')'
< #293 ';'
< #294 OBJECTID out_string
< #294 '('
< #294 STR_CONST "\t6: A less than sign\n"
< #294 ')'
< #294 ';'
< #295 OBJECTID out_string
< #295 '('
< #295 STR_CONST "\t7: Two greater than signs\n"
< #295 ')'
< #295 ';'
< #296 OBJECTID out_string
< #296 '('
< #296 STR_CONST "\t8: Two less than signs\n"
< #296 ')'
< #296 ';'
< #297 OBJECTID out_string
< #297 '('
< #297 STR_CONST "\t9: A 'V'\n"
< #297 ')'
< #297 ';'
< #298 OBJECTID out_string
< #298 '('
< #298 STR_CONST "\t10: An inverse 'V'\n"
< #298 ')'
< #298 ';'
< #299 OBJECTID out_string
< #299 '('
< #299 STR_CONST "\t11: Numbers 9 and 10 combined\n"
< #299 ')'
< #299 ';'
< #300 OBJECTID out_string
< #300 '('
< #300 STR_CONST "\t12: A full grid\n"
< #300 ')'
< #300 ';'
< #301 OBJECTID out_string
< #301 '('
< #301 STR_CONST "\t13: A 'T'\n"
< #301 ')'
< #301 ';'
< #302 OBJECTID out_string
< #302 '('
< #302 STR_CONST "\t14: A plus '+'\n"
< #302 ')'
< #302 ';'
< #303 OBJECTID out_string
< #303 '('
< #303 STR_CONST "\t15: A 'W'\n"
< #303 ')'
< #303 ';'
< #304 OBJECTID out_string
< #304 '('
< #304 STR_CONST "\t16: An 'M'\n"
< #304 ')'
< #304 ';'
< #305 OBJECTID out_string
< #305 '('
< #305 STR_CONST "\t17: An 'E'\n"
< #305 ')'
< #305 ';'
< #306 OBJECTID out_string
< #306 '('
< #306 STR_CONST "\t18: A '3'\n"
< #306 ')'
< #306 ';'
< #307 OBJECTID out_string
< #307 '('
< #307 STR_CONST "\t19: An 'O'\n"
< #307 ')'
< #307 ';'
< #308 OBJECTID out_string
< #308 '('
< #308 STR_CONST "\t20: An '8'\n"
< #308 ')'
< #308 ';'
< #309 OBJECTID out_string
< #309 '('
< #309 STR_CONST "\t21: An 'S'\n"
< #309 ')'
< #309 ';'
< #310 OBJECTID out_string
< #310 '('
< #310 STR_CONST "Your choice => "
< #310 ')'
< #310 ';'
< #311 OBJECTID num
< #311 ASSIGN
< #311 OBJECTID in_int
< #311 '('
< #311 ')'
< #311 ';'
< #312 OBJECTID out_string
< #312 '('
< #312 STR_CONST "\n"
< #312 ')'
< #312 ';'
< #313 IF
< #313 OBJECTID num
< #313 '='
< #313 INT_CONST 1
< #313 THEN
< #314 STR_CONST " XX  XXXX XXXX  XX  "
< #315 ELSE
< #315 IF
< #315 OBJECTID num
< #315 '='
< #315 INT_CONST 2
< #315 THEN
< #316 STR_CONST "    X   X   X   X   X    "
< #317 ELSE
< #317 IF
< #317 OBJECTID num
< #317 '='
< #317 INT_CONST 3
< #317 THEN
< #318 STR_CONST "X     X     X     X     X"
< #319 ELSE
< #319 IF
< #319 OBJECTID num
< #319 '='
< #319 INT_CONST 4
< #319 THEN
< #320 STR_CONST "X   X X X   X   X X X   X"
< #321 ELSE
< #321 IF
< #321 OBJECTID num
< #321 '='
< #321 INT_CONST 5
< #321 THEN
< #322 STR_CONST "X     X     X   X   X    "
< #323 ELSE
< #323 IF
< #323 OBJECTID num
< #323 '='
< #323 INT_CONST 6
< #323 THEN
< #324 STR_CONST "    X   X   X     X     X"
< #325 ELSE
< #325 IF
< #325 OBJECTID num
< #325 '='
< #325 INT_CONST 7
< #325 THEN
< #326 STR_CONST "X  X  X  XX  X      "
< #327 ELSE
< #327 IF
< #327 OBJECTID num
< #327 '='
< #327 INT_CONST 8
< #327 THEN
< #328 STR_CONST " X  XX  X  X  X     "
< #329 ELSE
< #329 IF
< #329 OBJECTID num
< #329 '='
< #329 INT_CONST 9
< #329 THEN
< #330 STR_CONST "X   X X X   X  "
< #331 ELSE
< #331 IF
< #331 OBJECTID num
< #331 '='
< #331 INT_CONST 10
< #331 THEN
< #332 STR_CONST "  X   X X X   X"
< #333 ELSE
< #333 IF
< #333 OBJECTID num
< #333 '='
< #333 INT_CONST 11
< #333 THEN
< #334 STR_CONST "X X X X X X X X"
< #335 ELSE
< #335 IF
< #335 OBJECTID num
< #335 '='
< #335 INT_CONST 12
< #335 THEN
< #336 STR_CONST "XXXXXXXXXXXXXXXXXXXXXXXXX"
< #337 ELSE
< #337 IF
< #337 OBJECTID num
< #337 '='
< #337 INT_CONST 13
< #337 THEN
< #338 STR_CONST "XXXXX  X    X    X    X  "
< #339 ELSE
< #339 IF
< #339 OBJECTID num
< #339 '='
< #339 INT_CONST 14
< #339 THEN
< #340 STR_CONST "  X    X  XXXXX  X    X  "
< #341 ELSE
< #341 IF
< #341 OBJECTID num
< #341 '='
< #341 INT_CONST 15
< #341 THEN
< #342 STR_CONST "X     X X X X   X X  "
< #343 ELSE
< #343 IF
< #343 OBJECTID num
< #343 '='
< #343 INT_CONST 16
< #343 THEN
< #344 STR_CONST "  X X   X X X X     X"
< #345 ELSE
< #345 IF
< #345 OBJECTID num
< #345 '='
< #345 INT_CONST 17
< #345 THEN
< #346 STR_CONST "XXXXX   X   XXXXX   X   XXXX"
< #347 ELSE
< #347 IF
< #347 OBJECTID num
< #347 '='
< #347 INT_CONST 18
< #347 THEN
< #348 STR_CONST "XXX    X   X  X    X   XXXX "
< #349 ELSE
< #349 IF
< #349 OBJECTID num
< #349 '='
< #349 INT_CONST 19
< #349 THEN
< #350 STR_CONST " XX X  XX  X XX "
< #351 ELSE
< #351 IF
< #351 OBJECTID num
< #351 '='
< #351 INT_CONST 20
< #351 THEN
< #352 STR_CONST " XX X  XX  X XX X  XX  X XX "
< #353 ELSE
< #353 IF
< #353 OBJECTID num
< #353 '='
< #353 INT_CONST 21
< #353 THEN
< #354 STR_CONST " XXXX   X    XX    X   XXXX "
< #355 ELSE
< #356 STR_CONST "                         "
< #357 FI
< #357 FI
< #357 FI
< #357 FI
< #357 FI
< #357 FI
< #357 FI
< #357 FI
< #357 FI
< #357 FI
< #357 FI
< #357 FI
< #357 FI
< #357 FI
< #357 FI
< #357 FI
< #357 FI
< #357 FI
< #357 FI
< #357 FI
< #357 FI
< #357 ';'
< #358 '}'
< #359 ')'
< #359 ';'
< #360 '}'
< #361 '}'
< #361 ';'
< #366 OBJECTID prompt
< #366 '('
< #366 ')'
< #366 ':'
< #366 TYPEID Bool
< #366 '{'
< #367 '{'
< #368 '('
< #368 LET
< #368 OBJECTID ans
< #368 ':'
< #368 TYPEID String
< #368 IN
< #369 '{'
< #370 OBJECTID out_string
< #370 '('
< #370 STR_CONST "Would you like to continue with the next generation? \n"
< #370 ')'
< #370 ';'
< #371 OBJECTID out_string
< #371 '('
< #371 STR_CONST "Please use lowercase y or n for your answer [y]: "
< #371 ')'
< #371 ';'
< #372 OBJECTID ans
< #372 ASSIGN
< #372 OBJECTID in_string
< #372 '('
< #372 ')'
< #372 ';'
< #373 OBJECTID out_string
< #373 '('
< #373 STR_CONST "\n"
< #373 ')'
< #373 ';'
< #374 IF
< #374 OBJECTID ans
< #374 '='
< #374 STR_CONST "n"
< #374 THEN
< #375 BOOL_CONST false
< #376 ELSE
< #377 BOOL_CONST true
< #378 FI
< #378 ';'
< #379 '}'
< #380 ')'
< #380 ';'
< #381 '}'
< #382 '}'
< #382 ';'
< #385 OBJECTID prompt2
< #385 '('
< #385 ')'
< #385 ':'
< #385 TYPEID Bool
< #385 '{'
< #386 '('
< #386 LET
< #386 OBJECTID ans
< #386 ':'
< #386 TYPEID String
< #386 IN
< #387 '{'
< #388 OBJECTID out_string
< #388 '('
< #388 STR_CONST "\n\n"
< #388 ')'
< #388 ';'
< #389 OBJECTID out_string
< #389 '('
< #389 STR_CONST "Would you like to choose a background pattern? \n"
< #389 ')'
< #389 ';'
< #390 OBJECTID out_string
< #390 '('
< #390 STR_CONST "Please use lowercase y or n for your answer [n]: "
< #390 ')'
< #390 ';'
< #391 OBJECTID ans
< #391 ASSIGN
< #391 OBJECTID in_string
< #391 '('
< #391 ')'
< #391 ';'
< #392 IF
< #392 OBJECTID ans
< #392 '='
< #392 STR_CONST "y"
< #392 THEN
< #393 BOOL_CONST true
< #394 ELSE
< #395 BOOL_CONST false
< #396 FI
< #396 ';'
< #397 '}'
< #398 ')'
< #399 '}'
< #399 ';'
< #402 '}'
< #402 ';'
< #404 CLASS
< #404 TYPEID Main
< #404 INHERITS
< #404 TYPEID CellularAutomaton
< #404 '{'
< #405 OBJECTID cells
< #405 ':'
< #405 TYPEID CellularAutomaton
< #405 ';'
< #407 OBJECTID main
< #407 '('
< #407 ')'
< #407 ':'
< #407 TYPEID SELF_TYPE
< #407 '{'
< #408 '{'
< #409 '('
< #409 LET
< #409 OBJECTID continue
< #409 ':'
< #409 TYPEID Bool
< #409 IN
< #410 '('
< #410 LET
< #410 OBJECTID choice
< #410 ':'
< #410 TYPEID String
< #410 IN
< #411 '{'
< #412 OBJECTID out_string
< #412 '('
< #412 STR_CONST "Welcome to the Game of Life.\n"
< #412 ')'
< #412 ';'
< #413 OBJECTID out_string
< #413 '('
< #413 STR_CONST "There are many initial states to choose from. \n"
< #413 ')'
< #413 ';'
< #414 WHILE
< #414 OBJECTID prompt2
< #414 '('
< #414 ')'
< #414 LOOP
< #415 '{'
< #416 OBJECTID continue
< #416 ASSIGN
< #416 BOOL_CONST true
< #416 ';'
< #417 OBJECTID choice
< #417 ASSIGN
< #417 OBJECTID option
< #417 '('
< #417 ')'
< #417 ';'
< #418 OBJECTID cells
< #418 ASSIGN
< #418 '('
< #418 NEW
< #418 TYPEID CellularAutomaton
< #418 ')'
< #418 '.'
< #418 OBJECTID init
< #418 '('
< #418 OBJECTID choice
< #418 ')'
< #418 ';'
< #419 OBJECTID cells
< #419 '.'
< #419 OBJECTID print
< #419 '('
< #419 ')'
< #419 ';'
< #420 WHILE
< #420 OBJECTID continue
< #420 LOOP
< #421 IF
< #421 OBJECTID prompt
< #421 '('
< #421 ')'
< #421 THEN
< #422 '{'
< #423 OBJECTID cells
< #423 '.'
< #423 OBJECTID evolve
< #423 '('
< #423 ')'
< #423 ';'
< #424 OBJECTID cells
< #424 '.'
< #424 OBJECTID print
< #424 '('
< #424 ')'
< #424 ';'
< #425 '}'
< #426 ELSE
< #427 OBJECTID continue
< #427 ASSIGN
< #427 BOOL_CONST false
< #428 FI
< #429 POOL
< #429 ';'
< #430 '}'
< #431 POOL
< #431 ';'
< #432 OBJECTID self
< #432 ';'
< #433 '}'
< #433 ')'
< #433 ')'
< #433 ';'
< #433 '}'
< #434 '}'
< #434 ';'
< #435 '}'
< #435 ';'
---
> (* The Game of Life 
>    Tendo Kayiira, Summer '95
>    With code taken from /private/cool/class/examples/cells.cl
> 
>  This introduction was taken off the internet. It gives a brief 
>  description of the Game Of Life. It also gives the rules by which 
>  this particular game follows.
> 
> 	Introduction
> 
>    John Conway's Game of Life is a mathematical amusement, but it 
>    is also much more: an insight into how a system of simple 
>    cellualar automata can create complex, odd, and often aesthetically 
>    pleasing patterns. It is played on a cartesian grid of cells
>    which are either 'on' or 'off' The game gets it's name from the 
>    similarity between the behaviour of these cells and the behaviour 
>    of living organisms.
> 
>  The Rules
> 
>   The playfield is a cartesian grid of arbitrary size. Each cell in 
>   this grid can be in an 'on' state or an 'off' state. On each 'turn' 
>   (called a generation,) the state of each cell changes simultaneously 
>   depending on it's state and the state of all cells adjacent to it.
> 
>    For 'on' cells, 
>       If the cell has 0 or 1 neighbours which are 'on', the cell turns 
>         'off'. ('dies of loneliness') 
>       If the cell has 2 or 3 neighbours which are 'on', the cell stays 
>         'on'. (nothing happens to that cell) 
>       If the cell has 4, 5, 6, 7, 8, or 9 neighbours which are 'on', 
>         the cell turns 'off'. ('dies of overcrowding') 
> 
>    For 'off' cells, 
>       If the cell has 0, 1, 2, 4, 5, 6, 7, 8, or 9 neighbours which 
>         are 'on', the cell stays 'off'. (nothing happens to that cell) 
>       If the cell has 3 neighbours which are 'on', the cell turns 
>         'on'. (3 neighbouring 'alive' cells 'give birth' to a fourth.) 
> 
>    Repeat for as many generations as desired. 
> 
>  *)
>  
> 
> class Board inherits IO { 
>  
>  rows : Int;
>  columns : Int;
>  board_size : Int;
> 
>  size_of_board(initial : String) : Int {
>    initial.length()
>  };
> 
>  board_init(start : String) : SELF_TYPE {
>    (let size :Int  <- size_of_board(start) in
>     {
> 	if size = 15 then
> 	 {
> 	  rows <- 3;
> 	  columns <- 5;
> 	  board_size <- size;
> 	 }
> 	else if size = 16 then
> 	  {
> 	  rows <- 4;
> 	  columns <- 4;
> 	  board_size <- size;
> 	 }
> 	else if size = 20 then
> 	 {
> 	  rows <- 4;
> 	  columns <- 5;
> 	  board_size <- size;
> 	 }
> 	else if size = 21 then
> 	 {
> 	  rows <- 3;
> 	  columns <- 7;
> 	  board_size <- size;
> 	 }
> 	else if size = 25 then
> 	 {
> 	  rows <- 5;
> 	  columns <- 5;
> 	  board_size <- size;
> 	 }
> 	else if size = 28 then
> 	 {
> 	  rows <- 7;
> 	  columns <- 4;
> 	  board_size <- size;
> 	 }
> 	else 	-- If none of the above fit, then just give 
> 	 {  -- the configuration of the most common board
> 	  rows <- 5;
> 	  columns <- 5;
> 	  board_size <- size;
> 	 }
> 	fi fi fi fi fi fi;
> 	self;
>     }
>    )
>  };
> 
> };
> 
> 
> 
> class CellularAutomaton inherits Board {
>     population_map : String;
>    
>     init(map : String) : SELF_TYPE {
>         {
>             population_map <- map;
> 	    board_init(map);
>             self;
>         }
>     };
> 
> 
> 
>    
>     print() : SELF_TYPE {
>         
> 	(let i : Int <- 0 in
> 	(let num : Int <- board_size in
> 	{
>  	out_string("\n");
> 	 while i < num loop
>            {
> 	    out_string(population_map.substr(i,columns));
> 	    out_string("\n"); 
> 	    i <- i + columns;
> 	   }
> 	 pool;
>  	out_string("\n");
> 	self;
> 	}
> 	) ) 
>     };
>    
>     num_cells() : Int {
>         population_map.length()
>     };
>    
>     cell(position : Int) : String {
> 	if board_size - 1 < position then
> 		" "
> 	else 
>         	population_map.substr(position, 1)
> 	fi
>     };
>    
>  north(position : Int): String {
> 	if (position - columns) < 0 then
> 	      " "	                       
> 	else
> 	   cell(position - columns)
> 	fi
>  };
> 
>  south(position : Int): String {
> 	if board_size < (position + columns) then
> 	      " "                     
> 	else
> 	   cell(position + columns)
> 	fi
>  };
> 
>  east(position : Int): String {
> 	if (((position + 1) /columns ) * columns) = (position + 1) then
> 	      " "                
> 	else
> 	   cell(position + 1)
> 	fi 
>  };
> 
>  west(position : Int): String {
> 	if position = 0 then
> 	      " "
> 	else 
> 	   if ((position / columns) * columns) = position then
> 	      " "
> 	   else
> 	      cell(position - 1)
> 	fi fi
>  };
> 
>  northwest(position : Int): String {
> 	if (position - columns) < 0 then
> 	      " "	                       
> 	else  if ((position / columns) * columns) = position then
> 	      " "
> 	      else
> 		north(position - 1)
> 	fi fi
>  };
> 
>  northeast(position : Int): String {
> 	if (position - columns) < 0 then
> 	      " "	
> 	else if (((position + 1) /columns ) * columns) = (position + 1) then
> 	      " "     
> 	     else
> 	       north(position + 1)
> 	fi fi
>  };
> 
>  southeast(position : Int): String {
> 	if board_size < (position + columns) then
> 	      " "                     
> 	else if (((position + 1) /columns ) * columns) = (position + 1) then
> 	       " "                
> 	     else
> 	       south(position + 1)
> 	fi fi
>  };
> 
>  southwest(position : Int): String {
> 	if board_size < (position + columns) then
> 	      " "                     
> 	else  if ((position / columns) * columns) = position then
> 	      " "
> 	      else
> 	       south(position - 1)
> 	fi fi
>  };
> 
>  neighbors(position: Int): Int { 
>  	{
> 	     if north(position) = "X" then 1 else 0 fi
> 	     + if south(position) = "X" then 1 else 0 fi
>  	     + if east(position) = "X" then 1 else 0 fi
>  	     + if west(position) = "X" then 1 else 0 fi
> 	     + if northeast(position) = "X" then 1 else 0 fi
> 	     + if northwest(position) = "X" then 1 else 0 fi
>  	     + if southeast(position) = "X" then 1 else 0 fi
> 	     + if southwest(position) = "X" then 1 else 0 fi;
> 	 }
>  };
> 
>  
> (* A cell will live if 2 or 3 of it's neighbors are alive. It dies 
>    otherwise. A cell is born if only 3 of it's neighbors are alive. *)
>     
>     cell_at_next_evolution(position : Int) : String {
> 
> 	if neighbors(position) = 3 then
> 		"X"
> 	else
> 	   if neighbors(position) = 2 then
> 		if cell(position) = "X" then
> 			"X"
> 		else
> 			"-"
> 	        fi
> 	   else
> 		"-"
> 	fi fi
>     };
>   
> 
>     evolve() : SELF_TYPE {
>         (let position : Int <- 0 in
>         (let num : Int <- num_cells() in
>         (let temp : String in
>             {
>                 while position < num loop
>                     {
>                         temp <- temp.concat(cell_at_next_evolution(position));
>                         position <- position + 1;
>                     }
>                 pool;
>                 population_map <- temp;
>                 self;
>             }
>         ) ) )
>     };
> 
> (* This is where the background pattern is detremined by the user. More 
>    patterns can be added as long as whoever adds keeps the board either
>    3x5, 4x5, 5x5, 3x7, 7x4, 4x4 with the row first then column. *) 
>  option(): String {
>  {
>   (let num : Int in
>    {
>    out_string("\nPlease chose a number:\n");
>    out_string("\t1: A cross\n"); 
>    out_string("\t2: A slash from the upper left to lower right\n");
>    out_string("\t3: A slash from the upper right to lower left\n"); 
>    out_string("\t4: An X\n"); 
>    out_string("\t5: A greater than sign \n"); 
>    out_string("\t6: A less than sign\n"); 
>    out_string("\t7: Two greater than signs\n"); 
>    out_string("\t8: Two less than signs\n"); 
>    out_string("\t9: A 'V'\n"); 
>    out_string("\t10: An inverse 'V'\n"); 
>    out_string("\t11: Numbers 9 and 10 combined\n"); 
>    out_string("\t12: A full grid\n"); 
>    out_string("\t13: A 'T'\n");
>    out_string("\t14: A plus '+'\n");
>    out_string("\t15: A 'W'\n");
>    out_string("\t16: An 'M'\n");
>    out_string("\t17: An 'E'\n");
>    out_string("\t18: A '3'\n");
>    out_string("\t19: An 'O'\n");
>    out_string("\t20: An '8'\n");
>    out_string("\t21: An 'S'\n");
>    out_string("Your choice #1 DARROW
>  ");
>    num <- in_int();
>    out_string("\n");
>    if num = 1 then
>     	" XX  XXXX XXXX  XX  "
>    else if num = 2 then
>     	"    X   X   X   X   X    "
>    else if num = 3 then
>     	"X     X     X     X     X"
>    else if num = 4 then
> 	"X   X X X   X   X X X   X"
>    else if num = 5 then
> 	"X     X     X   X   X    "
>    else if num = 6 then
> 	"    X   X   X     X     X"
>    else if num = 7 then
> 	"X  X  X  XX  X      "
>    else if num = 8 then
> 	" X  XX  X  X  X     "
>    else if num = 9 then
> 	"X   X X X   X  "
>    else if num = 10 then
> 	"  X   X X X   X"
>    else if num = 11 then
> 	"X X X X X X X X"
>    else if num = 12 then
> 	"XXXXXXXXXXXXXXXXXXXXXXXXX"
>    else if num = 13 then
>     	"XXXXX  X    X    X    X  "
>    else if num = 14 then
>     	"  X    X  XXXXX  X    X  "
>    else if num = 15 then
>     	"X     X X X X   X X  "
>    else if num = 16 then
>     	"  X X   X X X X     X"
>    else if num = 17 then
> 	"XXXXX   X   XXXXX   X   XXXX"
>    else if num = 18 then
> 	"XXX    X   X  X    X   XXXX "
>    else if num = 19 then
> 	" XX X  XX  X XX "
>    else if num = 20 then
> 	" XX X  XX  X XX X  XX  X XX "
>    else if num = 21 then
> 	" XXXX   X    XX    X   XXXX "
>    else
> 	"                         "
>   fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi;
>     }
>    );
>  }
>  };
> 
> 
> 
> 
>  prompt() : Bool { 
>  {
>   (let ans : String in
>    {
>    out_string("Would you like to continue with the next generation? \n");
>    out_string("Please use lowercase y or n for your answer [y]: ");
>    ans <- in_string();
>    out_string("\n");
>    if ans = "n" then 
> 	false
>    else
> 	true
>    fi;
>    }
>   );
>  }
>  };
> 
> 
>  prompt2() : Bool { 
>   (let ans : String in
>    {
>    out_string("\n\n");
>    out_string("Would you like to choose a background pattern? \n");
>    out_string("Please use lowercase y or n for your answer [n]: ");
>    ans <- in_string();
>    if ans = "y" then 
> 	true
>    else
> 	false
>    fi;
>    }
>   )
>  };
> 
> 
> };
> 
> class Main inherits CellularAutomaton {
>     cells : CellularAutomaton;
>    
>     main() : SELF_TYPE {
>         {
> 	 (let continue : Bool  in
> 	  (let choice : String  in
> 	   {
> 	   out_string("Welcome to the Game of Life.\n");
> 	   out_string("There are many initial states to choose from. \n");
> 	   while prompt2() loop
> 	    {
> 	     continue <- true;
> 	     choice <- option();
> 	     cells <- (new CellularAutomaton).init(choice);
> 	     cells.print();
>              while continue loop
> 		if prompt() then
>                     {
>                         cells.evolve();
>                         cells.print();
>                     }
> 		else
> 		    continue <- false
> 	      fi 
>                 pool;
>             }
>             pool;
> 	    self;
>       }  ) ); }
>     };
> };
> 
pass!
---------  Test  ../../examples/list.cl  ---------
2,265c2,142
< #26 CLASS
< #26 TYPEID List
< #26 '{'
< #29 OBJECTID isNil
< #29 '('
< #29 ')'
< #29 ':'
< #29 TYPEID Bool
< #29 '{'
< #29 BOOL_CONST true
< #29 '}'
< #29 ';'
< #35 OBJECTID head
< #35 '('
< #35 ')'
< #35 ':'
< #35 TYPEID Int
< #35 '{'
< #35 '{'
< #35 OBJECTID abort
< #35 '('
< #35 ')'
< #35 ';'
< #35 INT_CONST 0
< #35 ';'
< #35 '}'
< #35 '}'
< #35 ';'
< #40 OBJECTID tail
< #40 '('
< #40 ')'
< #40 ':'
< #40 TYPEID List
< #40 '{'
< #40 '{'
< #40 OBJECTID abort
< #40 '('
< #40 ')'
< #40 ';'
< #40 OBJECTID self
< #40 ';'
< #40 '}'
< #40 '}'
< #40 ';'
< #49 OBJECTID cons
< #49 '('
< #49 OBJECTID i
< #49 ':'
< #49 TYPEID Int
< #49 ')'
< #49 ':'
< #49 TYPEID List
< #49 '{'
< #50 '('
< #50 NEW
< #50 TYPEID Cons
< #50 ')'
< #50 '.'
< #50 OBJECTID init
< #50 '('
< #50 OBJECTID i
< #50 ','
< #50 OBJECTID self
< #50 ')'
< #51 '}'
< #51 ';'
< #53 '}'
< #53 ';'
< #70 CLASS
< #70 TYPEID Cons
< #70 INHERITS
< #70 TYPEID List
< #70 '{'
< #72 OBJECTID car
< #72 ':'
< #72 TYPEID Int
< #72 ';'
< #74 OBJECTID cdr
< #74 ':'
< #74 TYPEID List
< #74 ';'
< #76 OBJECTID isNil
< #76 '('
< #76 ')'
< #76 ':'
< #76 TYPEID Bool
< #76 '{'
< #76 BOOL_CONST false
< #76 '}'
< #76 ';'
< #78 OBJECTID head
< #78 '('
< #78 ')'
< #78 ':'
< #78 TYPEID Int
< #78 '{'
< #78 OBJECTID car
< #78 '}'
< #78 ';'
< #80 OBJECTID tail
< #80 '('
< #80 ')'
< #80 ':'
< #80 TYPEID List
< #80 '{'
< #80 OBJECTID cdr
< #80 '}'
< #80 ';'
< #82 OBJECTID init
< #82 '('
< #82 OBJECTID i
< #82 ':'
< #82 TYPEID Int
< #82 ','
< #82 OBJECTID rest
< #82 ':'
< #82 TYPEID List
< #82 ')'
< #82 ':'
< #82 TYPEID List
< #82 '{'
< #83 '{'
< #84 OBJECTID car
< #84 ASSIGN
< #84 OBJECTID i
< #84 ';'
< #85 OBJECTID cdr
< #85 ASSIGN
< #85 OBJECTID rest
< #85 ';'
< #86 OBJECTID self
< #86 ';'
< #87 '}'
< #88 '}'
< #88 ';'
< #90 '}'
< #90 ';'
< #100 CLASS
< #100 TYPEID Main
< #100 INHERITS
< #100 TYPEID IO
< #100 '{'
< #102 OBJECTID mylist
< #102 ':'
< #102 TYPEID List
< #102 ';'
< #107 OBJECTID print_list
< #107 '('
< #107 OBJECTID l
< #107 ':'
< #107 TYPEID List
< #107 ')'
< #107 ':'
< #107 TYPEID Object
< #107 '{'
< #108 IF
< #108 OBJECTID l
< #108 '.'
< #108 OBJECTID isNil
< #108 '('
< #108 ')'
< #108 THEN
< #108 OBJECTID out_string
< #108 '('
< #108 STR_CONST "\n"
< #108 ')'
< #109 ELSE
< #109 '{'
< #110 OBJECTID out_int
< #110 '('
< #110 OBJECTID l
< #110 '.'
< #110 OBJECTID head
< #110 '('
< #110 ')'
< #110 ')'
< #110 ';'
< #111 OBJECTID out_string
< #111 '('
< #111 STR_CONST " "
< #111 ')'
< #111 ';'
< #112 OBJECTID print_list
< #112 '('
< #112 OBJECTID l
< #112 '.'
< #112 OBJECTID tail
< #112 '('
< #112 ')'
< #112 ')'
< #112 ';'
< #113 '}'
< #114 FI
< #115 '}'
< #115 ';'
< #126 OBJECTID main
< #126 '('
< #126 ')'
< #126 ':'
< #126 TYPEID Object
< #126 '{'
< #127 '{'
< #128 OBJECTID mylist
< #128 ASSIGN
< #128 NEW
< #128 TYPEID List
< #128 '.'
< #128 OBJECTID cons
< #128 '('
< #128 INT_CONST 1
< #128 ')'
< #128 '.'
< #128 OBJECTID cons
< #128 '('
< #128 INT_CONST 2
< #128 ')'
< #128 '.'
< #128 OBJECTID cons
< #128 '('
< #128 INT_CONST 3
< #128 ')'
< #128 '.'
< #128 OBJECTID cons
< #128 '('
< #128 INT_CONST 4
< #128 ')'
< #128 '.'
< #128 OBJECTID cons
< #128 '('
< #128 INT_CONST 5
< #128 ')'
< #128 ';'
< #129 WHILE
< #129 '('
< #129 NOT
< #129 OBJECTID mylist
< #129 '.'
< #129 OBJECTID isNil
< #129 '('
< #129 ')'
< #129 ')'
< #129 LOOP
< #130 '{'
< #131 OBJECTID print_list
< #131 '('
< #131 OBJECTID mylist
< #131 ')'
< #131 ';'
< #132 OBJECTID mylist
< #132 ASSIGN
< #132 OBJECTID mylist
< #132 '.'
< #132 OBJECTID tail
< #132 '('
< #132 ')'
< #132 ';'
< #133 '}'
< #134 POOL
< #134 ';'
< #135 '}'
< #136 '}'
< #136 ';'
< #138 '}'
< #138 ';'
---
> (*
>  *  This file shows how to implement a list data type for lists of integers.
>  *  It makes use of INHERITANCE and DYNAMIC DISPATCH.
>  *
>  *  The List class has 4 operations defined on List objects. If 'l' is
>  *  a list, then the methods dispatched on 'l' have the following effects:
>  *
>  *    isNil() : Bool		Returns true if 'l' is empty, false otherwise.
>  *    head()  : Int		Returns the integer at the head of 'l'.
>  *				If 'l' is empty, execution aborts.
>  *    tail()  : List		Returns the remainder of the 'l',
>  *				i.e. without the first element.
>  *    cons(i : Int) : List	Return a new list containing i as the
>  *				first element, followed by the
>  *				elements in 'l'.
>  *
>  *  There are 2 kinds of lists, the empty list and a non-empty
>  *  list. We can think of the non-empty list as a specialization of
>  *  the empty list.
>  *  The class List defines the operations on empty list. The class
>  *  Cons inherits from List and redefines things to handle non-empty
>  *  lists.
>  *)
> 
> 
> class List {
>    -- Define operations on empty lists.
> 
>    isNil() : Bool { true };
> 
>    -- Since abort() has return type Object and head() has return type
>    -- Int, we need to have an Int as the result of the method body,
>    -- even though abort() never returns.
> 
>    head()  : Int { { abort(); 0; } };
> 
>    -- As for head(), the self is just to make sure the return type of
>    -- tail() is correct.
> 
>    tail()  : List { { abort(); self; } };
> 
>    -- When we cons and element onto the empty list we get a non-empty
>    -- list. The (new Cons) expression creates a new list cell of class
>    -- Cons, which is initialized by a dispatch to init().
>    -- The result of init() is an element of class Cons, but it
>    -- conforms to the return type List, because Cons is a subclass of
>    -- List.
> 
>    cons(i : Int) : List {
>       (new Cons).init(i, self)
>    };
> 
> };
> 
> 
> (*
>  *  Cons inherits all operations from List. We can reuse only the cons
>  *  method though, because adding an element to the front of an emtpy
>  *  list is the same as adding it to the front of a non empty
>  *  list. All other methods have to be redefined, since the behaviour
>  *  for them is different from the empty list.
>  *
>  *  Cons needs two attributes to hold the integer of this list
>  *  cell and to hold the rest of the list.
>  *
>  *  The init() method is used by the cons() method to initialize the
>  *  cell.
>  *)
> 
> class Cons inherits List {
> 
>    car : Int;	-- The element in this list cell
> 
>    cdr : List;	-- The rest of the list
> 
>    isNil() : Bool { false };
> 
>    head()  : Int { car };
> 
>    tail()  : List { cdr };
> 
>    init(i : Int, rest : List) : List {
>       {
> 	 car <- i;
> 	 cdr <- rest;
> 	 self;
>       }
>    };
> 
> };
> 
> 
> 
> (*
>  *  The Main class shows how to use the List class. It creates a small
>  *  list and then repeatedly prints out its elements and takes off the
>  *  first element of the list.
>  *)
> 
> class Main inherits IO {
> 
>    mylist : List;
> 
>    -- Print all elements of the list. Calls itself recursively with
>    -- the tail of the list, until the end of the list is reached.
> 
>    print_list(l : List) : Object {
>       if l.isNil() then out_string("\n")
>                    else {
> 			   out_int(l.head());
> 			   out_string(" ");
> 			   print_list(l.tail());
> 		        }
>       fi
>    };
> 
>    -- Note how the dynamic dispatch mechanism is responsible to end
>    -- the while loop. As long as mylist is bound to an object of 
>    -- dynamic type Cons, the dispatch to isNil calls the isNil method of
>    -- the Cons class, which returns false. However when we reach the
>    -- end of the list, mylist gets bound to the object that was
>    -- created by the (new List) expression. This object is of dynamic type
>    -- List, and thus the method isNil in the List class is called and
>    -- returns true.
> 
>    main() : Object {
>       {
> 	 mylist <- new List.cons(1).cons(2).cons(3).cons(4).cons(5);
> 	 while (not mylist.isNil()) loop
> 	    {
> 	       print_list(mylist);
> 	       mylist <- mylist.tail();
> 	    }
> 	 pool;
>       }
>    };
> 
> };
> 
> 
> 
pass!
---------  Test  ../../examples/new_complex.cl  ---------
2,282c2,80
< #1 CLASS
< #1 TYPEID Main
< #1 INHERITS
< #1 TYPEID IO
< #1 '{'
< #2 OBJECTID main
< #2 '('
< #2 ')'
< #2 ':'
< #2 TYPEID SELF_TYPE
< #2 '{'
< #3 '('
< #3 LET
< #3 OBJECTID c
< #3 ':'
< #3 TYPEID Complex
< #3 ASSIGN
< #3 '('
< #3 NEW
< #3 TYPEID Complex
< #3 ')'
< #3 '.'
< #3 OBJECTID init
< #3 '('
< #3 INT_CONST 1
< #3 ','
< #3 INT_CONST 1
< #3 ')'
< #3 IN
< #4 '{'
< #6 IF
< #6 OBJECTID c
< #6 '.'
< #6 OBJECTID reflect_X
< #6 '('
< #6 ')'
< #6 '='
< #6 OBJECTID c
< #6 '.'
< #6 OBJECTID reflect_0
< #6 '('
< #6 ')'
< #7 THEN
< #7 OBJECTID out_string
< #7 '('
< #7 STR_CONST "=)\n"
< #7 ')'
< #8 ELSE
< #8 OBJECTID out_string
< #8 '('
< #8 STR_CONST "=(\n"
< #8 ')'
< #9 FI
< #9 ';'
< #11 IF
< #11 OBJECTID c
< #11 '.'
< #11 OBJECTID reflect_X
< #11 '('
< #11 ')'
< #11 '.'
< #11 OBJECTID reflect_Y
< #11 '('
< #11 ')'
< #11 '.'
< #11 OBJECTID equal
< #11 '('
< #11 OBJECTID c
< #11 '.'
< #11 OBJECTID reflect_0
< #11 '('
< #11 ')'
< #11 ')'
< #12 THEN
< #12 OBJECTID out_string
< #12 '('
< #12 STR_CONST "=)\n"
< #12 ')'
< #13 ELSE
< #13 OBJECTID out_string
< #13 '('
< #13 STR_CONST "=(\n"
< #13 ')'
< #14 FI
< #14 ';'
< #15 '}'
< #16 ')'
< #17 '}'
< #17 ';'
< #18 '}'
< #18 ';'
< #20 CLASS
< #20 TYPEID Complex
< #20 INHERITS
< #20 TYPEID IO
< #20 '{'
< #21 OBJECTID x
< #21 ':'
< #21 TYPEID Int
< #21 ';'
< #22 OBJECTID y
< #22 ':'
< #22 TYPEID Int
< #22 ';'
< #24 OBJECTID init
< #24 '('
< #24 OBJECTID a
< #24 ':'
< #24 TYPEID Int
< #24 ','
< #24 OBJECTID b
< #24 ':'
< #24 TYPEID Int
< #24 ')'
< #24 ':'
< #24 TYPEID Complex
< #24 '{'
< #25 '{'
< #26 OBJECTID x
< #26 '='
< #26 OBJECTID a
< #26 ';'
< #27 OBJECTID y
< #27 '='
< #27 OBJECTID b
< #27 ';'
< #28 OBJECTID self
< #28 ';'
< #29 '}'
< #30 '}'
< #30 ';'
< #32 OBJECTID print
< #32 '('
< #32 ')'
< #32 ':'
< #32 TYPEID Object
< #32 '{'
< #33 IF
< #33 OBJECTID y
< #33 '='
< #33 INT_CONST 0
< #34 THEN
< #34 OBJECTID out_int
< #34 '('
< #34 OBJECTID x
< #34 ')'
< #35 ELSE
< #35 OBJECTID out_int
< #35 '('
< #35 OBJECTID x
< #35 ')'
< #35 '.'
< #35 OBJECTID out_string
< #35 '('
< #35 STR_CONST "+"
< #35 ')'
< #35 '.'
< #35 OBJECTID out_int
< #35 '('
< #35 OBJECTID y
< #35 ')'
< #35 '.'
< #35 OBJECTID out_string
< #35 '('
< #35 STR_CONST "I"
< #35 ')'
< #36 FI
< #37 '}'
< #37 ';'
< #39 OBJECTID reflect_0
< #39 '('
< #39 ')'
< #39 ':'
< #39 TYPEID Complex
< #39 '{'
< #40 '{'
< #41 OBJECTID x
< #41 '='
< #41 '~'
< #41 OBJECTID x
< #41 ';'
< #42 OBJECTID y
< #42 '='
< #42 '~'
< #42 OBJECTID y
< #42 ';'
< #43 OBJECTID self
< #43 ';'
< #44 '}'
< #45 '}'
< #45 ';'
< #47 OBJECTID reflect_X
< #47 '('
< #47 ')'
< #47 ':'
< #47 TYPEID Complex
< #47 '{'
< #48 '{'
< #49 OBJECTID y
< #49 '='
< #49 '~'
< #49 OBJECTID y
< #49 ';'
< #50 OBJECTID self
< #50 ';'
< #51 '}'
< #52 '}'
< #52 ';'
< #54 OBJECTID reflect_Y
< #54 '('
< #54 ')'
< #54 ':'
< #54 TYPEID Complex
< #54 '{'
< #55 '{'
< #56 OBJECTID x
< #56 '='
< #56 '~'
< #56 OBJECTID x
< #56 ';'
< #57 OBJECTID self
< #57 ';'
< #58 '}'
< #59 '}'
< #59 ';'
< #61 OBJECTID equal
< #61 '('
< #61 OBJECTID d
< #61 ':'
< #61 TYPEID Complex
< #61 ')'
< #61 ':'
< #61 TYPEID Bool
< #61 '{'
< #62 IF
< #62 OBJECTID x
< #62 '='
< #62 OBJECTID d
< #62 '.'
< #62 OBJECTID x_value
< #62 '('
< #62 ')'
< #63 THEN
< #64 IF
< #64 OBJECTID y
< #64 '='
< #64 OBJECTID d
< #64 '.'
< #64 OBJECTID y_value
< #64 '('
< #64 ')'
< #65 THEN
< #65 BOOL_CONST true
< #66 ELSE
< #66 BOOL_CONST false
< #67 FI
< #68 ELSE
< #68 BOOL_CONST false
< #69 FI
< #70 '}'
< #70 ';'
< #72 OBJECTID x_value
< #72 '('
< #72 ')'
< #72 ':'
< #72 TYPEID Int
< #72 '{'
< #73 OBJECTID x
< #74 '}'
< #74 ';'
< #76 OBJECTID y_value
< #76 '('
< #76 ')'
< #76 ':'
< #76 TYPEID Int
< #76 '{'
< #77 OBJECTID y
< #78 '}'
< #78 ';'
< #79 '}'
< #79 ';'
---
> class Main inherits IO {
>     main() : SELF_TYPE {
> 	(let c : Complex <- (new Complex).init(1, 1) in
> 	    {
> 	        -- trivially equal (see CoolAid)
> 	        if c.reflect_X() = c.reflect_0()
> 	        then out_string("=)\n")
> 	        else out_string("=(\n")
> 	        fi;
> 		-- equal
> 	        if c.reflect_X().reflect_Y().equal(c.reflect_0())
> 	        then out_string("=)\n")
> 	        else out_string("=(\n")
> 	        fi;
> 	    }
> 	)
>     };
> };
> 
> class Complex inherits IO {
>     x : Int;
>     y : Int;
> 
>     init(a : Int, b : Int) : Complex {
> 	{
> 	    x = a;
> 	    y = b;
> 	    self;
> 	}
>     };
> 
>     print() : Object {
> 	if y = 0
> 	then out_int(x)
> 	else out_int(x).out_string("+").out_int(y).out_string("I")
> 	fi
>     };
> 
>     reflect_0() : Complex {
> 	{
> 	    x = ~x;
> 	    y = ~y;
> 	    self;
> 	}
>     };
> 
>     reflect_X() : Complex {
> 	{
> 	    y = ~y;
> 	    self;
> 	}
>     };
> 
>     reflect_Y() : Complex {
> 	{
> 	    x = ~x;
> 	    self;
> 	}
>     };
> 
>     equal(d : Complex) : Bool {
> 	if x = d.x_value()
> 	then
> 	    if y = d.y_value()
> 	    then true
> 	    else false
> 	    fi
> 	else false
> 	fi
>     };
> 
>     x_value() : Int {
> 	x
>     };
> 
>     y_value() : Int {
> 	y
>     };
> };
pass!
---------  Test  ../../examples/palindrome.cl  ---------
2,131c2,26
< #1 CLASS
< #1 TYPEID Main
< #1 INHERITS
< #1 TYPEID IO
< #1 '{'
< #2 OBJECTID pal
< #2 '('
< #2 OBJECTID s
< #2 ':'
< #2 TYPEID String
< #2 ')'
< #2 ':'
< #2 TYPEID Bool
< #2 '{'
< #3 IF
< #3 OBJECTID s
< #3 '.'
< #3 OBJECTID length
< #3 '('
< #3 ')'
< #3 '='
< #3 INT_CONST 0
< #4 THEN
< #4 BOOL_CONST true
< #5 ELSE
< #5 IF
< #5 OBJECTID s
< #5 '.'
< #5 OBJECTID length
< #5 '('
< #5 ')'
< #5 '='
< #5 INT_CONST 1
< #6 THEN
< #6 BOOL_CONST true
< #7 ELSE
< #7 IF
< #7 OBJECTID s
< #7 '.'
< #7 OBJECTID substr
< #7 '('
< #7 INT_CONST 0
< #7 ','
< #7 INT_CONST 1
< #7 ')'
< #7 '='
< #7 OBJECTID s
< #7 '.'
< #7 OBJECTID substr
< #7 '('
< #7 OBJECTID s
< #7 '.'
< #7 OBJECTID length
< #7 '('
< #7 ')'
< #7 '-'
< #7 INT_CONST 1
< #7 ','
< #7 INT_CONST 1
< #7 ')'
< #8 THEN
< #8 OBJECTID pal
< #8 '('
< #8 OBJECTID s
< #8 '.'
< #8 OBJECTID substr
< #8 '('
< #8 INT_CONST 1
< #8 ','
< #8 OBJECTID s
< #8 '.'
< #8 OBJECTID length
< #8 '('
< #8 ')'
< #8 '-'
< #8 INT_CONST 2
< #8 ')'
< #8 ')'
< #9 ELSE
< #9 BOOL_CONST false
< #10 FI
< #10 FI
< #10 FI
< #11 '}'
< #11 ';'
< #13 OBJECTID i
< #13 ':'
< #13 TYPEID Int
< #13 ';'
< #15 OBJECTID main
< #15 '('
< #15 ')'
< #15 ':'
< #15 TYPEID SELF_TYPE
< #15 '{'
< #16 '{'
< #17 OBJECTID i
< #17 ASSIGN
< #17 '~'
< #17 INT_CONST 1
< #17 ';'
< #18 OBJECTID out_string
< #18 '('
< #18 STR_CONST "enter a string\n"
< #18 ')'
< #18 ';'
< #19 IF
< #19 OBJECTID pal
< #19 '('
< #19 OBJECTID in_string
< #19 '('
< #19 ')'
< #19 ')'
< #20 THEN
< #20 OBJECTID out_string
< #20 '('
< #20 STR_CONST "that was a palindrome\n"
< #20 ')'
< #21 ELSE
< #21 OBJECTID out_string
< #21 '('
< #21 STR_CONST "that was not a palindrome\n"
< #21 ')'
< #22 FI
< #22 ';'
< #23 '}'
< #24 '}'
< #24 ';'
< #25 '}'
< #25 ';'
---
> class Main inherits IO {
>     pal(s : String) : Bool {
> 	if s.length() = 0
> 	then true
> 	else if s.length() = 1
> 	then true
> 	else if s.substr(0, 1) = s.substr(s.length() - 1, 1)
> 	then pal(s.substr(1, s.length() -2))
> 	else false
> 	fi fi fi
>     };
> 
>     i : Int;
> 
>     main() : SELF_TYPE {
> 	{
>             i <- ~1;
> 	    out_string("enter a string\n");
> 	    if pal(in_string())
> 	    then out_string("that was a palindrome\n")
> 	    else out_string("that was not a palindrome\n")
> 	    fi;
> 	}
>     };
> };
pass!
---------  Test  ../../examples/primes.cl  ---------
2,145c2,85
< #27 CLASS
< #27 TYPEID Main
< #27 INHERITS
< #27 TYPEID IO
< #27 '{'
< #29 OBJECTID main
< #29 '('
< #29 ')'
< #29 ':'
< #29 TYPEID Int
< #29 '{'
< #30 INT_CONST 0
< #31 '}'
< #31 ';'
< #33 OBJECTID out
< #33 ':'
< #33 TYPEID Int
< #33 ASSIGN
< #34 '{'
< #35 OBJECTID out_string
< #35 '('
< #35 STR_CONST "2 is trivially prime.\n"
< #35 ')'
< #35 ';'
< #36 INT_CONST 2
< #36 ';'
< #37 '}'
< #37 ';'
< #39 OBJECTID testee
< #39 ':'
< #39 TYPEID Int
< #39 ASSIGN
< #39 OBJECTID out
< #39 ';'
< #41 OBJECTID divisor
< #41 ':'
< #41 TYPEID Int
< #41 ';'
< #43 OBJECTID stop
< #43 ':'
< #43 TYPEID Int
< #43 ASSIGN
< #43 INT_CONST 500
< #43 ';'
< #45 OBJECTID m
< #45 ':'
< #45 TYPEID Object
< #45 ASSIGN
< #46 WHILE
< #46 BOOL_CONST true
< #46 LOOP
< #47 '{'
< #49 OBJECTID testee
< #49 ASSIGN
< #49 OBJECTID testee
< #49 '+'
< #49 INT_CONST 1
< #49 ';'
< #50 OBJECTID divisor
< #50 ASSIGN
< #50 INT_CONST 2
< #50 ';'
< #52 WHILE
< #53 IF
< #53 OBJECTID testee
< #53 '<'
< #53 OBJECTID divisor
< #53 '*'
< #53 OBJECTID divisor
< #54 THEN
< #54 BOOL_CONST false
< #55 ELSE
< #55 IF
< #55 OBJECTID testee
< #55 '-'
< #55 OBJECTID divisor
< #55 '*'
< #55 '('
< #55 OBJECTID testee
< #55 '/'
< #55 OBJECTID divisor
< #55 ')'
< #55 '='
< #55 INT_CONST 0
< #56 THEN
< #56 BOOL_CONST false
< #57 ELSE
< #57 BOOL_CONST true
< #58 FI
< #58 FI
< #59 LOOP
< #60 OBJECTID divisor
< #60 ASSIGN
< #60 OBJECTID divisor
< #60 '+'
< #60 INT_CONST 1
< #61 POOL
< #61 ';'
< #63 IF
< #63 OBJECTID testee
< #63 '<'
< #63 OBJECTID divisor
< #63 '*'
< #63 OBJECTID divisor
< #64 THEN
< #65 '{'
< #66 OBJECTID out
< #66 ASSIGN
< #66 OBJECTID testee
< #66 ';'
< #67 OBJECTID out_int
< #67 '('
< #67 OBJECTID out
< #67 ')'
< #67 ';'
< #68 OBJECTID out_string
< #68 '('
< #68 STR_CONST " is prime.\n"
< #68 ')'
< #68 ';'
< #69 '}'
< #70 ELSE
< #71 INT_CONST 0
< #72 FI
< #72 ';'
< #74 IF
< #74 OBJECTID stop
< #74 LE
< #74 OBJECTID testee
< #74 THEN
< #75 STR_CONST "halt"
< #75 '.'
< #75 OBJECTID abort
< #75 '('
< #75 ')'
< #76 ELSE
< #77 STR_CONST "continue"
< #78 FI
< #78 ';'
< #80 '}'
< #81 POOL
< #81 ';'
< #83 '}'
< #83 ';'
---
> 
> (*
>  * methodless-primes.cl
>  *
>  * Designed by Jesse H. Willett, jhw@cory, 11103234, with 
>  *             Istvan Siposs, isiposs@cory, 12342921.
>  *
>  * This program generates primes in order without using any methods.
>  * Actually, it does use three methods: those of IO to print out each prime, and
>  * abort() to halt the program.  These methods are incidental, however,
>  * to the information-processing functionality of the program.  We
>  * could regard the attribute 'out's sequential values as our output,
>  * and the string "halt" as our terminate signal.
>  *
>  * Naturally, using Cool this way is a real waste, basically reducing it 
>  * to assembly without the benefit of compilation.  
>  *
>  * There could even be a subroutine-like construction, in that different
>  * code could be in the assign fields of attributes of other classes,
>  * and it could be executed by calling 'new Sub', but no parameters
>  * could be passed to the subroutine, and it could only return itself.
>  * but returning itself would be useless since we couldn't call methods
>  * and the only operators we have are for Int and Bool, which do nothing
>  * interesting when we initialize them!
>  *)
> 
> class Main inherits IO {
> 
>   main() : Int {	-- main() is an atrophied method so we can parse. 
>     0 
>   };
> 
>   out : Int <-		-- out is our 'output'.  It's values are the primes.
>     {
>       out_string("2 is trivially prime.\n");
>       2;
>     };
> 
>   testee : Int <- out;	-- testee is a number to be tested for primeness.   
> 
>   divisor : Int;	-- divisor is a number which may factor testee.
> 
>   stop : Int <- 500;	-- stop is an arbitrary value limiting testee. 	
> 
>   m : Object <-		-- m supplants the main method.
>     while true loop 
>       {
> 
>         testee <- testee + 1;
>         divisor <- 2;
> 
>         while 
>           if testee < divisor * divisor 
>             then false 		-- can stop if divisor > sqrt(testee).
> 	  else if testee - divisor*(testee/divisor) = 0 
>             then false 		-- can stop if divisor divides testee. 
>             else true
>           fi fi     
>         loop 
>           divisor <- divisor + 1
>         pool;        
> 
>         if testee < divisor * divisor	-- which reason did we stop for?
>         then 	-- testee has no factors less than sqrt(testee).
>           {
>             out <- testee;	-- we could think of out itself as the output.
>             out_int(out); 
>             out_string(" is prime.\n");
>           }
>         else	-- the loop halted on testee/divisor = 0, testee isn't prime.
>           0	-- testee isn't prime, do nothing.
> 	fi;   	
> 
>         if stop <= testee then 
>           "halt".abort()	-- we could think of "halt" as SIGTERM.
>         else 
>           "continue"
>         fi;       
> 
>       } 
>     pool;
> 
> }; (* end of Main *)
> 
pass!
---------  Test  ../../examples/sort_list.cl  ---------
2,538c2,149
< #24 CLASS
< #24 TYPEID List
< #24 INHERITS
< #24 TYPEID IO
< #24 '{'
< #28 OBJECTID isNil
< #28 '('
< #28 ')'
< #28 ':'
< #28 TYPEID Bool
< #28 '{'
< #28 '{'
< #28 OBJECTID abort
< #28 '('
< #28 ')'
< #28 ';'
< #28 BOOL_CONST true
< #28 ';'
< #28 '}'
< #28 '}'
< #28 ';'
< #30 OBJECTID cons
< #30 '('
< #30 OBJECTID hd
< #30 ':'
< #30 TYPEID Int
< #30 ')'
< #30 ':'
< #30 TYPEID Cons
< #30 '{'
< #31 '('
< #31 LET
< #31 OBJECTID new_cell
< #31 ':'
< #31 TYPEID Cons
< #31 ASSIGN
< #31 NEW
< #31 TYPEID Cons
< #31 IN
< #32 OBJECTID new_cell
< #32 '.'
< #32 OBJECTID init
< #32 '('
< #32 OBJECTID hd
< #32 ','
< #32 OBJECTID self
< #32 ')'
< #33 ')'
< #34 '}'
< #34 ';'
< #41 OBJECTID car
< #41 '('
< #41 ')'
< #41 ':'
< #41 TYPEID Int
< #41 '{'
< #41 '{'
< #41 OBJECTID abort
< #41 '('
< #41 ')'
< #41 ';'
< #41 NEW
< #41 TYPEID Int
< #41 ';'
< #41 '}'
< #41 '}'
< #41 ';'
< #43 OBJECTID cdr
< #43 '('
< #43 ')'
< #43 ':'
< #43 TYPEID List
< #43 '{'
< #43 '{'
< #43 OBJECTID abort
< #43 '('
< #43 ')'
< #43 ';'
< #43 NEW
< #43 TYPEID List
< #43 ';'
< #43 '}'
< #43 '}'
< #43 ';'
< #45 OBJECTID rev
< #45 '('
< #45 ')'
< #45 ':'
< #45 TYPEID List
< #45 '{'
< #45 OBJECTID cdr
< #45 '('
< #45 ')'
< #45 '}'
< #45 ';'
< #47 OBJECTID sort
< #47 '('
< #47 ')'
< #47 ':'
< #47 TYPEID List
< #47 '{'
< #47 OBJECTID cdr
< #47 '('
< #47 ')'
< #47 '}'
< #47 ';'
< #49 OBJECTID insert
< #49 '('
< #49 OBJECTID i
< #49 ':'
< #49 TYPEID Int
< #49 ')'
< #49 ':'
< #49 TYPEID List
< #49 '{'
< #49 OBJECTID cdr
< #49 '('
< #49 ')'
< #49 '}'
< #49 ';'
< #51 OBJECTID rcons
< #51 '('
< #51 OBJECTID i
< #51 ':'
< #51 TYPEID Int
< #51 ')'
< #51 ':'
< #51 TYPEID List
< #51 '{'
< #51 OBJECTID cdr
< #51 '('
< #51 ')'
< #51 '}'
< #51 ';'
< #53 OBJECTID print_list
< #53 '('
< #53 ')'
< #53 ':'
< #53 TYPEID Object
< #53 '{'
< #53 OBJECTID abort
< #53 '('
< #53 ')'
< #53 '}'
< #53 ';'
< #54 '}'
< #54 ';'
< #56 CLASS
< #56 TYPEID Cons
< #56 INHERITS
< #56 TYPEID List
< #56 '{'
< #57 OBJECTID xcar
< #57 ':'
< #57 TYPEID Int
< #57 ';'
< #58 OBJECTID xcdr
< #58 ':'
< #58 TYPEID List
< #58 ';'
< #62 OBJECTID isNil
< #62 '('
< #62 ')'
< #62 ':'
< #62 TYPEID Bool
< #62 '{'
< #62 BOOL_CONST false
< #62 '}'
< #62 ';'
< #64 OBJECTID init
< #64 '('
< #64 OBJECTID hd
< #64 ':'
< #64 TYPEID Int
< #64 ','
< #64 OBJECTID tl
< #64 ':'
< #64 TYPEID List
< #64 ')'
< #64 ':'
< #64 TYPEID Cons
< #64 '{'
< #65 '{'
< #66 OBJECTID xcar
< #66 ASSIGN
< #66 OBJECTID hd
< #66 ';'
< #67 OBJECTID xcdr
< #67 ASSIGN
< #67 OBJECTID tl
< #67 ';'
< #68 OBJECTID self
< #68 ';'
< #69 '}'
< #70 '}'
< #70 ';'
< #72 OBJECTID car
< #72 '('
< #72 ')'
< #72 ':'
< #72 TYPEID Int
< #72 '{'
< #72 OBJECTID xcar
< #72 '}'
< #72 ';'
< #74 OBJECTID cdr
< #74 '('
< #74 ')'
< #74 ':'
< #74 TYPEID List
< #74 '{'
< #74 OBJECTID xcdr
< #74 '}'
< #74 ';'
< #76 OBJECTID rev
< #76 '('
< #76 ')'
< #76 ':'
< #76 TYPEID List
< #76 '{'
< #76 '('
< #76 OBJECTID xcdr
< #76 '.'
< #76 OBJECTID rev
< #76 '('
< #76 ')'
< #76 ')'
< #76 '.'
< #76 OBJECTID rcons
< #76 '('
< #76 OBJECTID xcar
< #76 ')'
< #76 '}'
< #76 ';'
< #78 OBJECTID sort
< #78 '('
< #78 ')'
< #78 ':'
< #78 TYPEID List
< #78 '{'
< #78 '('
< #78 OBJECTID xcdr
< #78 '.'
< #78 OBJECTID sort
< #78 '('
< #78 ')'
< #78 ')'
< #78 '.'
< #78 OBJECTID insert
< #78 '('
< #78 OBJECTID xcar
< #78 ')'
< #78 '}'
< #78 ';'
< #80 OBJECTID insert
< #80 '('
< #80 OBJECTID i
< #80 ':'
< #80 TYPEID Int
< #80 ')'
< #80 ':'
< #80 TYPEID List
< #80 '{'
< #81 IF
< #81 OBJECTID i
< #81 '<'
< #81 OBJECTID xcar
< #81 THEN
< #82 '('
< #82 NEW
< #82 TYPEID Cons
< #82 ')'
< #82 '.'
< #82 OBJECTID init
< #82 '('
< #82 OBJECTID i
< #82 ','
< #82 OBJECTID self
< #82 ')'
< #83 ELSE
< #84 '('
< #84 NEW
< #84 TYPEID Cons
< #84 ')'
< #84 '.'
< #84 OBJECTID init
< #84 '('
< #84 OBJECTID xcar
< #84 ','
< #84 OBJECTID xcdr
< #84 '.'
< #84 OBJECTID insert
< #84 '('
< #84 OBJECTID i
< #84 ')'
< #84 ')'
< #85 FI
< #86 '}'
< #86 ';'
< #89 OBJECTID rcons
< #89 '('
< #89 OBJECTID i
< #89 ':'
< #89 TYPEID Int
< #89 ')'
< #89 ':'
< #89 TYPEID List
< #89 '{'
< #89 '('
< #89 NEW
< #89 TYPEID Cons
< #89 ')'
< #89 '.'
< #89 OBJECTID init
< #89 '('
< #89 OBJECTID xcar
< #89 ','
< #89 OBJECTID xcdr
< #89 '.'
< #89 OBJECTID rcons
< #89 '('
< #89 OBJECTID i
< #89 ')'
< #89 ')'
< #89 '}'
< #89 ';'
< #91 OBJECTID print_list
< #91 '('
< #91 ')'
< #91 ':'
< #91 TYPEID Object
< #91 '{'
< #92 '{'
< #93 OBJECTID out_int
< #93 '('
< #93 OBJECTID xcar
< #93 ')'
< #93 ';'
< #94 OBJECTID out_string
< #94 '('
< #94 STR_CONST "\n"
< #94 ')'
< #94 ';'
< #95 OBJECTID xcdr
< #95 '.'
< #95 OBJECTID print_list
< #95 '('
< #95 ')'
< #95 ';'
< #96 '}'
< #97 '}'
< #97 ';'
< #98 '}'
< #98 ';'
< #100 CLASS
< #100 TYPEID Nil
< #100 INHERITS
< #100 TYPEID List
< #100 '{'
< #101 OBJECTID isNil
< #101 '('
< #101 ')'
< #101 ':'
< #101 TYPEID Bool
< #101 '{'
< #101 BOOL_CONST true
< #101 '}'
< #101 ';'
< #103 OBJECTID rev
< #103 '('
< #103 ')'
< #103 ':'
< #103 TYPEID List
< #103 '{'
< #103 OBJECTID self
< #103 '}'
< #103 ';'
< #105 OBJECTID sort
< #105 '('
< #105 ')'
< #105 ':'
< #105 TYPEID List
< #105 '{'
< #105 OBJECTID self
< #105 '}'
< #105 ';'
< #107 OBJECTID insert
< #107 '('
< #107 OBJECTID i
< #107 ':'
< #107 TYPEID Int
< #107 ')'
< #107 ':'
< #107 TYPEID List
< #107 '{'
< #107 OBJECTID rcons
< #107 '('
< #107 OBJECTID i
< #107 ')'
< #107 '}'
< #107 ';'
< #109 OBJECTID rcons
< #109 '('
< #109 OBJECTID i
< #109 ':'
< #109 TYPEID Int
< #109 ')'
< #109 ':'
< #109 TYPEID List
< #109 '{'
< #109 '('
< #109 NEW
< #109 TYPEID Cons
< #109 ')'
< #109 '.'
< #109 OBJECTID init
< #109 '('
< #109 OBJECTID i
< #109 ','
< #109 OBJECTID self
< #109 ')'
< #109 '}'
< #109 ';'
< #111 OBJECTID print_list
< #111 '('
< #111 ')'
< #111 ':'
< #111 TYPEID Object
< #111 '{'
< #111 BOOL_CONST true
< #111 '}'
< #111 ';'
< #113 '}'
< #113 ';'
< #116 CLASS
< #116 TYPEID Main
< #116 INHERITS
< #116 TYPEID IO
< #116 '{'
< #118 OBJECTID l
< #118 ':'
< #118 TYPEID List
< #118 ';'
< #121 OBJECTID iota
< #121 '('
< #121 OBJECTID i
< #121 ':'
< #121 TYPEID Int
< #121 ')'
< #121 ':'
< #121 TYPEID List
< #121 '{'
< #122 '{'
< #123 OBJECTID l
< #123 ASSIGN
< #123 NEW
< #123 TYPEID Nil
< #123 ';'
< #124 '('
< #124 LET
< #124 OBJECTID j
< #124 ':'
< #124 TYPEID Int
< #124 ASSIGN
< #124 INT_CONST 0
< #124 IN
< #125 WHILE
< #125 OBJECTID j
< #125 '<'
< #125 OBJECTID i
< #126 LOOP
< #127 '{'
< #128 OBJECTID l
< #128 ASSIGN
< #128 '('
< #128 NEW
< #128 TYPEID Cons
< #128 ')'
< #128 '.'
< #128 OBJECTID init
< #128 '('
< #128 OBJECTID j
< #128 ','
< #128 OBJECTID l
< #128 ')'
< #128 ';'
< #129 OBJECTID j
< #129 ASSIGN
< #129 OBJECTID j
< #129 '+'
< #129 INT_CONST 1
< #129 ';'
< #130 '}'
< #131 POOL
< #132 ')'
< #132 ';'
< #133 OBJECTID l
< #133 ';'
< #134 '}'
< #135 '}'
< #135 ';'
< #137 OBJECTID main
< #137 '('
< #137 ')'
< #137 ':'
< #137 TYPEID Object
< #137 '{'
< #138 '{'
< #139 OBJECTID out_string
< #139 '('
< #139 STR_CONST "How many numbers to sort?"
< #139 ')'
< #139 ';'
< #140 OBJECTID iota
< #140 '('
< #140 OBJECTID in_int
< #140 '('
< #140 ')'
< #140 ')'
< #140 '.'
< #140 OBJECTID rev
< #140 '('
< #140 ')'
< #140 '.'
< #140 OBJECTID sort
< #140 '('
< #140 ')'
< #140 '.'
< #140 OBJECTID print_list
< #140 '('
< #140 ')'
< #140 ';'
< #141 '}'
< #142 '}'
< #142 ';'
< #143 '}'
< #143 ';'
---
> (*
>    This file presents a fairly large example of Cool programming.  The
> class List defines the names of standard list operations ala Scheme:
> car, cdr, cons, isNil, rev, sort, rcons (add an element to the end of
> the list), and print_list.  In the List class most of these functions
> are just stubs that abort if ever called.  The classes Nil and Cons
> inherit from List and define the same operations, but now as
> appropriate to the empty list (for the Nil class) and for cons cells (for
> the Cons class).
> 
> The Main class puts all of this code through the following silly 
> test exercise:
> 
>    1. prompt for a number N
>    2. generate a list of numbers 0..N-1
>    3. reverse the list
>    4. sort the list
>    5. print the sorted list
> 
> Because the sort used is a quadratic space insertion sort, sorting
> moderately large lists will cause spim to run out of memory.
> *)
> 
> Class List inherits IO { 
>         (* Since abort() returns Object, we need something of
> 	   type Bool at the end of the block to satisfy the typechecker. 
>            This code is unreachable, since abort() halts the program. *)
> 	isNil() : Bool { { abort(); true; } };
> 
> 	cons(hd : Int) : Cons {
> 	  (let new_cell : Cons <- new Cons in
> 		new_cell.init(hd,self)
> 	  )
> 	};
> 
> 	(* 
> 	   Since abort "returns" type Object, we have to add
> 	   an expression of type Int here to satisfy the typechecker.
> 	   This code is, of course, unreachable.
>         *)
> 	car() : Int { { abort(); new Int; } };
> 
> 	cdr() : List { { abort(); new List; } };
> 
> 	rev() : List { cdr() };
> 
> 	sort() : List { cdr() };
> 
> 	insert(i : Int) : List { cdr() };
> 
> 	rcons(i : Int) : List { cdr() };
> 	
> 	print_list() : Object { abort() };
> };
> 
> Class Cons inherits List {
> 	xcar : Int;  -- We keep the car in cdr in attributes.
> 	xcdr : List; -- Because methods and features must have different names,
> 		     -- we use xcar and xcdr for the attributes and reserve
> 		     -- cons and car for the features.
> 
> 	isNil() : Bool { false };
> 
> 	init(hd : Int, tl : List) : Cons {
> 	  {
> 	    xcar <- hd;
> 	    xcdr <- tl;
> 	    self;
> 	  }
> 	};
> 	  
> 	car() : Int { xcar };
> 
> 	cdr() : List { xcdr };
> 
> 	rev() : List { (xcdr.rev()).rcons(xcar) };
> 
> 	sort() : List { (xcdr.sort()).insert(xcar) };
> 
> 	insert(i : Int) : List {
> 		if i < xcar then
> 			(new Cons).init(i,self)
> 		else
> 			(new Cons).init(xcar,xcdr.insert(i))
> 		fi
> 	};
> 
> 
> 	rcons(i : Int) : List { (new Cons).init(xcar, xcdr.rcons(i)) };
> 
> 	print_list() : Object {
> 		{
> 		     out_int(xcar);
> 		     out_string("\n");
> 		     xcdr.print_list();
> 		}
> 	};
> };
> 
> Class Nil inherits List {
> 	isNil() : Bool { true };
> 
>         rev() : List { self };
> 
> 	sort() : List { self };
> 
> 	insert(i : Int) : List { rcons(i) };
> 
> 	rcons(i : Int) : List { (new Cons).init(i,self) };
> 
> 	print_list() : Object { true };
> 
> };
> 
> 
> Class Main inherits IO {
> 
> 	l : List;
> 
> 	(* iota maps its integer argument n into the list 0..n-1 *)
> 	iota(i : Int) : List {
> 	    {
> 		l <- new Nil;
> 		(let j : Int <- 0 in
> 		   while j < i 
> 		   loop 
> 		     {
> 		       l <- (new Cons).init(j,l);
> 		       j <- j + 1;
> 		     } 
> 		   pool
> 		);
> 		l;
> 	    }
> 	};		
> 
> 	main() : Object {
> 	   {
> 	     out_string("How many numbers to sort?");
> 	     iota(in_int()).rev().sort().print_list();
> 	   }
> 	};
> };			    
> 
> 
> 
> 
> 
pass!
